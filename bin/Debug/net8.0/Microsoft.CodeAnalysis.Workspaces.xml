<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces</name>
    </assembly>
    <members>
        <member name="F:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.Annotation">
            <summary>
            The annotation normally used on nodes to request case correction.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the provided document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the spans of any nodes annotated with the provided
            annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the provided spans.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrect(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Host.SolutionServices,System.Threading.CancellationToken)">
            <summary>
            Case correct only things that don't require semantic information
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the spans in the provided document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService.CaseCorrect(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects only things that don't require semantic information
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
             <summary>
             Determine whether we can change the namespace for given <paramref name="container"/> in the document.
             Linked documents are not supported, except for a regular document in a multi-targeting project, 
             where the container node must be consistent among all linked documents.
             Here's the additional requirements on <paramref name="container"/> to use this service:
             
             - If <paramref name="container"/> is a namespace declaration node:
                1. Doesn't contain or is nested in other namespace declarations
                2. The name of the namespace is valid (i.e. no errors)
                3. No partial type declared in the namespace. Otherwise its multiple declarations will
                   end up in different namespace.
            
             - If <paramref name="container"/> is a compilation unit node:
                1. It must contain no namespace declaration
                2. No partial type declared in the document. Otherwise its multiple declarations will
                   end up in different namespace.
                   
             - Otherwise, an <see cref="T:System.ArgumentException"/> will be thrown.
               
             Returns <see langword="true"/> only when all the requirements above are met.
             </summary>
             <remarks>
             While this service might be used by features that change namespace based on some property of the document
             (e.g. Sync namespace refactoring), those logic is implemented by those individual features and isn't part 
             of the IChangeNamespaceService service.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.ChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Threading.CancellationToken)">
            <summary>
            Change namespace for given <paramref name="container"/> to the name specified by <paramref name="targetNamespace"/>.
            Everything declared in the <paramref name="container"/> will be moved to the new namespace. 
            Change will only be made if <see cref="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> returns <see langword="true"/> and <paramref name="targetNamespace"/>
            is a valid name for namespace. Use "" for <paramref name="targetNamespace"/> to specify the global namespace.
            
            An <see cref="T:System.ArgumentException"/> will be thrown if:
            1. <paramref name="container"/> is not a namespace declaration or a compilation unit node.
            2. <paramref name="targetNamespace"/> is null or contains an invalid character.
            </summary>
            <remarks>
            If the declared namespace for <paramref name="container"/> is already identical to <paramref name="targetNamespace"/>, then it will be
            a no-op and original solution will be returned.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.TryChangeTopLevelNamespacesAsync(Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)">
            <summary>
            Using only the top level namespace declarations of a document, change all of them to the target namespace. Will only
            use namespace containers considered valid by <see cref="M:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService.CanChangeNamespaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.AbstractClassificationService.AddRange(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Collections.Generic.List{Microsoft.CodeAnalysis.Classification.ClassifiedSpan})">
            <summary>
            Helper to add all the values of <paramref name="temp"/> into <paramref name="result"/>
            without causing any allocations or boxing of enumerators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.ClassificationTypeNames.AdditiveTypeNames">
            <summary>
            Additive classifications types supply additional context to other classifications.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.GetClassifiedSpansAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Classifies the provided <paramref name="span"/> in the given <paramref name="document"/>. This will do this
            using an appropriate <see cref="T:Microsoft.CodeAnalysis.Classification.IClassificationService"/> if that can be found.  <see
            cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/> will be returned if this fails.
            </summary>
            <param name="includeAdditiveSpans">Whether or not 'additive' classification spans are included in the
            results or not.  'Additive' spans are things like 'this variable is static' or 'this variable is
            overwritten'.  i.e. they add additional information to a previous classification.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.GetClassifiedSpansAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Classifies the provided <paramref name="spans"/> in the given <paramref name="document"/>. This will do this
            using an appropriate <see cref="T:Microsoft.CodeAnalysis.Classification.IClassificationService"/> if that can be found.  <see
            cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/> will be returned if this fails.
            </summary>
            <param name="document">the current document.</param>
            <param name="spans">The non-intersecting portions of the document to get classified spans for.</param>
            <param name="options">The options to use when getting classified spans.</param>
            <param name="includeAdditiveSpans">Whether or not 'additive' classification spans are included in the
            results or not.  'Additive' spans are things like 'this variable is static' or 'this variable is
            overwritten'.  i.e. they add additional information to a previous classification.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.AdjustSpans(Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Ensures that all spans in <paramref name="spans"/> do not go beyond the spans in <paramref
            name="widenedSpan"/>. Any spans that are entirely outside of <paramref name="widenedSpan"/> are replaced
            with <see langword="default"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.MergeParts(Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan})">
            <summary>
            Adds all semantic parts to final parts, and adds all portions of <paramref name="syntaxParts"/> that do not
            overlap with any semantic parts as well.  All final parts will be non-empty.  Both <paramref
            name="syntaxParts"/> and <paramref name="semanticParts"/> must be sorted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.MergeParts``2(Microsoft.CodeAnalysis.Collections.SegmentedList{``0},Microsoft.CodeAnalysis.Collections.SegmentedList{``0},Microsoft.CodeAnalysis.Collections.SegmentedList{``0},System.Func{``0,Microsoft.CodeAnalysis.Text.TextSpan},System.Func{``0,Microsoft.CodeAnalysis.Text.TextSpan,``0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.MergeParts(Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifier.GetClassifiedSpans(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Returns classified spans in ascending <see cref="T:Microsoft.CodeAnalysis.Classification.ClassifiedSpan"/> order.
            <see cref="T:Microsoft.CodeAnalysis.Classification.ClassifiedSpan"/>s may have the same <see cref="P:Microsoft.CodeAnalysis.Classification.ClassifiedSpan.TextSpan"/>. This occurs when there are multiple
            <see cref="P:Microsoft.CodeAnalysis.Classification.ClassifiedSpan.ClassificationType"/>s for the same region of code. For example, a reference to a static method
            will have two spans, one that designates it as a method, and one that designates it as static.
            <see cref="T:Microsoft.CodeAnalysis.Classification.ClassifiedSpan"/>s may also have overlapping <see cref="P:Microsoft.CodeAnalysis.Classification.ClassifiedSpan.TextSpan"/>s. This occurs when there are
            strings containing regex and/or escape characters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddLexicalClassifications(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for the span of text specified.  Classification should be
            performed as quickly as possible, and should process the text in a lexical fashion.
            This allows classification results to be shown to the user when a file is opened before
            any additional compiler information is available for the text.
            
            Important: The classification should not consider the context the text exists in, and how
            that may affect the final classifications.  This may result in incorrect classification
            (i.e. identifiers being classified as keywords).  These incorrect results will be patched
            up when the lexical results are superseded by the calls to AddSyntacticClassifications.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSyntacticClassifications(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSyntacticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/>
            <remarks>This method is optional and only should be implemented by languages that support
            syntax.  If the language does not support syntax, callers should use
            <see cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSyntacticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/> instead.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSyntacticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for the span of text specified.  The syntax of the document 
            can be accessed to provide more correct classifications.  For example, the syntax can
            be used to determine if a piece of text that looks like a keyword should actually be
            considered an identifier in its current context.
            </summary>
            <param name="document">the current document.</param>
            <param name="textSpans">The non-intersecting portions of the document to add classified spans for.</param>
            <param name="result">The list to add the spans to.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for the span of text specified.  Semantics of the language can be used to
            provide richer information for constructs where syntax is insufficient. For example, semantic information
            can be used to determine if an identifier should be classified as a type, structure, or something else
            entirely.
            </summary>
            <param name="document">the current document.</param>
            <param name="textSpans">The non-intersecting portions of the document to add classified spans for.</param>
            <param name="options">The options to use when adding spans.</param>
            <param name="result">The list to add the spans to.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <remarks>
            This will not include classifications for embedded language constructs in string literals.  For that use
            <see cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddEmbeddedLanguageClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddEmbeddedLanguageClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for embedded language string literals (e.g. Regex/Json strings) in the span of
            text specified.
            </summary>
            <param name="document">the current document.</param>
            <param name="textSpans">The non-intersecting portions of the document to add classified spans for.</param>
            <param name="options">The options to use when adding spans.</param>
            <param name="result">The list to add the spans to.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AdjustStaleClassification(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Classification.ClassifiedSpan)">
             <summary>
             Adjust a classification from a previous version of text accordingly based on the current
             text.  For example, if a piece of text was classified as an identifier in a previous version,
             but a character was added that would make it into a keyword, then indicate that here.
            
             This allows the classified to quickly fix up old classifications as the user types.  These
             adjustments are allowed to be incorrect as they will be superseded by calls to get the
             syntactic and semantic classifications for this version later.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.ComputeSyntacticChangeRangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Determines the range of the documents that should be considered syntactically changed after an edit.  In
            language systems that can reuse major parts of a document after an edit, and which would not need to
            recompute classifications for those reused parts, this can speed up processing on a host by not requiring
            the host to reclassify all the source in view, but only the source that could have changed.
            <para>
            If determining this is not possible, or potentially expensive, <see langword="null"/> can be returned to
            indicate that the entire document should be considered changed and should be syntactically reclassified.
            </para>
            <para>
            Implementations should attempt to abide by the provided timeout as much as they can, returning the best
            information available at that point.  As this can be called in performance critical scenarios, it is better
            to return quickly with potentially larger change span (including that of the full document) rather than
            spend too much time computing a very precise result.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.ComputeSyntacticChangeRange(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.ComputeSyntacticChangeRangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.TimeSpan,System.Threading.CancellationToken)"/>
            <remarks>This method is optional and only should be implemented by languages that support
            syntax.  If the language does not support syntax, callers should use
            <see cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.ComputeSyntacticChangeRangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.TimeSpan,System.Threading.CancellationToken)"/> instead.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IRemoteSemanticClassificationService.GetClassificationsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationType,Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the cached semantic classifications for the specified document and text spans.
            </summary>
            <param name="solutionChecksum">The checksum of the solution containing the document.</param>
            <param name="documentId">The ID of the document to get classified spans for.</param>
            <param name="textSpans">The non-intersecting portions of the document to get classified spans for.</param>
            <param name="type">The type of classified spans to get.</param>
            <param name="options">The options to use when getting classified spans.</param>
            <param name="isFullyLoaded">Whether or not the document is fully loaded.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The classified spans for the specified document and text spans.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IRemoteSemanticClassificationService.GetCachedClassificationsAsync(Microsoft.CodeAnalysis.Storage.DocumentKey,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationType,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Tries to get cached semantic classifications for the specified document and the specified <paramref
            name="textSpans"/>.  Will return an empty array not able to.
            </summary>
            <param name="documentKey">The key of the document to get cached classified spans for.</param>
            <param name="textSpans">The non-intersecting portions of the document to get cached classified spans for.</param>
            <param name="type">The type of classified spans to get.</param>
            <param name="checksum">Pass in <see cref="P:Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums.Text"/>.  This will ensure that the cached
            classifications are only returned if they match the content the file currently has.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The cached classified spans for the specified document and text spans.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Classification.SerializableClassifiedSpans">
            <summary>
            For space efficiency, we encode classified spans as triples of ints in one large array.  The
            first int is the index of classification type in <see cref="F:Microsoft.CodeAnalysis.Classification.SerializableClassifiedSpans.ClassificationTypes"/>, and the
            second and third ints encode the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.SerializableClassifiedSpans.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Int32})">
            <summary>
            For space efficiency, we encode classified spans as triples of ints in one large array.  The
            first int is the index of classification type in <see cref="F:Microsoft.CodeAnalysis.Classification.SerializableClassifiedSpans.ClassificationTypes"/>, and the
            second and third ints encode the span.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxNodeTypes">
            <summary>
            The syntax node types this classifier is able to classify. This list must be the precise node types matches
            (using <code>n.GetType().Equals(t)</code>).  Subtyping type checks are not supported here.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxTokenKinds">
            <summary>
            The syntax token kinds this classifier is able to classify
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Classification.ClassificationOptions,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            This method will be called for all nodes that match the types specified by the <see cref="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxNodeTypes"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Classification.ClassificationOptions,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            This method will be called for all tokens that match the kinds specified by the <see cref="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxTokenKinds"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.AddLexicalClassifications(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddLexicalClassifications(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.AddSyntacticClassifications(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSyntacticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier}},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier}},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.AddSemanticClassifications(Microsoft.CodeAnalysis.SemanticModel,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier}},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier}},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier}},System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier}},Microsoft.CodeAnalysis.Collections.SegmentedList{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.FixClassification(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Classification.ClassifiedSpan)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AdjustStaleClassification(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Classification.ClassifiedSpan)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService.ComputeSyntacticChangeRange(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.TimeSpan,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Classification.IClassificationService.ComputeSyntacticChangeRangeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.TimeSpan,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Classification.SyntacticChangeRangeComputer">
            <summary>
            Computes a syntactic text change range that determines the range of a document that was changed by an edit. The
            portions outside this change range are guaranteed to be syntactically identical (see <see
            cref="M:Microsoft.CodeAnalysis.SyntaxNode.IsIncrementallyIdenticalTo(Microsoft.CodeAnalysis.SyntaxNode)"/>).  This algorithm is intended to be <em>fast</em>.  It is
            technically linear in the number of nodes and tokens that may need to examined.  However, in practice, it should
            operate in sub-linear time as it will bail the moment tokens don't match, and it's able to skip over matching
            nodes fully without examining the contents of those nodes.  This is intended for consumers that want a
            reasonably accurate change range computer, but do not want to spend an inordinate amount of time getting the
            most accurate and minimal result possible.
            </summary>
            <remarks>
            This computation is not guaranteed to be minimal.  It may return a range that includes parts that are unchanged.
            This means it is also legal for the change range to just specify the entire file was changed. The quality of
            results will depend on how well the parsers did with incremental parsing, and how much time is given to do the
            comparison.  In practice, for large files (i.e. 15kloc) with standard types of edits, this generally returns
            results in around 50-100 usecs on a i7 3GHz desktop.
            <para>
            This algorithm will respect the timeout provided to the best of abilities.  If any information has been computed
            when the timeout elapses, it will be returned.
            </para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation">
            <summary>
            Apply this annotation to a SyntaxNode to indicate a conflict may exist that requires user understanding and acknowledgment before taking action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.NavigationAnnotation">
            <summary>
            Apply this annotation to an appropriate Syntax element to request that it should be 
            navigated to by the user after a code action is applied.  If present the host should
            try to place the user's caret at the beginning of the element.
            </summary>
            <remarks>
            By using a <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/> this navigation location will be resilient
            to the transformations performed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> infrastructure.  
            Namely it will be resilient to the formatting, reduction or case correction that
            automatically occures.  This allows a code action to specify a desired location for
            the user caret to be placed without knowing what actual position that location will
            end up at when the action is finally applied.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation">
            <summary>
            Apply this annotation to an appropriate SyntaxNode to request that it should be renamed by the user after the action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.WarningAnnotation">
            <summary>
            Apply this annotation to a SyntaxNode to indicate that a warning message should be presented to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeAction">
            <summary>
            An action produced by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeAction.CanBeHighPriorityTag">
            <summary>
            Special tag that indicates that it's this is a privileged code action that is allowed to use the <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.High"/> priority class.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeAction.RequiresNonDocumentChange">
            <summary>
            Tag we use to convey that this code action should only be shown if it's in a host that allows for
            non-document changes.  For example if it needs to make project changes, or if will show host-specific UI.
            <para>
            Note: if the bulk of code action is just document changes, and it does some optional things beyond that
            (like navigating the user somewhere) this should not be set.  Such a code action is still usable in all
            hosts and should be shown to the user.  It's only if the code action can truly not function should this
            tag be provided.
            </para>
            <para>
            Currently, this also means that we presume that all 3rd party code actions do not require non-document
            changes and we will show them all in all hosts.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.Title">
            <summary>
            A short title describing the action that may appear in a menu.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey">
             <summary>
             Two code actions are treated as equivalent if they have equal non-null <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> values and were generated
             by the same <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
             </summary>
             <remarks>
             Equivalence of code actions affects some Visual Studio behavior. For example, if multiple equivalent
             code actions result from code fixes or refactorings for a single Visual Studio light bulb instance,
             the light bulb UI will present only one code action from each set of equivalent code actions.
             Additionally, a Fix All operation will apply only code actions that are equivalent to the original code action.
            
             If two code actions that could be treated as equivalent do not have equal <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> values, Visual Studio behavior
             may be less helpful than would be optimal. If two code actions that should be treated as distinct have
             equal <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> values, Visual Studio behavior may appear incorrect.
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.Priority">
            <summary>
            Priority of this particular action within a group of other actions.  Less relevant actions should override
            this and specify a lower priority so that more important actions are easily accessible to the user.  Returns
            <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Default"/> if not overridden.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputePriority">
            <summary>
            Computes the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority"/> group this code action should be presented in. Legal values
            this can be must be between <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Lowest"/> and <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.High"/>.
            </summary>
            <remarks>
            Values outside of this range will be clamped to be within that range.  Requests for <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.High"/> may be downgraded to <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Default"/> as they
            poorly behaving high-priority items can cause a negative user experience.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.Tags">
            <summary>
            Descriptive tags from <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/>.
            These tags may influence how the item is displayed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.NestedActions">
            <summary>
            Child actions contained within this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.  Can be presented in a host to provide more
            potential solution actions to a particular problem.  To create a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with nested
            actions, use <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.AdditionalPreviewFlavors">
            <summary>
            Code actions that should be presented as hyperlinks in the code action preview pane,
            similar to FixAll scopes and Preview Changes but may not apply to ALL CodeAction types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.NestedCodeActions">
            <summary>
            Bridge method for sdk. https://github.com/dotnet/roslyn-sdk/issues/1136 tracks removing this.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.IsInlinable">
            <summary>
            If this code action contains <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.NestedActions"/>, this property provides a hint to hosts as to
            whether or not it's ok to elide this code action and just present the nested actions instead.  When a host
            already has a lot of top-level actions to show, it should consider <em>not</em> inlining this action, to
            keep the number of options presented to the user low.  However, if there are few options to show to the
            user, inlining this action could be beneficial as it would allow the user to see and choose one of the
            nested options with less steps.  To create a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with nested actions, use <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.CustomTags">
            <summary>
            Gets custom tags for the CodeAction.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeAction._providerTypeForTelemetry">
            <summary>
            Lazily set provider type that registered this code action.
            Used for telemetry purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.AddCustomTagAndTelemetryInfo(Microsoft.CodeAnalysis.Host.Mef.CodeChangeProviderMetadata,System.Object)">
            <summary>
            Used by the CodeFixService and CodeRefactoringService to add the Provider Name as a CustomTag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            The sequence of operations that define the code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(Microsoft.CodeAnalysis.Solution,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            The sequence of operations that define the code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            The sequence of operations used to construct a preview.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that includes custom <see
            cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that includes custom <see
            cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s.  Prefer overriding this method over <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)"/> when computation is long running and progress should be
            shown to the user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputePreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that has a set of preview operations that are different
            than the operations produced by <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.Threading.CancellationToken)">
            <summary>
            Computes all changes for an entire solution. Override this method if you want to implement a <see
            cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes more than one document.  Override <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)"/> to report progress
            progress while computing the operations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Computes all changes for an entire solution. Override this method if you want to implement a <see
            cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes more than one document. Prefer overriding this method over <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.Threading.CancellationToken)"/> when computation is long running and progress should be
            shown to the user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedDocumentAsync(System.Threading.CancellationToken)">
            <summary>
            Computes changes for a single document. Override this method if you want to implement a <see
            cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes a single document.  Override <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedDocumentAsync(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)"/> to report progress
            progress while computing the operations.
            </summary>
            <remarks>
            All code actions are expected to operate on solutions. This method is a helper to simplify the
            implementation of <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.Threading.CancellationToken)"/> for code actions that only need
            to change one document.
            </remarks>
            <exception cref="T:System.NotSupportedException">If this code action does not support changing a single
            document.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedDocumentAsync(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Computes changes for a single document. Override this method if you want to implement a <see
            cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes a single document. Prefer overriding this method over <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedDocumentAsync(System.Threading.CancellationToken)"/> when computation is long running and progress should be
            shown to the user.
            </summary>
            <remarks>
            All code actions are expected to operate on solutions. This method is a helper to simplify the
            implementation of <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.Threading.CancellationToken)"/> for code actions that only need
            to change one document.
            </remarks>
            <exception cref="T:System.NotSupportedException">If this code action does not support changing a single
            document.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionInternalAsync(Microsoft.CodeAnalysis.Solution,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            used by batch fixer engine to get new solution
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessAsync(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeActionOperation},System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>'s.
            </summary>
            <param name="operations">A list of operations.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A new list of operations with post processing steps applied to any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>'s.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessChangesAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to solution changes, like formatting and simplification.
            </summary>
            <param name="changedSolution">The solution changed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="cancellationToken">A cancellation token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to a single document:
              Reducing nodes annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation"/>
              Formatting nodes annotated with <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation"/>
            </summary>
            <param name="document">The document changed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A document with the post processing changes applied.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> for a change to a single <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            Use this factory when the change is expensive to compute and should be deferred until requested.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="createChangedDocument">Function to create the <see cref="T:Microsoft.CodeAnalysis.Document"/>.</param>
            <param name="equivalenceKey">Optional value used to determine the equivalence of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with other <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>s. See <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String)"/>
            <param name="priority">Code action priority</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}},System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> for a change to more than one <see cref="T:Microsoft.CodeAnalysis.Document"/> within a <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            Use this factory when the change is expensive to compute and should be deferred until requested.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="createChangedSolution">Function to create the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.</param>
            <param name="equivalenceKey">Optional value used to determine the equivalence of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with other <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>s. See <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}},System.String,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> for a change to more than one <see cref="T:Microsoft.CodeAnalysis.Document"/> within a <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            Use this factory when the change is expensive to compute and should be deferred until requested.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="createChangedSolution">Function to create the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.</param>
            <param name="equivalenceKey">Optional value used to determine the equivalence of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with other <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>s. See <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}},System.String,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}},System.String,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Boolean)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> representing a group of code actions.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> group.</param>
            <param name="nestedActions">The code actions within the group.</param>
            <param name="isInlinable"><see langword="true"/> to allow inlining the members of the group into the parent;
            otherwise, <see langword="false"/> to require that this group appear as a group with nested actions.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Boolean,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Boolean)"/>
            <param name="priority">Priority of the code action</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.SimpleCodeAction.CreatedFromFactoryMethod">
            <summary>
            Indicates if this CodeAction was created using one of the 'CodeAction.Create' factory methods.
            This is used in <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetTelemetryId(System.Nullable{Microsoft.CodeAnalysis.CodeFixes.FixAllScope})"/> to determine the appropriate type
            name to log in the CodeAction telemetry.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeAction.s_cleanupPasses">
            <summary>
            We do cleanup in N serialized passes.  This allows us to process all documents in parallel, while only forking
            the solution N times *total* (instead of N times *per* document).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority">
            <summary>
            Priority of a particular code action produced by either a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> or a <see
            cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.  Code actions use priorities to group themselves, with lower priority actions showing
            up after higher priority ones.  Providers should put less relevant code actions into lower priority buckets to
            have them appear later in the UI, allowing the user to get to important code actions more quickly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Lowest">
            <summary>
            Lowest priority code actions.  Will show up after <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Low"/> priority items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Low">
            <summary>
            Low priority code action.  Will show up after <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Default"/> priority items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Default">
            <summary>
            Medium priority code action.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.High">
            <summary>
            High priority code action. Note: High priority is simply a request on the part of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.
            The core engine may automatically downgrade these items to <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Default"/> priority.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority">
            <summary>
            Priority class that a particular <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> or <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> should
            run at.  Providers are run in priority order, allowing the results of higher priority providers to be computed
            and shown to the user without having to wait on, or share computing resources with, lower priority providers.
            Providers should choose lower priority classes if they are either:
            <list type="number">
            <item>Very slow.  Slow providers will impede computing results for other providers in the same priority class.
            So running in a lower one means that fast providers can still get their results to users quickly.</item>
            <item>Less relevant.  Providers that commonly show available options, but those options are less likely to be
            taken, should run in lower priority groups.  This helps ensure their items are still there when the user wants
            them, but aren't as prominently shown.</item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Lowest">
            <summary>
            Only lowest priority suppression and configuration fix providers should be run.  Specifically, <see
            cref="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider"/> providers will be run. NOTE: This priority is reserved for suppression and
            configuration fix providers and should not be used by regular code fix providers and refactoring providers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Low">
            <summary>
            Run the priority below <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default"/> priority.  The provider may run slow, or its results may be
            commonly less relevant for the user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default">
            <summary>
            Run this provider at default priority.  The provider will run in reasonable speeds and provide results that are
            commonly relevant to the user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.High">
            <summary>
            Run this provider at high priority. Note: High priority is simply a request on the part of a provider. The core
            engine may automatically downgrade these items to <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default"/> priority.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriorityExtensions.Clamp(Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority,System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Clamps the value of <paramref name="priority"/> (which could be any integer) to the legal range of values
            present in <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that can vary with user specified options.  Override one of <see
            cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.Threading.CancellationToken)"/> or <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)"/> to actually compute the operations for this action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)">
            <summary>
            Gets the options to use with this code action.
            This method is guaranteed to be called on the UI thread.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>An implementation specific object instance that holds options for applying the code action.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOperationsAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s for this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> given the specified options.
            </summary>
            <param name="options">An object instance returned from a prior call to <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Override this method to compute the operations that implement this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.
            </summary>
            <param name="options">An object instance returned from a call to <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Override this method to compute the operations that implement this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>. Prefer
            overriding this method over <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.Threading.CancellationToken)"/> when computation
            is long running and progress should be shown to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for applying solution changes to a workspace.
            <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> may return at most one
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>. Hosts may provide custom handling for 
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>s, but if a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> requires custom
            host behavior not supported by a single <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>, then instead:
            <list type="bullet">
            <description><text>Implement a custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> and <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>s</text></description>
            <description><text>Do not return any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> from <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/></text></description>
            <description><text>Directly apply any workspace edits</text></description>
            <description><text>Handle any custom host behavior</text></description>
            <description><text>Produce a preview for <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(System.Threading.CancellationToken)"/> 
              by creating a custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.PreviewOperation"/> or returning a single <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>
              to use the built-in preview mechanism</text></description>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation.#ctor(Microsoft.CodeAnalysis.Solution)">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for applying solution changes to a workspace.
            <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> may return at most one
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>. Hosts may provide custom handling for 
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>s, but if a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> requires custom
            host behavior not supported by a single <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>, then instead:
            <list type="bullet">
            <description><text>Implement a custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> and <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>s</text></description>
            <description><text>Do not return any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> from <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/></text></description>
            <description><text>Directly apply any workspace edits</text></description>
            <description><text>Handle any custom host behavior</text></description>
            <description><text>Produce a preview for <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(System.Threading.CancellationToken)"/> 
              by creating a custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.PreviewOperation"/> or returning a single <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>
              to use the built-in preview mechanism</text></description>
            </list>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation">
            <summary>
            Represents a single operation of a multi-operation code action.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Title">
            <summary>
            A short title describing of the effect of the operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Apply(Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Called by the host environment to apply the effect of the operation.
            This method is guaranteed to be called on the UI thread.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.TryApplyAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Solution,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.Threading.CancellationToken)">
            <summary>
            Called by the host environment to apply the effect of the operation.
            This method is guaranteed to be called on the UI thread.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.ApplyDuringTests">
            <summary>
            Operations may make all sorts of changes that may not be appropriate during testing
            (like popping up UI). So, by default, we don't apply them unless the operation asks
            for that to happen.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation">
            <summary>
            A code action operation for requesting a document be opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation.#ctor(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            A code action operation for requesting a document be opened in the host environment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.PreviewOperation">
            <summary>
            Represents a preview operation for generating a custom user preview for the operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.PreviewOperation.GetPreviewAsync(System.Threading.CancellationToken)">
            <summary>
            Gets a custom preview control for the operation.
            If preview is null and <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Title"/> is non-null, then <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Title"/> is used to generate the preview.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetPreviousTokenStartPosition(Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Get the proper start position based on the span marker type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetNextTokenEndPosition(Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Get the proper end position based on the span marker type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.AnnotateNodeForTextSpans(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Inject annotations into the node so that it can re-calculate spans for each code cleaner after each tree transformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetNonOverlappingSpans(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Make sure annotations are positioned outside of any spans. If not, merge two adjacent spans to one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetTokensAroundSpan(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
             <summary>
             Retrieves four tokens around span like below.
            
             [previousToken][startToken][SPAN][endToken][nextToken]
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetSpanAlignedToTokens(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            Adjust provided span to align to either token's start position or end position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Find closest token (including one in structured trivia) right of given position
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Find closest token (including one in structured trivia) left of given position
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType">
            <summary>
            Enum that indicates type of span marker
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.Normal">
            <summary>
            Normal case
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.BeginningOfFile">
            <summary>
            Span starts at the beginning of the tree
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.EndOfFile">
            <summary>
            Span ends at the end of the tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker">
            <summary>
            Internal annotation type to mark span location in the tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker.Type">
            <summary>
            Indicates the current marker type
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker.OppositeMarkerType">
            <summary>
            Indicates how to find the other side of the span marker if it is missing
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner">
            <summary>
            Static CodeCleaner class that provides default code cleaning behavior.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.GetDefaultProviders(Microsoft.CodeAnalysis.Document)">
            <summary>
            Return default code cleaners for a given document.
            
            This can be modified and given to the Cleanup method to provide different cleaners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Cleans up the whole document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Cleans up the document marked with the provided annotation.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided span in the document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided spans in the document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,Microsoft.CodeAnalysis.Host.SolutionServices,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided span in the node.
            This will only cleanup stuff that doesn't require semantic information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,Microsoft.CodeAnalysis.Host.SolutionServices,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided spans in the node.
            This will only cleanup stuff that doesn't require semantic information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService">
            <summary>
            Internal code cleanup service interface.
            
            This is not supposed to be used directly. It just provides a way to get the right service from each language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.GetDefaultProviders">
            <summary>
            Returns the default code cleaners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,Microsoft.CodeAnalysis.Host.SolutionServices,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            
            This will do cleanups that don't require any semantic information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ExportCodeCleanupProvider">
            <summary>
            Specifies the exact type of the code cleanup exported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider">
            <summary>
            A code cleaner that requires semantic information to do its job.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.Name">
            <summary>
            Returns the name of this provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Threading.CancellationToken)">
            <summary>
            This should apply its code clean up logic to the spans of the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,Microsoft.CodeAnalysis.Host.SolutionServices,System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            
            This will do cleanups that don't require any semantic information
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DefaultFixAllProviderHelpers">
            <summary>
            Default implementation of a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that efficiently handles the dispatch logic for fixing
            entire solutions.  Used by <see cref="T:Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider"/> and <see cref="T:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DocumentBasedFixAllProviderHelpers">
            <summary>
            Helper methods for DocumentBasedFixAllProvider common to code fixes and refactorings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllKind">
            <summary>
            An enum to distinguish if we are performing a Fix all occurences for a code fix or a code refactoring.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllLogger">
            <summary>
            Fix all occurrences logging.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo">
            <summary>
            Contains computed information for a given <see cref="F:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo.FixAllProvider"/>, such as supported diagnostic Ids and supported <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo.Create(System.Object)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo"/> for the given code fix provider or suppression fix provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo.CreateWithCodeFixer(Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo"/> for the given code fix provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo.CreateWithCodeRefactoring(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo"/> for the given code refactoring provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo.CreateWithSuppressionFixer(Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo"/> for the given suppression fix provider.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext">
            <summary>
            Represents a FixAllContext for code fixes or refactorings. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllProvider">
            <summary>
            Represents a FixAllProvider for code fixes or refactorings. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState">
            <summary>
            Represents internal FixAllState for code fixes or refactorings. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.Provider">
            <summary>
            Underlying code fix provider or code refactoring provider for the fix all occurrences fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllSpanMappingService">
            <summary>
            Language service for mapping spans for specific <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/>s for fix all occurences code fix.
            Every language that wants to support span based FixAll scopes, such as <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/>,
            <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/>, should implement this language service. Non-span based FixAll scopes,
            such as <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document"/>, <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project"/> and <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution"/>
            do not require such a span mapping, and this service will never be called for these scopes. This language service
            does not need to be implemented by languages that only intend to support these non-span based FixAll scopes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllSpanMappingService.GetFixAllSpansAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.Threading.CancellationToken)">
            <summary>
            For the given <paramref name="fixAllScope"/> and <paramref name="triggerSpan"/> in the given <paramref name="document"/>,
            returns the documents and fix all spans within each document that need to be fixed.
            Note that this API is only invoked for span based FixAll scopes, i.e. <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/>
            and <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix">
            <summary>
            Represents a single fix. This is essentially a tuple
            that holds on to a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> and the set of
            <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s that this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> will fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic">
            <summary>
            This is the diagnostic that will show up in the preview pane header when a particular fix
            is selected in the light bulb menu. We also group all fixes with the same <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/>
            together (into a single SuggestedActionSet) in the light bulb menu.
            </summary>
            <remarks>
            A given fix can fix one or more diagnostics. However, our light bulb UI (preview pane, grouping
            of fixes in the light bulb menu etc.) currently keeps things simple and pretends that
            each fix fixes a single <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/>.
            
            Implementation-wise the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/> is always the first diagnostic that
            the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> supplied when registering the fix (<see 
            cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})"/>). This could change
            in the future, if we decide to change the UI to depict the true mapping between fixes and diagnostics
            or if we decide to use some other heuristic to determine the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext">
            <summary>
            Context for code fixes provided by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Document">
            <summary>
            Document corresponding to the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span"/> to fix.
            For code fixes that support non-source documents by providing a non-default value for
            <see cref="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.DocumentKinds"/>, this property will
            throw an <see cref="T:System.InvalidOperationException"/>. Such fixers should use the
            <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.TextDocument"/> property instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.TextDocument">
            <summary>
            TextDocument corresponding to the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span"/> to fix.
            This property should be used instead of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Document"/> property by
            code fixes that support non-source documents by providing a non-default value for
            <see cref="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.DocumentKinds"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span">
            <summary>
            Text span within the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Document"/> or <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.TextDocument"/> to fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics">
            <summary>
            Diagnostics to fix.
            NOTE: All the diagnostics in this collection have the same <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.CancellationToken">
            <summary>
            CancellationToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
            <summary>
            Creates a code fix context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)"/> method.
            </summary>
            <param name="document">Document to fix.</param>
            <param name="span">Text span within the <paramref name="document"/> to fix.</param>
            <param name="diagnostics">
            Diagnostics to fix.
            All the diagnostics must have the same <paramref name="span"/>.
            Additionally, the <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of each diagnostic must be in the set of the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> of the associated <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </param>
            <param name="registerCodeFix">Delegate to register a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> fixing a subset of diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.ArgumentNullException">Throws this exception if any of the arguments is null.</exception>
            <exception cref="T:System.ArgumentException">
            Throws this exception if the given <paramref name="diagnostics"/> is empty,
            has a null element or has an element whose span is not equal to <paramref name="span"/>.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.#ctor(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
            <summary>
            Creates a code fix context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)"/> method.
            </summary>
            <param name="document">Text document to fix.</param>
            <param name="span">Text span within the <paramref name="document"/> to fix.</param>
            <param name="diagnostics">
            Diagnostics to fix.
            All the diagnostics must have the same <paramref name="span"/>.
            Additionally, the <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of each diagnostic must be in the set of the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> of the associated <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </param>
            <param name="registerCodeFix">Delegate to register a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> fixing a subset of diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.ArgumentNullException">Throws this exception if any of the arguments is null.</exception>
            <exception cref="T:System.ArgumentException">
            Throws this exception if the given <paramref name="diagnostics"/> is empty,
            has a null element or has an element whose span is not equal to <paramref name="span"/>.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
            <summary>
            Creates a code fix context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)"/> method.
            </summary>
            <param name="document">Document to fix.</param>
            <param name="diagnostic">
            Diagnostic to fix.
            The <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of this diagnostic must be in the set of the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> of the associated <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </param>
            <param name="registerCodeFix">Delegate to register a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> fixing a subset of diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.ArgumentNullException">Throws this exception if any of the arguments is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.#ctor(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Diagnostic,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
            <summary>
            Creates a code fix context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)"/> method.
            </summary>
            <param name="document">Text document to fix.</param>
            <param name="diagnostic">
            Diagnostic to fix.
            The <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of this diagnostic must be in the set of the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> of the associated <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </param>
            <param name="registerCodeFix">Delegate to register a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> fixing a subset of diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.ArgumentNullException">Throws this exception if any of the arguments is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Add supplied <paramref name="action"/> to the list of fixes that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the fix.</param>
            <param name="diagnostic">The subset of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics"/> being addressed / fixed by the <paramref name="action"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Add supplied <paramref name="action"/> to the list of fixes that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the fix.</param>
            <param name="diagnostics">The subset of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics"/> being addressed / fixed by the <paramref name="action"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Add supplied <paramref name="action"/> to the list of fixes that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the fix.</param>
            <param name="diagnostics">The subset of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics"/> being addressed / fixed by the <paramref name="action"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider">
            <summary>
            Implement this type to provide fixes for source code problems.
            Remember to use <see cref="T:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute"/> so the host environment can offer your fixes in a UI.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds">
            <summary>
            A list of diagnostic IDs that this provider can provide fixes for.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)">
            <summary>
            Computes one or more fixes for the specified <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext"/>.
            </summary>
            <param name="context">
            A <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext"/> containing context information about the diagnostics to fix.
            The context must only contain diagnostics with a <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> included in the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> for the current provider.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.GetFixAllProvider">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that can fix all/multiple occurrences of diagnostics fixed by this code fix provider.
            Return null if the provider doesn't support fix all/multiple occurrences.
            Otherwise, you can return any of the well known fix all providers from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders"/> or implement your own fix all provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.ComputeRequestPriority">
            <summary>
            Computes the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority"/> group this provider should be considered to run at. Legal values
            this can be must be between <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Low"/> and <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.High"/>.
            </summary>
            <remarks>
            Values outside of this range will be clamped to be within that range.  Requests for <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.High"/> may be downgraded to <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default"/> as they
            poorly behaving high-priority providers can cause a negative user experience.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RequestPriority">
            <summary>
            Priority class this refactoring provider should run at. Returns <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default"/> if not overridden.  Slower, or less relevant, providers should
            override this and return a lower value to not interfere with computation of normal priority providers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.Name">
            <summary>
            Optional name of the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.Languages">
            <summary>
            The source languages this provider can provide fixes for.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.DocumentKinds">
            <summary>
            The document kinds for which this provider can provide code fixes. See <see cref="T:Microsoft.CodeAnalysis.TextDocumentKind"/>.
            By default, the provider supports code fixes only for source documents, <see cref="F:Microsoft.CodeAnalysis.TextDocumentKind.Document"/>.
            Provide string representation of the documents kinds for this property, for example:
                DocumentKinds = new[] { nameof(TextDocumentKind.AdditionalDocument) }
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.DocumentExtensions">
            <summary>
            The document extensions for which this provider can provide code fixes.
            Each extension string must include the leading period, for example, ".txt", ".xaml", ".editorconfig", etc.
            By default, this value is null and the document extension is not considered to determine applicability of code fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.#ctor(System.String,System.String[])">
            <summary>
            Attribute constructor used to specify automatic application of a code fix provider.
            </summary>
            <param name="firstLanguage">One language to which the code fix provider applies.</param>
            <param name="additionalLanguages">Additional languages to which the code fix provider applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider">
            <summary>
            Helper class for "Fix all occurrences" code fix providers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider.GetAllChangedDocumentsInDiagnosticsOrderAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Returns all the changed documents produced by fixing the list of provided <paramref
            name="orderedDiagnostics"/>.  The documents will be returned such that fixed documents for a later
            diagnostic will appear later than those for an earlier diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider.MergeTextChangesAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Document},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger})">
            <summary>
            Take all the changes made to a particular document and determine the text changes caused by each one.  Take
            those individual text changes and attempt to merge them together in order into <paramref
            name="docIdToTextMerger"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider">
            <summary>
            Provides a base class to write a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that fixes documents independently. This type
            should be used instead of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders.BatchFixer"/> in the case where fixes for a <see
            cref="T:Microsoft.CodeAnalysis.Diagnostic"/> only affect the <see cref="T:Microsoft.CodeAnalysis.Document"/> the diagnostic was produced in.
            </summary>
            <remarks>
            This type provides suitable logic for fixing large solutions in an efficient manner.  Projects are serially
            processed, with all the documents in the project being processed in parallel.  Diagnostics are computed for the
            project and then appropriately bucketed by document.  These are then passed to <see
            cref="M:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider.FixAllAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})"/> for implementors to process.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.FixAllScope})">
            <summary>
            Provides a base class to write a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that fixes documents independently. This type
            should be used instead of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders.BatchFixer"/> in the case where fixes for a <see
            cref="T:Microsoft.CodeAnalysis.Diagnostic"/> only affect the <see cref="T:Microsoft.CodeAnalysis.Document"/> the diagnostic was produced in.
            </summary>
            <remarks>
            This type provides suitable logic for fixing large solutions in an efficient manner.  Projects are serially
            processed, with all the documents in the project being processed in parallel.  Diagnostics are computed for the
            project and then appropriately bucketed by document.  These are then passed to <see
            cref="M:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider.FixAllAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})"/> for implementors to process.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider.GetFixAllTitle(Microsoft.CodeAnalysis.CodeFixes.FixAllContext)">
            <summary>
            Produce a suitable title for the fix-all <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> this type creates in <see
            cref="M:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider.GetFixAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext)"/>.  Override this if customizing that title is desired.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider.FixAllAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Fix all the <paramref name="diagnostics"/> present in <paramref name="document"/>.  The document returned
            will only be examined for its content (e.g. it's <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.  No
            other aspects of (like it's properties), or changes to the <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/>
            it points at will be considered.
            </summary>
            <param name="fixAllContext">The context for the Fix All operation.</param>
            <param name="document">The document to fix.</param>
            <param name="diagnostics">The diagnostics to fix in the document.</param>
            <returns>
            <para>The new <see cref="T:Microsoft.CodeAnalysis.Document"/> representing the content fixed document.</para>
            <para>-or-</para>
            <para><see langword="null"/>, if no changes were made to the document.</para>
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext">
            <summary>
            Context for "Fix all occurrences" code fixes provided by a <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.FixAllProvider"/>.
            </summary>
            <summary>
            Context for "Fix all occurrences" code fixes provided by a <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.FixAllProvider"/>.
            </summary>
            <summary>
            Context for "Fix all occurrences" code fixes provided by a <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.FixAllProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Solution">
            <summary>
            Solution to fix all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Project">
            <summary>
            Project within which fix all occurrences was triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Document">
            <summary>
            Document within which fix all occurrences was triggered, null if the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/> is scoped to a project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.CodeFixProvider">
            <summary>
            Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Scope">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds">
            <summary>
            Diagnostic Ids to fix.
            Note that <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document)"/>, <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project)"/> and <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.Project)"/> methods
            return only diagnostics whose IDs are contained in this set of Ids.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.CodeActionEquivalenceKey">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.CancellationToken">
            <summary>
            CancellationToken for fix all session.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Progress">
            <summary>
            Progress sink for reporting the progress of a fix-all operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            Use this overload when applying fix all to a diagnostic with a source location.
            <para>
            This overload cannot be used with <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/> or
            <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/> value for the <paramref name="scope"/>.
            For those fix all scopes, use the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/> constructor that
            takes a 'diagnosticSpan' parameter to identify the containing member or type based
            on this span.
            </para>
            </summary>
            <param name="document">Document within which fix all occurrences was triggered.</param>
            <param name="codeFixProvider">Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.</param>
            <param name="scope"><see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.</param>
            <param name="codeActionEquivalenceKey">The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.</param>
            <param name="diagnosticIds">Diagnostic Ids to fix.</param>
            <param name="fixAllDiagnosticProvider">
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider"/> to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </param>
            <param name="cancellationToken">Cancellation token for fix all computation.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.#ctor(Microsoft.CodeAnalysis.Document,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/> with an associated <paramref name="diagnosticSpan"/>.
            Use this overload when applying fix all to a diagnostic with a source location and
            using <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/> or <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/>
            for the <paramref name="scope"/>.  When using other fix all scopes, <paramref name="diagnosticSpan"/>
            is not required and other constructor which does not take a diagnostic span can be used instead.
            </summary>
            <param name="document">Document within which fix all occurrences was triggered.</param>
            <param name="diagnosticSpan">Span for the diagnostic for which fix all occurrences was triggered.</param>
            <param name="codeFixProvider">Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.</param>
            <param name="scope"><see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.</param>
            <param name="codeActionEquivalenceKey">The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.</param>
            <param name="diagnosticIds">Diagnostic Ids to fix.</param>
            <param name="fixAllDiagnosticProvider">
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider"/> to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </param>
            <param name="cancellationToken">Cancellation token for fix all computation.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.#ctor(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            Use this overload when applying fix all to a diagnostic with no source location, i.e. <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.
            </summary>
            <param name="project">Project within which fix all occurrences was triggered.</param>
            <param name="codeFixProvider">Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.</param>
            <param name="scope"><see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.</param>
            <param name="codeActionEquivalenceKey">The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.</param>
            <param name="diagnosticIds">Diagnostic Ids to fix.</param>
            <param name="fixAllDiagnosticProvider">
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider"/> to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </param>
            <param name="cancellationToken">Cancellation token for fix all computation.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets all the diagnostics in the given document filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetDocumentSpanDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets all the diagnostics in the given <paramref name="filterSpan"/> for the given <paramref name="document"/> filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets all the project-level diagnostics, i.e. diagnostics with no source location, in the given project filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets all the diagnostics in the given project filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            This includes both document-level diagnostics for all documents in the given project and project-level diagnostics, i.e. diagnostics with no source location, in the given project. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project,System.Boolean)">
            <summary>
            Gets all the project diagnostics in the given project filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            If <paramref name="includeAllDocumentDiagnostics"/> is false, then returns only project-level diagnostics which have no source location.
            Otherwise, returns all diagnostics in the project, including the document diagnostics for all documents in the given project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.WithCancellationToken(System.Threading.CancellationToken)">
            <summary>
            Gets a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/> with the given cancellationToken.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider">
            <summary>
            Diagnostic provider to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics to fix in the given document in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Gets all the project-level diagnostics to fix, i.e. diagnostics with no source location, in the given project in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics to fix in the given project in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            This includes both document-level diagnostics for all documents in the given project and project-level diagnostics, i.e. diagnostics with no source location, in the given project. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.SpanBasedDiagnosticProvider">
            <summary>
            Diagnostic provider to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>,
            which supports a <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.SpanBasedDiagnosticProvider.GetDocumentSpanDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)"/>
            method to compute diagnostics for a given span within a document.
            We need to compute diagnostics for a span when applying a fix all operation in <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/>
            and <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/> scopes.
            A regular <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider"/> will compute diagnostics for the entire document and filter out
            diagnostics outside the span as a post-filtering step.
            A <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.SpanBasedDiagnosticProvider"/> can do this more efficiently by implementing the
            <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.SpanBasedDiagnosticProvider.GetDocumentSpanDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)"/> method to compute
            the diagnostics only for the given 'fixAllSpan' upfront.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.SpanBasedDiagnosticProvider.GetDocumentSpanDiagnosticsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics to fix for the given <paramref name="fixAllSpan"/> in the given <paramref name="document"/> in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider">
            <summary>
            Implement this abstract type to provide fix all/multiple occurrences code fixes for source code problems.
            Alternatively, you can use any of the well known fix all providers from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.GetSupportedFixAllScopes">
            <summary>
            Gets the supported scopes for fixing all occurrences of a diagnostic.
            By default, it returns the following scopes:
            (a) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document"/>
            (b) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project"/> and
            (c) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.GetSupportedFixAllDiagnosticIds(Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider)">
            <summary>
            Gets the diagnostic IDs for which fix all occurrences is supported.
            By default, it returns <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> for the given <paramref name="originalCodeFixProvider"/>.
            </summary>
            <param name="originalCodeFixProvider">Original code fix provider that returned this fix all provider from <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.GetFixAllProvider"/> method.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.GetFixAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext)">
            <summary>
            Gets fix all occurrences fix for the given fixAllContext.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.Create(System.Func{Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that fixes documents independently.  This should be used instead of
            <see cref="P:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders.BatchFixer"/> in the case where fixes for a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>
            only affect the <see cref="T:Microsoft.CodeAnalysis.Document"/> the diagnostic was produced in.
            </summary>
            <param name="fixAllAsync">
            Callback that will the fix diagnostics present in the provided document.  The document returned will only be
            examined for its content (e.g. it's <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.  No other aspects
            of it (like attributes), or changes to the <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> it points at
            will be considered.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.Create(System.Func{Microsoft.CodeAnalysis.CodeFixes.FixAllContext,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.FixAllScope})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that fixes documents independently for the given <paramref name="supportedFixAllScopes"/>.
            This should be used instead of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders.BatchFixer"/> in the case where
            fixes for a <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> only affect the <see cref="T:Microsoft.CodeAnalysis.Document"/> the diagnostic was produced in.
            </summary>
            <param name="fixAllAsync">
            Callback that will the fix diagnostics present in the provided document.  The document returned will only be
            examined for its content (e.g. it's <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.  No other aspects
            of it (like attributes), or changes to the <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> it points at
            will be considered.
            </param>
            <param name="supportedFixAllScopes">
            Supported <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/>s for the fix all provider.
            Note that <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Custom"/> is not supported by the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider"/>
            and should not be part of the supported scopes.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope">
            <summary>
            Indicates scope for "Fix all occurrences" code fixes provided by each <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document">
            <summary>
            Scope to fix all occurences of diagnostic(s) in the entire document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project">
            <summary>
            Scope to fix all occurences of diagnostic(s) in the entire project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution">
            <summary>
            Scope to fix all occurences of diagnostic(s) in the entire solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Custom">
            <summary>
            Custom scope to fix all occurences of diagnostic(s). This scope can
            be used by custom <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/>s and custom code fix engines.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember">
            <summary>
            Scope to fix all occurrences of diagnostic(s) in the containing member
            relative to the trigger span for the original code fix.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType">
            <summary>
            Scope to fix all occurrences of diagnostic(s) in the containing type
            relative to the trigger span for the original code fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState.FixMultipleDiagnosticProvider">
            <summary>
            Diagnostic provider to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.NoOpFixAllProvider">
            <summary>
            A dummy fix all provider to represent a no-change provider.
            This is only used by public constructors for <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>,
            our internal code fix engine always creates a FixAllContext with a non-null
            FixAllProvider. Using a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.NoOpFixAllProvider"/> for the public constructors
            helps us to avoid a nullable <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.FixAllProvider"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger">
            <summary>
            Helper to merge many disparate text changes to a single document together into a total set of changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger.TryMergeChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Try to merge the changes made to <paramref name="newDocument"/> into the tracked changes. If there is any
            conflicting change in <paramref name="newDocument"/> with existing changes, then no changes are added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger.TryMergeChangesAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Try to merge the changes made to all the documents in <paramref name="newDocuments"/> in order into the
            tracked changes. If there is any conflicting changes with existing changes for a particular document, then
            no changes will be added for it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders">
            <summary>
            Contains well known implementations of <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders.BatchFixer">
            <summary>
            Default batch fix all provider.
            This provider batches all the individual diagnostic fixes across the scope of fix all action,
            computes fixes in parallel and then merges all the non-conflicting fixes into a single fix all code action.
            This fixer supports fixes for the following fix all scopes:
            <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document"/>, <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project"/>, <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution"/>
            <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/> and <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/>.
            </summary>
            <remarks>
            The batch fix all provider only batches operations (i.e. <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>) of type
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> present within the individual diagnostic fixes. Other types of
            operations present within these fixes are ignored.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider">
            <summary>
            Provides suppression or configuration code fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.IsFixableDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Returns true if the given diagnostic can be configured, suppressed or unsuppressed by this provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.GetFixesAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Gets one or more add suppression, remove suppression, or configuration fixes for the specified diagnostics represented as a list of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s.
            </summary>
            <returns>A list of zero or more potential <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>'es. It is also safe to return null if there are none.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.GetFixesAsync(Microsoft.CodeAnalysis.Project,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Gets one or more add suppression, remove suppression, or configuration fixes for the specified no-location diagnostics represented as a list of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s.
            </summary>
            <returns>A list of zero or more potential <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>'es. It is also safe to return null if there are none.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.GetFixAllProvider">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that can fix all/multiple occurrences of diagnostics fixed by this fix provider.
            Return null if the provider doesn't support fix all/multiple occurrences.
            Otherwise, you can return any of the well known fix all providers from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders"/> or implement your own fix all provider.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ForkingSyntaxEditorBasedCodeFixProvider`1">
            <summary>
            Helper type for <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>s that need to provide 'fix all' support in a document, by operate by
            applying one fix at a time, then recomputing the work to do after that fix is applied.  While this is not generally
            desirable from a performance perspective (due to the costs of forking a document after each fix), it is sometimes
            necessary as individual fixes can impact the code so substantially that successive fixes may no longer apply, or may
            have dramatically different data to work with before the fix.  For example, if one fix removes statements entirely
            that another fix was contained in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ForkingSyntaxEditorBasedCodeFixProvider`1.FixAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Editing.SyntaxEditor,`0,System.Collections.Immutable.ImmutableDictionary{System.String,System.String},System.Threading.CancellationToken)">
            <summary>
            Subclasses must override this to actually provide the fix for a particular diagnostic.  The implementation will
            be passed the <em>current</em> <paramref name="document"/> (containing the changes from all prior fixes), the
            the <paramref name="diagnosticNode"/> in that document, for the current diagnostic being fixed.  And the <see
            cref="P:Microsoft.CodeAnalysis.Diagnostic.Properties"/> for that diagnostic.  The diagnostic itself is not passed along as it was
            computed with respect to the original user document, and as such its <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Location"/> and <see
            cref="P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations"/> will not be correct.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContextExtensions.RegisterFixes(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeAction},Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Use this helper to register multiple fixes (<paramref name="actions"/>) each of which addresses / fixes the same supplied <paramref name="diagnostic"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContextExtensions.RegisterFixes(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Use this helper to register multiple fixes (<paramref name="actions"/>) each of which addresses / fixes the same set of supplied <paramref name="diagnostics"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.FixAllAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Editing.SyntaxEditor,System.Threading.CancellationToken)">
            <summary>
            Fixes all <paramref name="diagnostics"/> in the specified <paramref name="editor"/>.
            The fixes are applied to the <paramref name="document"/>'s syntax tree via <paramref name="editor"/>.
            The implementation may query options of any document in the <paramref name="document"/>'s solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)">
            <summary>
            Whether or not this diagnostic should be included when performing a FixAll.  This is useful for providers that
            create multiple diagnostics for the same issue (For example, one main diagnostic and multiple 'faded out code'
            diagnostics).  FixAll can be invoked from any of those, but we'll only want perform an edit for only one
            diagnostic for each of those sets of diagnostics.
            <para/>
            This overload differs from <see cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic)"/> in that it also passes along
            the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState"/> in case that would be useful (for example if the <see
            cref="P:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.CodeActionEquivalenceKey"/> is used.
            <para/>
            Only one of these two overloads needs to be overridden if you want to customize behavior.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Whether or not this diagnostic should be included when performing a FixAll.  This is useful for providers that
            create multiple diagnostics for the same issue (For example, one main diagnostic and multiple 'faded out code'
            diagnostics).  FixAll can be invoked from any of those, but we'll only want perform an edit for only one
            diagnostic for each of those sets of diagnostics.
            <para/>
            By default, all diagnostics will be included in fix-all unless they are filtered out here. If only the
            diagnostic needs to be queried to make this determination, only this overload needs to be overridden.  However,
            if information from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState"/> is needed (for example <see
            cref="P:Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.CodeActionEquivalenceKey"/>), then <see cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)"/> should be overridden instead.
            <para/>
            Only one of these two overloads needs to be overridden if you want to customize behavior.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext">
            <summary>
            Context for code refactorings provided by a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Document">
            <summary>
            Document corresponding to the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Span"/> to refactor.
            For code refactorings that support non-source documents by providing a non-default value for
            <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.DocumentKinds"/>, this property will
            throw an <see cref="T:System.InvalidOperationException"/>. Such refactorings should use the
            <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.TextDocument"/> property instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.TextDocument">
            <summary>
            TextDocument corresponding to the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Span"/> to refactor.
            This property should be used instead of <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Document"/> property by
            code refactorings that support non-source documents by providing a non-default value for
            <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.DocumentKinds"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Span">
            <summary>
            Text span within the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Document"/> or <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.TextDocument"/> to refactor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.CancellationToken">
            <summary>
            CancellationToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Threading.CancellationToken)">
            <summary>
            Creates a code refactoring context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.#ctor(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Threading.CancellationToken)">
            <summary>
            Creates a code refactoring context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.#ctor(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan}},System.Threading.CancellationToken)">
            <summary>
            Creates a code refactoring context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.RegisterRefactoring(Microsoft.CodeAnalysis.CodeActions.CodeAction)">
            <summary>
            Add supplied <paramref name="action"/> to the list of refactorings that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the refactoring.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.RegisterRefactoring(Microsoft.CodeAnalysis.CodeActions.CodeAction,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Add supplied <paramref name="action"/> applicable to <paramref name="applicableToSpan"/> to the list of refactorings that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the refactoring.</param>
            <param name="applicableToSpan">The <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> within original document the <paramref name="action"/> is applicable to.</param>
            <remarks>
            <paramref name="applicableToSpan"/> should represent a logical section within the original document that the <paramref name="action"/> is 
            applicable to. It doesn't have to precisely represent the exact <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> that will get changed.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider">
            <summary>
            Inherit this type to provide source code refactorings.
            Remember to use <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute"/> so the host environment can offer your refactorings in a UI.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)">
            <summary>
            Computes one or more refactorings for the specified <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.GetFixAllProvider">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider"/> that can apply multiple occurrences of code refactoring(s)
            registered by this code refactoring provider across the supported <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/>s.
            Return null if the provider doesn't support fix all operation.
            </summary>
            <remarks>
            TODO: Make public, tracked with https://github.com/dotnet/roslyn/issues/60703
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRequestPriority">
            <summary>
            Computes the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority"/> group this provider should be considered to run at. Legal values
            this can be must be between <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Low"/> and <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.High"/>.
            </summary>
            <remarks>
            Values outside of this range will be clamped to be within that range.  Requests for <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.High"/> may be downgraded to <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default"/> as they
            poorly behaving high-priority providers can cause a negative user experience.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.RequestPriority">
            <summary>
            Priority class this refactoring provider should run at. Returns <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority.Default"/> if not overridden.  Slower, or less relevant, providers should
            override this and return a lower value to not interfere with computation of normal priority providers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.Name">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.Languages">
            <summary>
            The source languages for which this provider can provide refactorings. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.DocumentKinds">
            <summary>
            The document kinds for which this provider can provide refactorings. See <see cref="T:Microsoft.CodeAnalysis.TextDocumentKind"/>.
            By default, the provider supports refactorings only for source documents, <see cref="F:Microsoft.CodeAnalysis.TextDocumentKind.Document"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.DocumentExtensions">
            <summary>
            The document extensions for which this provider can provide refactorings.
            Each extension string must include the leading period, for example, ".txt", ".xaml", ".editorconfig", etc.
            By default, this value is null and the document extension is not considered to determine applicability of refactorings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.#ctor(System.String,System.String[])">
            <summary>
            Attribute constructor used to specify availability of a code refactoring provider.
            </summary>
            <param name="firstLanguage">One language to which the code refactoring provider applies.</param>
            <param name="additionalLanguages">Additional languages to which the code refactoring provider applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider">
             <summary>
             Provides a base class to write a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider"/> for refactorings that fixes documents independently.
             This type should be used in the case where the code refactoring(s) only affect individual <see cref="T:Microsoft.CodeAnalysis.Document"/>s.
             </summary>
             <remarks>
             This type provides suitable logic for fixing large solutions in an efficient manner.  Projects are serially
             processed, with all the documents in the project being processed in parallel. 
             <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.FixAllAsync(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Optional{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}})"/> is invoked for each document for implementors to process.
            
             TODO: Make public, tracked with https://github.com/dotnet/roslyn/issues/60703
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.FixAllScope})">
             <summary>
             Provides a base class to write a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider"/> for refactorings that fixes documents independently.
             This type should be used in the case where the code refactoring(s) only affect individual <see cref="T:Microsoft.CodeAnalysis.Document"/>s.
             </summary>
             <remarks>
             This type provides suitable logic for fixing large solutions in an efficient manner.  Projects are serially
             processed, with all the documents in the project being processed in parallel. 
             <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.FixAllAsync(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Optional{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}})"/> is invoked for each document for implementors to process.
            
             TODO: Make public, tracked with https://github.com/dotnet/roslyn/issues/60703
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.GetFixAllTitle(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext)">
            <summary>
            Produce a suitable title for the fix-all <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> this type creates in <see
            cref="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.GetFixAsync(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext)"/>.  Override this if customizing that title is desired.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.FixAllAsync(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Optional{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}})">
            <summary>
            Apply fix all operation for the code refactoring in the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Document"/>
            for the given <paramref name="fixAllContext"/>.  The document returned will only be examined for its content
            (e.g. it's <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.  No other aspects of document (like it's properties),
            or changes to the <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> it points at will be considered.
            </summary>
            <param name="fixAllContext">The context for the Fix All operation.</param>
            <param name="document">The document to fix.</param>
            <param name="fixAllSpans">The spans to fix in the document. If not specified, entire document needs to be fixedd.</param>
            <returns>
            <para>The new <see cref="T:Microsoft.CodeAnalysis.Document"/> representing the content fixed document.</para>
            <para>-or-</para>
            <para><see langword="null"/>, if no changes were made to the document.</para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider.GetFixedDocumentsAsync(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext,System.Func{Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.Threading.Tasks.ValueTask})">
            <summary>
            Attempts to apply fix all operations returning, for each updated document, either the new syntax root for that
            document or its new text.  Syntax roots are returned for documents that support them, and are used to perform a
            final cleanup pass for formatting/simplification/etc.  Text is returned for documents that don't support syntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext">
            <summary>
            Context for "Fix all occurrences" for code refactorings provided by each <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.CodeRefactoringProvider"/>.
            </summary>
            <remarks>
            TODO: Make public, tracked with https://github.com/dotnet/roslyn/issues/60703
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Document">
            <summary>
            Document within which fix all occurrences was triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.CodeRefactoringProvider">
            <summary>
            Underlying <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.CodeRefactoringProvider"/> which triggered this fix all.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Scope">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.CodeActionEquivalenceKey">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.CancellationToken">
            <summary>
            CancellationToken for fix all session.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Project">
            <summary>
            Project to fix all occurrences.
            Note that this property will always be the containing project of <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Document"/>
            for publicly exposed FixAllContext instance. However, we might create an intermediate FixAllContext
            with null <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Document"/> and non-null Project, so we require this internal property for intermediate computation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.GetFixAllSpansAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the spans to fix by document for the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext.Scope"/> for this fix all occurences fix.
            If no spans are specified, it indicates the entire document needs to be fixed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider">
            <summary>
            Implement this abstract type to provide fix all occurrences support for code refactorings.
            </summary>
            <remarks>
            TODO: Make public, tracked with https://github.com/dotnet/roslyn/issues/60703
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider.GetSupportedFixAllScopes">
            <summary>
            Gets the supported scopes for applying multiple occurrences of a code refactoring.
            By default, it returns the following scopes:
            (a) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document"/>
            (b) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project"/> and
            (c) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider.GetFixAsync(Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext)">
            <summary>
            Gets fix all occurrences fix for the given fixAllContext.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider.Create(System.Func{Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Optional{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}},System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider"/> that fixes documents independently.
            This can be used in the case where refactoring(s) registered by this provider
            only affect a single <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            </summary>
            <param name="fixAllAsync">
            Callback that will apply the refactorings present in the provided document.  The document returned will only be
            examined for its content (e.g. it's <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.  No other aspects
            of it (like attributes), or changes to the <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> it points at
            will be considered.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider.Create(System.Func{Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Optional{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}},System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.FixAllScope})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider"/> that fixes documents independently.
            This can be used in the case where refactoring(s) registered by this provider
            only affect a single <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            </summary>
            <param name="fixAllAsync">
            Callback that will apply the refactorings present in the provided document.  The document returned will only be
            examined for its content (e.g. it's <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.  No other aspects
            of it (like attributes), or changes to the <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> it points at
            will be considered.
            </param>
            <param name="supportedFixAllScopes">
            Supported <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/>s for the fix all provider.
            Note that <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Custom"/> is not supported by the <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider"/>
            and should not be part of the supported scopes.
            </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeRefactorings.FixAllState._selectionSpan">
            <summary>
            Original selection span from which FixAll was invoked.
            This is used in <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllState.GetFixAllSpansAsync(System.Threading.CancellationToken)"/>
            to compute fix all spans for <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingMember"/>
            and <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.ContainingType"/> scopes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.FixAllState.GetFixAllSpansAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the spans to fix by document for the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> for this fix all occurences fix.
            If no spans are specified, it indicates the entire document needs to be fixed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3.ExtractNodesSimple(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            Extractor function that retrieves all nodes that should be considered for extraction of given current node. 
            <para>
            The rationale is that when user selects e.g. entire local declaration statement [|var a = b;|] it is reasonable
            to provide refactoring for `b` node. Similarly for other types of refactorings.
            </para>
            </summary>
            <remark>
            Should also return given node. 
            </remark>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3.ExtractNodesInHeader(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.LanguageService.IHeaderFactsService)">
            <summary>
            Extractor function that checks and retrieves all nodes current location is in a header.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService">
            <summary>
            Contains helpers related to asking intuitive semantic questions about a users intent
            based on the position of their caret or span of their selection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService.IsBetweenTypeMembers(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            True if the user is on a blank line where a member could go inside a type declaration.
            This will be between members and not ever inside a member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService.AddRelevantNodes``1(Microsoft.CodeAnalysis.ParsedDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{``0}@,System.Threading.CancellationToken)">
            <summary>
            <para>
            Returns an array of <typeparamref name="TSyntaxNode"/> instances for refactoring given specified selection
            in document. <paramref name="allowEmptyNodes"/> determines if the returned nodes will can have empty spans
            or not.
            </para>
            <para>
            A <typeparamref name="TSyntaxNode"/> instance is returned if: - Selection is zero-width and inside/touching
            a Token with direct parent of type <typeparamref name="TSyntaxNode"/>. - Selection is zero-width and
            touching a Token whose ancestor of type <typeparamref name="TSyntaxNode"/> ends/starts precisely on current
            selection. - Selection is zero-width and in whitespace that corresponds to a Token whose direct ancestor is
            of type of type <typeparamref name="TSyntaxNode"/>. - Selection is zero-width and in a header (defined by
            ISyntaxFacts helpers) of an node of type of type <typeparamref name="TSyntaxNode"/>. - Token whose direct
            parent of type <typeparamref name="TSyntaxNode"/> is selected. - Selection is zero-width and wanted node is
            an expression / argument with selection within such syntax node (arbitrarily deep) on its first line. -
            Whole node of a type <typeparamref name="TSyntaxNode"/> is selected.
            </para>
            <para>
            Attempts extracting a Node of type <typeparamref name="TSyntaxNode"/> for each Node it considers (see
            above). E.g. extracts initializer expressions from declarations and assignments, Property declaration from
            any header node, etc.
            </para>
            <para>
            Note: this function trims all whitespace from both the beginning and the end of given <paramref
            name="selection"/>. The trimmed version is then used to determine relevant <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>. It also
            handles incomplete selections of tokens gracefully. Over-selection containing leading comments is also
            handled correctly. 
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption">
            <summary>
            Public representation of a code style option value. Should only be used for public API.
            Internally the value is represented by <see cref="T:Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption`1">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1">
            <summary>
            Represents a code style option and an associated notification option.  Supports
            being instantiated with T as a <see cref="T:System.Boolean"/> or an <c>enum type</c>.
            
            CodeStyleOption also has some basic support for migration a <see cref="T:System.Boolean"/> option
            forward to an <c>enum type</c> option.  Specifically, if a previously serialized
            bool-CodeStyleOption is then deserialized into an enum-CodeStyleOption then 'false' 
            values will be migrated to have the 0-value of the enum, and 'true' values will be
            migrated to have the 1-value of the enum.
            
            Similarly, enum-type code options will serialize out in a way that is compatible with 
            hosts that expect the value to be a boolean.  Specifically, if the enum value is 0 or 1
            then those values will write back as false/true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1.#ctor(`0,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2)">
            <summary>
            Represents a code style option and an associated notification option.  Supports
            being instantiated with T as a <see cref="T:System.Boolean"/> or an <c>enum type</c>.
            
            CodeStyleOption also has some basic support for migration a <see cref="T:System.Boolean"/> option
            forward to an <c>enum type</c> option.  Specifically, if a previously serialized
            bool-CodeStyleOption is then deserialized into an enum-CodeStyleOption then 'false' 
            values will be migrated to have the 0-value of the enum, and 'true' values will be
            migrated to have the 1-value of the enum.
            
            Similarly, enum-type code options will serialize out in a way that is compatible with 
            hosts that expect the value to be a boolean.  Specifically, if the enum value is 0 or 1
            then those values will write back as false/true.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyFieldAccess">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyFieldAccess"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyPropertyAccess">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyPropertyAccess"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyMethodAccess">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyMethodAccess"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyEventAccess">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyEventAccess"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.PreferIntrinsicPredefinedTypeKeywordInDeclaration">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.PreferIntrinsicPredefinedTypeKeywordInDeclaration"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.PreferIntrinsicPredefinedTypeKeywordInMemberAccess">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.PreferIntrinsicPredefinedTypeKeywordInMemberAccess"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Name">
            <summary>
            Name for the notification option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Severity">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Severity"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.None">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.None"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Silent">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Silent"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Suggestion">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Suggestion"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Warning">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Warning"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Error">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Error"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2">
            <summary>
            Offers different notification styles for enforcing
            a code style. Under the hood, it simply maps to <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/>
            </summary>
            <completionlist cref="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.#ctor(Microsoft.CodeAnalysis.ReportDiagnostic,System.Boolean)">
            <summary>
            Offers different notification styles for enforcing
            a code style. Under the hood, it simply maps to <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/>
            </summary>
            <completionlist cref="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.None">
            <summary>
            Notification option to disable or suppress an option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Suppress"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Silent">
            <summary>
            Notification option for a silent or hidden option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Hidden"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Suggestion">
            <summary>
            Notification option for a suggestion or an info option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Info"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Warning">
            <summary>
            Notification option for a warning option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Warn"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Error">
            <summary>
            Notification option for an error option with <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Error"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers.TryGetCodeStyleValue(System.String,System.String@)">
            <summary>
            Given an editor-config code-style-option, gives back the core value part of the 
            option.  For example, if the option is "true:error" or "true" then "true" will be returned
            in <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers.TryGetCodeStyleValueAndOptionalNotification(System.String,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2,System.String@,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2@)">
            <summary>
            Given an editor-config code-style-option, gives back the constituent parts of the 
            option.  For example, if the option is "true:error" then "true" will be returned
            in <paramref name="value"/> and <see cref="P:Microsoft.CodeAnalysis.CodeStyle.NotificationOption2.Error"/> will be returned
            in <paramref name="notification"/>.  Note that users are allowed to not provide
            a NotificationOption, so <paramref name="notification"/> will default to <paramref name="defaultNotification"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2">
            <summary>
            Internal representation of a code style option value. Should be used throughout Roslyn.
            The internal values are translated to the public ones (ICodeStyleOption) at the public entry points.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.FromXElement(System.Xml.Linq.XElement)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2"/> from a specified <paramref name="element"/>.
            </summary>
            <exception cref="T:System.Exception">
            The type of the serialized data does not match the type of <see cref="P:Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.Value"/> or the format of the serialized data is invalid.
            </exception>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2.TrueWithSilentEnforcement">
            <remarks>
            When user preferences are not yet set for a style, we fall back to the default value.
            One such default(s), is that the feature is turned on, so that codegen consumes it,
            but with silent enforcement, so that the user is not prompted about their usage.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2.GetCodeStyle(System.Boolean,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2)">
            <summary>
            Use singletons for most common values.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyFieldAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in field access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyPropertyAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in property access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyMethodAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in method access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.QualifyEventAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in event access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.PreferIntrinsicPredefinedTypeKeywordInDeclaration">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Declarations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.PreferIntrinsicPredefinedTypeKeywordInMemberAccess">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Member Access Expression
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2.EditorConfigOptions">
            <summary>
            Options that we expect the user to set in editorconfig.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference">
            <remarks>
            Note: the order of this enum is important.  We originally only supported two values,
            and we encoded this as a bool with 'true = WhenPossible' and 'false = never'.  To
            preserve compatibility we map the false value to 0 and the true value to 1.  All new
            values go after these. 
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.ForEachExplicitCastInSourcePreference">
            <summary>
            Preferences if a foreach statement is allowed to have an explicit cast not visible in source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.ForEachExplicitCastInSourcePreference.Always">
            <summary>
            Hidden explicit casts are not allowed.  In any location where one might be emitted, users must supply their
            own explicit cast to make it apparent that the code may fail at runtime.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.ForEachExplicitCastInSourcePreference.WhenStronglyTyped">
            <summary>
            Hidden casts are allowed on legacy APIs but not allowed on strongly-typed modern APIs.  An API is considered
            legacy if enumerating it would produce values of type <see cref="T:System.Object"/> or itself does not implement <see
            cref="T:System.Collections.Generic.IEnumerable`1"/>.  These represent APIs that existed prior to the widespread adoption of generics and
            are the reason the language allowed this explicit conversion to not be stated for convenience.  With
            generics though it is more likely that an explicit cast emitted is an error and the user put in an incorrect
            type errantly and would benefit from an alert about the issue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NamespaceDeclarationPreference.BlockScoped">
            <summary>
            Prefer <c>namespace N { }</c>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.NamespaceDeclarationPreference.FileScoped">
            <summary>
            Prefer <c>namespace N;</c>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.UnusedParametersPreference">
            <summary>
            Preferences for flagging unused parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference">
            <summary>
            Assignment preference for unused values from expression statements and assignments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeStyle.NamingStyleOptions.NamingPreferences">
            <summary>
            This option describes the naming rules that should be applied to specified categories of symbols, 
            and the level to which those rules should be enforced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisKind">
            <summary>
            enum for each analysis kind.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache">
            <summary>
            Provides and caches information about diagnostic analyzers such as <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/>, 
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> instance, <see cref="T:Microsoft.CodeAnalysis.DiagnosticDescriptor"/>s.
            Thread-safe.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache._descriptorsInfo">
            <summary>
            Supported descriptors of each <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>. 
            </summary>
            <remarks>
            Holds on <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> instances weakly so that we don't keep analyzers coming from package references alive.
            They need to be released when the project stops referencing the analyzer.
            
            The purpose of this map is to avoid multiple calls to <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> that might return different values
            (they should not but we need a guarantee to function correctly).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache._suppressionsInfo">
            <summary>
            Supported suppressions of each <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/>. 
            </summary>
            <remarks>
            Holds on <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor"/> instances weakly so that we don't keep suppressors coming from package references alive.
            They need to be released when the project stops referencing the suppressor.
            
            The purpose of this map is to avoid multiple calls to <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.SupportedSuppressions"/> that might return different values
            (they should not but we need a guarantee to function correctly).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache._idToDescriptorsMap">
            <summary>
            Lazily populated map from diagnostic IDs to diagnostic descriptor.
            If same diagnostic ID is reported by multiple descriptors, a null value is stored in the map for that ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.GetDiagnosticDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Returns <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> of given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.GetDiagnosticSuppressions(Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor)">
            <summary>
            Returns <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSuppressor.SupportedSuppressions"/> of given <paramref name="suppressor"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.GetNonCompilationEndDiagnosticDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Returns <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> of given <paramref name="analyzer"/>
            that are not compilation end descriptors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.GetCompilationEndDiagnosticDescriptors(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Returns <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.SupportedDiagnostics"/> of given <paramref name="analyzer"/>
            that are compilation end descriptors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.IsCompilationEndAnalyzer(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Returns true if given <paramref name="analyzer"/> has a compilation end descriptor
            that is reported in the Compilation end action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache.IsTelemetryCollectionAllowed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Determine whether collection of telemetry is allowed for given <paramref name="analyzer"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.Language">
            <summary>
            Language name (<see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>) or null if the diagnostic is not associated with source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.PropertiesForBuildDiagnostic">
            <summary>
            Properties for a diagnostic generated by an explicit build.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.TryCreate(Microsoft.CodeAnalysis.DiagnosticDescriptor,System.String[],Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Diagnostics.DiagnosticData@)">
            <summary>
            Create a host/VS specific diagnostic with the given descriptor and message arguments for the given project.
            Note that diagnostic created through this API cannot be suppressed with in-source suppression due to performance reasons (see the PERF remark below for details).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.IsBuildDiagnostic">
            <summary>
            Returns true if the diagnostic was generated by an explicit build, not live analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.UnmappedFileSpan">
            <summary>
            Path to where the diagnostic was originally reported.  May be a path to a document in a project, or the
            project file itself. This should only be used by clients that truly need to know the original location a
            diagnostic was reported at, ignoring things like <c>#line</c> directives or other systems that would map the
            diagnostic to a different file or location.  Most clients should instead use <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.MappedFileSpan"/>,
            which contains the final location (file and span) that the diagnostic should be considered at.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.DocumentId">
            <summary>
            Document the diagnostic is associated with.  May be null if this is a project diagnostic.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.MappedFileSpan">
            <summary>
            Path and span where the diagnostic has been finally mapped to.  If no mapping happened, this will be equal
            to <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.UnmappedFileSpan"/>.  The <see cref="P:Microsoft.CodeAnalysis.FileLinePositionSpan.Path"/> of this value will be the
            fully normalized file path where the diagnostic is located at.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.WithSpan(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Return a new location with the same <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.DocumentId"/> as this, but with updated <see
            cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.UnmappedFileSpan"/> and <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.MappedFileSpan"/> corresponding to the respection locations of
            <paramref name="newSourceSpan"/> within <paramref name="tree"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope">
            <summary>
            Scope for analyzing a document for computing local syntax/semantic diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope.AdditionalFile">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> corresponding to the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope.TextDocument"/>.
            NOTE: Throws an exception if <see cref="P:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope.TextDocument"/> is not an <see cref="T:Microsoft.CodeAnalysis.AdditionalDocument"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer">
            <summary>
            IDE-only document based diagnostic analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <summary>
            it is not allowed one to implement both DocumentDiagnosticAnalzyer and DiagnosticAnalyzer
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer.Priority">
            <summary>
            This lets vsix installed <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer"/> to
            specify priority of the analyzer. Regular <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> always comes before those 2 different types.
            Priority is ascending order and this only works on HostDiagnosticAnalyzer meaning Vsix installed analyzers in VS.
            This is to support partner teams (such as typescript and F#) who want to order their analyzer's execution order.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Extensions.s_typeToAssemblyQualifiedName">
            <summary>
            Cache of a <see cref="T:System.Type"/> to its <see cref="P:System.Type.AssemblyQualifiedName"/>.  We cache this as the latter
            computes and allocates expensively every time it is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Extensions.Filter(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Filters out the diagnostics with the specified <paramref name="diagnosticIdsToFilter"/>.
            If <paramref name="includeSuppressedDiagnostics"/> is false, filters out suppressed diagnostics.
            If <paramref name="filterSpan"/> is non-null, filters out diagnostics with location outside this span.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.FileContentLoadAnalyzer">
            <summary>
            A dummy singleton analyzer. Its only purpose is to represent file content load failures in maps that are keyed by <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.GeneratorDiagnosticsPlaceholderAnalyzer">
            <summary>
            A placeholder singleton analyzer. Its only purpose is to represent generator-produced diagnostics in maps that are keyed by <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._hostAnalyzerReferencesMap">
            <summary>
            Key is <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Id"/>.
            
            We use the key to de-duplicate analyzer references if they are referenced from multiple places.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._hostDiagnosticAnalyzersPerLanguageMap">
            <summary>
            Key is the language the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> supports and key for the second map is analyzer reference identity and
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> for that assembly reference.
            
            Entry will be lazily filled in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._lazyHostDiagnosticAnalyzersPerReferenceMap">
            <summary>
            Key is <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.Id"/>.
            
            Value is set of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> that belong to the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/>.
            
            We populate it lazily. otherwise, we will bring in all analyzers preemptively
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._compilerDiagnosticAnalyzerMap">
            <summary>
            Maps <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> to compiler diagnostic analyzers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers._skippedHostAnalyzers">
            <summary>
            Maps list of analyzer references and <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo"/>.
            </summary>
            <remarks>
            TODO: https://github.com/dotnet/roslyn/issues/42848
            It is quite common for multiple projects to have the same set of analyzer references, yet we will create
            multiple instances of the analyzer list and thus not share the info.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.HostAnalyzerReferences">
            <summary>
            List of host <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/>s
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.GetOrCreateHostDiagnosticAnalyzersPerReference(System.String)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> identity and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s map for given <paramref name="language"/>
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.CreateDiagnosticAnalyzersPerReference(Microsoft.CodeAnalysis.Project)">
            <summary>
            Create <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> identity and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s map for given <paramref name="project"/> that
            includes both host and project analyzers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.CreateProjectDiagnosticAnalyzersPerReference(Microsoft.CodeAnalysis.Project)">
            <summary>
            Create <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> identity and <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>s map for given <paramref name="project"/> that
            has only project analyzers
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers.GetCompilerDiagnosticAnalyzer(System.String)">
            <summary>
            Return compiler <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> for the given language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IWorkspaceVenusSpanMappingService.GetAdjustedDiagnosticSpan(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Text.TextSpan@,Microsoft.CodeAnalysis.FileLinePositionSpan@,Microsoft.CodeAnalysis.FileLinePositionSpan@)">
            <summary>
            Given the original location of the diagnostic and the mapped line info based on line directives in source,
            apply any necessary adjustments to these diagnostic spans and returns the effective source span for the diagnostic.
            For example, for Venus, we might change the mapped location to be the location in the primary buffer.
            Additionally, if the secondary buffer location is outside visible user code, then the original location is also adjusted to be within visible user code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer">
            <summary>
            IDE-only project based diagnostic analyzer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)">
            <summary>
            it is not allowed one to implement both ProjectDiagnosticAnalzyer and DiagnosticAnalyzer
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer.Priority">
            <summary>
            This lets vsix installed <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer"/> to
            specify priority of the analyzer. Regular <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> always comes before those 2 different types.
            Priority is ascending order and this only works on HostDiagnosticAnalyzer meaning Vsix installed analyzers in VS.
            This is to support partner teams (such as typescript and F#) who want to order their analyzer's execution order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo">
            <summary>
            Information about analyzers supplied by the host (IDE), which can be completely skipped or its diagnostics partially filtered for the corresponding project
            as project analyzer reference (from NuGet) has equivalent analyzer(s) reporting all or subset of diagnostic IDs reported by these analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo.SkippedAnalyzers">
            <summary>
            Analyzers supplied by the host (IDE), which can be completely skipped for the corresponding project
            as project analyzer reference has equivalent analyzer(s) reporting all diagnostic IDs reported by these analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo.FilteredDiagnosticIdsForAnalyzers">
            <summary>
            Analyzer to diagnostic ID map, such that the diagnostics of those IDs reported by the analyzer should be filtered
            for a correspndiong project.
            This includes the analyzers supplied by the host (IDE), such that project's analyzer references (from NuGet)
            has equivalent analyzer(s) reporting subset of diagnostic IDs reported by these analyzers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.WellKnownDiagnosticPropertyNames.Origin">
            <summary>
            Predefined name of diagnostic property which shows in what compilation stage the diagnostic is created. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState">
            <summary>
            An implementation of <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> for the compiler that wraps a <see cref="T:Microsoft.CodeAnalysis.AdditionalDocumentState"/>.
            </summary>
            <remarks>
            Create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a <see cref="T:Microsoft.CodeAnalysis.AdditionalDocumentState"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState.#ctor(Microsoft.CodeAnalysis.AdditionalDocumentState)">
            <summary>
            An implementation of <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> for the compiler that wraps a <see cref="T:Microsoft.CodeAnalysis.AdditionalDocumentState"/>.
            </summary>
            <remarks>
            Create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a <see cref="T:Microsoft.CodeAnalysis.AdditionalDocumentState"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState.Path">
            <summary>
            Resolved path of the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState.GetText(System.Threading.CancellationToken)">
            <summary>
            Retrieves a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> with the contents of this file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions"/> that memoize structured (parsed) form of certain complex options to avoid parsing them multiple times.
            Storages of these complex options may directly call the specialized getters to reuse the cached values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticSeverityExtensions.ToReportDiagnostic(Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Returns the equivalent <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> for a <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.
            </summary>
            <param name="diagnosticSeverity">The <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.</param>
            <returns>
            The equivalent <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> for the <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <paramref name="diagnosticSeverity"/> is not one of the expected values.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ReportDiagnosticExtensions.ToDiagnosticSeverity(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Returns the equivalent <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> for a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.
            </summary>
            <param name="reportDiagnostic">The <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.</param>
            <returns>
            The equivalent <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> for a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value; otherwise,
            <see langword="null"/> if <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> does not contain a direct equivalent for
            <paramref name="reportDiagnostic"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <paramref name="reportDiagnostic"/> is not one of the expected values.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.ReportDiagnosticExtensions.WithDefaultSeverity(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Applies a default severity to a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.
            </summary>
            <param name="reportDiagnostic">The <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.</param>
            <param name="defaultSeverity">The default severity.</param>
            <returns>
            <para>If <paramref name="reportDiagnostic"/> is <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Default"/>, returns
            <paramref name="defaultSeverity"/>.</para>
            <para>-or-</para>
            <para>Otherwise, returns <paramref name="reportDiagnostic"/> if it has a non-default value.</para>
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.PascalCase">
            <summary>
            Each word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.CamelCase">
            <summary>
            Every word except the first word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.FirstUpper">
            <summary>
            Only the first word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.AllUpper">
            <summary>
            Every character is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.AllLower">
            <summary>
            No characters are capitalized
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser.NamingRuleSubsetComparer.FirstIsSubset(Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule@,Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule@)">
            <summary>
            Determines if <paramref name="x"/> matches a subset of the symbols matched by <paramref name="y"/>. The
            implementation determines which properties of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule"/> are considered for this
            evaluation. The subset relation does not necessarily indicate a proper subset.
            </summary>
            <param name="x">The first naming rule.</param>
            <param name="y">The second naming rule.</param>
            <returns><see langword="true"/> if <paramref name="x"/> matches a subset of the symbols matched by
            <paramref name="y"/> on some implementation-defined properties; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleRules.IsInterfaceImplementation(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            This does not handle the case where a method in a base type implicitly implements an
            interface method on behalf of one of its derived types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences">
            <summary>
            Contains all information related to Naming Style Preferences.
            1. Symbol Specifications
            2. Name Style
            3. Naming Rule (points to Symbol Specification IDs)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.None">
            <summary>
            Invalid value, analyzer must support at least one or more of the subsequent analysis categories.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SyntaxTreeWithoutSemanticsAnalysis">
            <summary>
            Analyzer reports syntax diagnostics (i.e. registers a SyntaxTree action).
            Note: an <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> that uses this will not work properly if
            it registers a <see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalysisContext.RegisterSyntaxNodeAction``1(System.Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])"/> and then ends
            up needing to use the <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.SemanticModel"/>.  If a
            <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> is needed, use <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticSpanAnalysis"/> or
            <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticDocumentAnalysis"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticSpanAnalysis">
            <summary>
            Analyzer reports semantic diagnostics and also supports incremental span based method body analysis.
            An analyzer can support incremental method body analysis if edits within a method body only affect the diagnostics reported by the analyzer on the edited method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory.SemanticDocumentAnalysis">
            <summary>
            Analyzer reports semantic diagnostics but doesn't support incremental span based method body analysis.
            It needs to re-analyze the whole document for reporting semantic diagnostics even for method body editing scenarios.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer">
            <summary>
            This interface is a marker for all the analyzers that are built in.
            We will record non-fatal-watson if any analyzer with this interface throws an exception.
            
            also, built in analyzer can do things that third-party analyzer (command line analyzer) can't do
            such as reporting all diagnostic descriptors as hidden when it can return different severity on runtime.
            
            or reporting diagnostics ID that is not reported by SupportedDiagnostics.
            
            this interface is used by the engine to allow this special behavior over command line analyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer.GetAnalyzerCategory">
            <summary>
            This category will be used to run analyzer more efficiently by restricting scope of analysis
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer.IsHighPriority">
            <summary>
            If this analyzer is privileged and should run with higher priority than other analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IPragmaSuppressionsAnalyzer">
            <summary>
            Special IDE analyzer to flag unnecessary inline source suppressions,
            i.e. pragma and local SuppressMessageAttribute suppressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IPragmaSuppressionsAnalyzer.AnalyzeAsync(Microsoft.CodeAnalysis.SemanticModel,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,System.Func{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DiagnosticDescriptor}},System.Action{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Analyzes the tree, with an optional span scope, and report unnecessary inline suppressions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult">
            <summary>
            This holds onto diagnostics for a specific version of project snapshot
            in a way each kind of diagnostics can be queried fast.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult.DocumentIds">
            <summary>
            The set of documents that has any kind of diagnostics on it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult._syntaxLocals">
            <summary>
            Syntax diagnostics from this file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult._semanticLocals">
            <summary>
            Semantic diagnostics from this file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult._nonLocals">
            <summary>
            Diagnostics that were produced for these documents, but came from the analysis of other files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult._others">
            <summary>
            Diagnostics that don't have locations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultBuilder">
            <summary>
            We have this builder to avoid creating collections unnecessarily.
            Expectation is that, most of time, most of analyzers doesn't have any diagnostics. so no need to actually create any objects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultBuilder.#ctor(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            We have this builder to avoid creating collections unnecessarily.
            Expectation is that, most of time, most of analyzers doesn't have any diagnostics. so no need to actually create any objects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultMap">
            <summary>
            Basically typed tuple.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.IHostDiagnosticAnalyzerProvider">
            <summary>
            An interface implemented by hosts to provide the host-level analyzers; for example in Visual Studio for Windows this
            is where we'll fetch VSIX-defined analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection">
            <summary>
            Helper class to manage collections of source-file like things; this exists just to avoid duplicating all the logic for regular source files
            and additional files.
            </summary>
            <remarks>This class should be free-threaded, and any synchronization is done via <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._gate"/>.
            This class is otherwise free to operate on private members of <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._project"/> if needed.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._documentPathsToDocumentIds">
            <summary>
            The map of file paths to the underlying <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>. This document may exist in <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._documentsAddedInBatch"/> or has been
            pushed to the actual workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._sourceTextContainersToDocumentIds">
            <summary>
            A map of explicitly-added "always open" <see cref="T:Microsoft.CodeAnalysis.Text.SourceTextContainer"/> and their associated <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>. This does not contain
            any regular files that have been open.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._documentIdToDynamicFileInfoProvider">
            <summary>
            The map of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> to <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> whose <see cref="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo"/> got added into <see cref="T:Microsoft.CodeAnalysis.Workspace"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._documentsAddedInBatch">
            <summary>
            The current list of documents that are to be added in this batch.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._documentsRemovedInBatch">
            <summary>
            The current list of documents that are being removed in this batch. Once the document is in this list, it is no longer in <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._documentPathsToDocumentIds"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection._orderedDocumentsInBatch">
            <summary>
            The current list of document file paths that will be ordered in a batch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection.ProcessDynamicFileChange(System.String,System.String)">
            <summary>
            Process file content changes
            </summary>
            <param name="projectSystemFilePath">filepath given from project system</param>
            <param name="workspaceFilePath">filepath used in workspace. it might be different than projectSystemFilePath</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection.UpdateSolutionForBatch(Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,System.Collections.Immutable.ImmutableArray{System.String}.Builder,System.Func{Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo},Microsoft.CodeAnalysis.Solution},Microsoft.CodeAnalysis.WorkspaceChangeKind,System.Func{Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.Solution},Microsoft.CodeAnalysis.WorkspaceChangeKind)">
            <summary>
            Updates the solution for a set of batch changes.
            While it is OK for this method to *read* local state, it cannot *modify* it as this may
            be called multiple times (when the workspace update fails due to interceding updates).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._gate">
            <summary>
            A semaphore taken for all mutation of any mutable field in this type.
            </summary>
            <remarks>This is, for now, intentionally pessimistic. There are no doubt ways that we could allow more to run in
            parallel, but the current tradeoff is for simplicity of code and "obvious correctness" than something that is
            subtle, fast, and wrong.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._activeBatchScopes">
            <summary>
            The number of active batch scopes. If this is zero, we are not batching, non-zero means we are batching.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._projectAnalyzerPaths">
            <summary>
            The set of actual analyzer reference paths that the project knows about.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._sdkCodeStyleAnalyzerPaths">
            <summary>
            The set of SDK code style analyzer reference paths that the project knows about.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._analyzersAddedInBatch">
            <summary>
            Paths to analyzers we want to add when the current batch completes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._analyzersRemovedInBatch">
            <summary>
            Paths to analzyers we want to remove when the current batch completes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.IsPrimary">
            <summary>
            If this project is the 'primary' project the project system cares about for a group of Roslyn projects that
            correspond to different configurations of a single project system project. <see langword="true"/> by
            default.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._allMetadataReferences">
            <summary>
            The full list of all metadata references this project has. References that have internally been converted to project references
            will still be in this.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._documentWatchedFiles">
            <summary>
            The file watching tokens for the documents in this project. We get the tokens even when we're in a batch, so the files here
            may not be in the actual workspace yet.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._documentFileChangeContext">
            <summary>
            A file change context used to watch source files, additional files, and analyzer config files for this project. It's automatically set to watch the user's project
            directory so we avoid file-by-file watching.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._eventSubscriptionTracker">
            <summary>
            track whether we have been subscribed to <see cref="E:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.Updated"/> event
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject._dynamicFilePathMaps">
             <summary>
             Map of the original dynamic file path to the <see cref="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.FilePath"/> that was associated with it.
            
             For example, the key is something like Page.cshtml which is given to us from the project system calling
             <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.AddDynamicSourceFile(System.String,System.Collections.Immutable.ImmutableArray{System.String})"/>. The value of the map is a generated file that
             corresponds to the original path, say Page.g.cs. If we were given a file by the project system but no
             <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> provided a file for it, we will record the value as null so we still can track
             the addition of the .cshtml file for a later call to <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.RemoveDynamicSourceFile(System.String)"/>.
            
             The workspace snapshot will only have a document with  <see cref="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.FilePath"/> (the value) but not the
             original dynamic file path (the key).
             </summary>
             <remarks>
             We use the same string comparer as in the <see cref="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchingDocumentCollection"/> used by _sourceFiles, below, as these
             files are added to that collection too.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.TryReportCompilationThrownAway(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Reports a telemetry event if compilation information is being thrown away after being previously computed
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.CompilationOutputAssemblyFilePath">
            <summary>
            The path to the output in obj.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.DefaultNamespace">
             <summary>
             The default namespace of the project.
             </summary>
             <remarks>
             In C#, this is defined as the value of "rootnamespace" msbuild property. Right now VB doesn't
             have the concept of "default namespace", but we conjure one in workspace by assigning the value
             of the project's root namespace to it. So various features can choose to use it for their own purpose.
            
             In the future, we might consider officially exposing "default namespace" for VB project
             (e.g.through a "defaultnamespace" msbuild property)
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.MaxLangVersion">
            <summary>
            The max language version supported for this project, if applicable. Useful to help indicate what
            language version features should be suggested to a user, as well as if they can be upgraded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.BatchScope._disposed">
            <summary>
            Flag to control if this has already been disposed. Not a boolean only so it can be used with Interlocked.CompareExchange.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.AddSourceTextContainer(Microsoft.CodeAnalysis.Text.SourceTextContainer,System.String,Microsoft.CodeAnalysis.SourceCodeKind,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,Microsoft.CodeAnalysis.Host.IDocumentServiceProvider)">
            <summary>
            Adds a source file to the project from a text container (eg, a Visual Studio Text buffer)
            </summary>
            <param name="textContainer">The text container that contains this file.</param>
            <param name="fullPath">The file path of the document.</param>
            <param name="sourceCodeKind">The kind of the source code.</param>
            <param name="folders">The names of the logical nested folders the document is contained in.</param>
            <param name="designTimeOnly">Whether the document is used only for design time (eg. completion) or also included in a compilation.</param>
            <param name="documentServiceProvider">A <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> associated with this document</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.GetPropertiesForMetadataReference(System.String)">
            <summary>
            Returns the properties being used for the current metadata reference added to this project. May return multiple properties if
            the reference has been added multiple times with different properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.ClearAndZeroCapacity``1(System.Collections.Generic.List{``0})">
            <summary>
            Clears a list and zeros out the capacity. The lists we use for batching are likely to get large during an initial load, but after
            that point should never get that large again.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.ClearAndZeroCapacity``1(System.Collections.Immutable.ImmutableArray{``0}.Builder)">
            <summary>
            Clears a list and zeros out the capacity. The lists we use for batching are likely to get large during an initial load, but after
            that point should never get that large again.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._gate">
            <summary>
            The main gate to synchronize updates to this solution.
            </summary>
            <remarks>
            See the Readme.md in this directory for further comments about threading in this area.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._projectUpdateState">
            <summary>
            Stores the latest state of the project system factory.
            Access to this is synchronized via <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._gate"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.DocumentsNotFromFiles">
            <summary>
            A set of documents that were added by <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProject.AddSourceTextContainer(Microsoft.CodeAnalysis.Text.SourceTextContainer,System.String,Microsoft.CodeAnalysis.SourceCodeKind,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean,Microsoft.CodeAnalysis.Host.IDocumentServiceProvider)"/>, and aren't otherwise
            tracked for opening/closing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._projectToMaxSupportedLangVersionMap">
            <remarks>Should be updated with <see cref="T:System.Collections.Immutable.ImmutableInterlocked"/>.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._projectToDependencyNodeTargetIdentifier">
            <remarks>Should be updated with <see cref="T:System.Collections.Immutable.ImmutableInterlocked"/>.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.SolutionClosing">
            <summary>
            Set by the host if the solution is currently closing; this can be used to optimize some things there.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.SolutionPath">
            <summary>
            The current path to the solution. Currently this is only used to update the solution path when the first project is added -- we don't have a concept
            of the solution path changing in the middle while a bunch of projects are loaded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyChangeToWorkspace(System.Action{Microsoft.CodeAnalysis.Workspace})">
            <summary>
            Applies a single operation to the workspace. <paramref name="action"/> should be a call to one of the protected Workspace.On* methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyChangeToWorkspaceAsync(System.Action{Microsoft.CodeAnalysis.Workspace},System.Threading.CancellationToken)">
            <summary>
            Applies a single operation to the workspace. <paramref name="action"/> should be a call to one of the protected Workspace.On* methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyChangeToWorkspaceMaybeAsync(System.Boolean,System.Action{Microsoft.CodeAnalysis.Workspace})">
            <summary>
            Applies a single operation to the workspace. <paramref name="action"/> should be a call to one of the protected Workspace.On* methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyChangeToWorkspaceWithProjectUpdateState(System.Func{Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})">
            <summary>
            Applies a single operation to the workspace that also needs to update the <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._projectUpdateState"/>.
            <paramref name="action"/> should be a call to one of the protected Workspace.On* methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyChangeToWorkspace(Microsoft.CodeAnalysis.ProjectId,System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution})">
             <summary>
             Applies a solution transformation to the workspace and triggers workspace changed event for specified <paramref name="projectId"/>.
             The transformation shall only update the project of the solution with the specified <paramref name="projectId"/>.
            
             The <paramref name="solutionTransformation"/> function must be safe to be attempted multiple times (and not update local state).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspace(System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspaceAsync(System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspaceAsync(System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspaceAsync(System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspaceMaybeAsync(System.Boolean,System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspaceAsync(System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyBatchChangeToWorkspaceMaybe_NoLockAsync(System.Boolean,System.Func{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState},System.Action{Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState})">
            <summary>
            Applies a change to the workspace that can do any number of project changes.
            The mutation action must be safe to attempt multiple times, in case there are interceding solution changes.
            If outside changes need to run under the global lock and run only once, they should use the <paramref name="onAfterUpdateAlways"/> action.
            <paramref name="onAfterUpdateAlways"/> will always run even if the transformation applied no changes.
            </summary>
            <remarks>This is needed to synchronize with <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ApplyChangeToWorkspace(System.Action{Microsoft.CodeAnalysis.Workspace})" /> to avoid any races. This
            method could be moved down to the core Workspace layer and then could use the synchronization lock there.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.RemoveProjectFromTrackingMaps_NoLock(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Removes the project from the various maps this type maintains; it's still up to the caller to actually remove
            the project in one way or another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ConvertMetadataReferencesToProjectReferences_NoLock(Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.ProjectId,System.String,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState)">
            <summary>
            Attempts to convert all metadata references to <paramref name="outputPath"/> to a project reference to <paramref
            name="projectIdToReference"/>.
            </summary>
            <param name="projectIdToReference">The <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> of the project that could be referenced in place
            of the output path.</param>
            <param name="outputPath">The output path to replace.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ConvertProjectReferencesToMetadataReferences_NoLock(Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator,Microsoft.CodeAnalysis.ProjectId,System.String,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Finds all projects that had a project reference to <paramref name="projectId"/> and convert it back to a metadata reference.
            </summary>
            <param name="projectId">The <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> of the project being referenced.</param>
            <param name="outputPath">The output path of the given project to remove the link to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.TryCreateConvertedProjectReference_NoLock(Microsoft.CodeAnalysis.ProjectId,System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectReference@)">
            <summary>
            Converts a metadata reference to a project reference if possible.
            This must be safe to run multiple times for the same reference as it is called
            during a workspace update (which will attempt to apply the update multiple times).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.TryRemoveConvertedProjectReference_NoLock(Microsoft.CodeAnalysis.ProjectId,System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,Microsoft.CodeAnalysis.ProjectReference@)">
            <summary>
            Tries to convert a metadata reference to remove to a project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.CreateMetadataReference_NoLock(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Gets or creates a PortableExecutableReference instance for the given file path and properties.
            Calls to this are expected to be serialized by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.StartRefreshingReferencesForFileAsync``1(System.String,System.Func{Microsoft.CodeAnalysis.Project,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{Microsoft.CodeAnalysis.Host.SolutionServices,``0,``0},System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState,``0,``0,System.ValueTuple{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState}},System.Threading.CancellationToken)">
            <summary>
            Core helper that handles refreshing the references we have for a particular <see
            cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> or <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState">
            <summary>
            Immutable data type that holds the current state of the project system factory as well as storing any
            incremental state changes in the current workspace update.
            
            This state is updated by various project system update operations under the <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._gate"/>. Importantly,
            this immutable type allows us to discard updates to the state that fail to apply due to interceding workspace
            operations.
            
            There are two kinds of state that this type holds that need to support discarding:
            <list type="number">
            <item>Global state for the <see cref="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory"/> (various maps of project information). This
            state must be saved between different changes.</item>
            <item>Incremental state for the current change being processed.  This state has information that is cannot be
            resilient to being applied multiple times during the workspace update, so is saved to be applied only once the
            workspace update is successful.</item>
            </list>
            </summary>
            <param name="ProjectsByOutputPath">
            Global state representing a multimap from an output path to the project outputting to it. Ideally, this
            shouldn't ever actually be a true multimap, since we shouldn't have two projects outputting to the same path,
            but any bug by a project adding the wrong output path means we could end up with some duplication. In that case,
            we'll temporarily have two until (hopefully) somebody removes it.
            </param>
            <param name="ProjectReferenceInfos">
            Global state containing output paths and converted project reference information for each project.
            </param>
            <param name="RemovedMetadataReferences">
            Incremental state containing metadata references removed in the current update.
            </param>
            <param name="AddedMetadataReferences">
            Incremental state containing metadata references added in the current update.
            </param>
            <param name="RemovedAnalyzerReferences">
            Incremental state containing analyzer references removed in the current update.
            </param>
            <param name="AddedAnalyzerReferences">
            Incremental state containing analyzer references added in the current update.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.#ctor(System.Collections.Immutable.ImmutableDictionary{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectReferenceInformation},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PortableExecutableReference},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.PortableExecutableReference},System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Immutable data type that holds the current state of the project system factory as well as storing any
            incremental state changes in the current workspace update.
            
            This state is updated by various project system update operations under the <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory._gate"/>. Importantly,
            this immutable type allows us to discard updates to the state that fail to apply due to interceding workspace
            operations.
            
            There are two kinds of state that this type holds that need to support discarding:
            <list type="number">
            <item>Global state for the <see cref="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory"/> (various maps of project information). This
            state must be saved between different changes.</item>
            <item>Incremental state for the current change being processed.  This state has information that is cannot be
            resilient to being applied multiple times during the workspace update, so is saved to be applied only once the
            workspace update is successful.</item>
            </list>
            </summary>
            <param name="ProjectsByOutputPath">
            Global state representing a multimap from an output path to the project outputting to it. Ideally, this
            shouldn't ever actually be a true multimap, since we shouldn't have two projects outputting to the same path,
            but any bug by a project adding the wrong output path means we could end up with some duplication. In that case,
            we'll temporarily have two until (hopefully) somebody removes it.
            </param>
            <param name="ProjectReferenceInfos">
            Global state containing output paths and converted project reference information for each project.
            </param>
            <param name="RemovedMetadataReferences">
            Incremental state containing metadata references removed in the current update.
            </param>
            <param name="AddedMetadataReferences">
            Incremental state containing metadata references added in the current update.
            </param>
            <param name="RemovedAnalyzerReferences">
            Incremental state containing analyzer references removed in the current update.
            </param>
            <param name="AddedAnalyzerReferences">
            Incremental state containing analyzer references added in the current update.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.ProjectsByOutputPath">
            <summary>
            Global state representing a multimap from an output path to the project outputting to it. Ideally, this
            shouldn't ever actually be a true multimap, since we shouldn't have two projects outputting to the same path,
            but any bug by a project adding the wrong output path means we could end up with some duplication. In that case,
            we'll temporarily have two until (hopefully) somebody removes it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.ProjectReferenceInfos">
            <summary>
            Global state containing output paths and converted project reference information for each project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.RemovedMetadataReferences">
            <summary>
            Incremental state containing metadata references removed in the current update.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.AddedMetadataReferences">
            <summary>
            Incremental state containing metadata references added in the current update.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.RemovedAnalyzerReferences">
            <summary>
            Incremental state containing analyzer references removed in the current update.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.AddedAnalyzerReferences">
            <summary>
            Incremental state containing analyzer references added in the current update.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectFactory.ProjectUpdateState.ClearIncrementalState">
            <summary>
            Returns a new instance with any incremental state that should not be saved between updates cleared.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor._gate">
            <summary>
            Gate to guard all mutable fields in this class.
            The lock hierarchy means you are allowed to call out of this class and into <see cref="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor._project"/> while holding the lock.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor._commandLineChecksum">
            <summary>
            A hashed checksum of the last command line we were set to.  We use this
            as a low cost (in terms of memory) way to determine if the command line
            actually changes and we need to make any downstream updates.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor._commandLineStorageHandle">
            <summary>
            To save space in the managed heap, we dump the entire command-line string to our
            temp-storage-service. This is helpful as compiler command-lines can grow extremely large
            (especially in cases with many references).
            </summary>
            <remarks>Note: this will be null in the case that the command line is an empty array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.ReparseCommandLineIfChanged_NoLock(System.Collections.Immutable.ImmutableArray{System.String})">
            <returns><see langword="true"/> if the command line was updated.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.EffectiveRuleSetFilePath">
            <summary>
            Returns the active path to the rule set file that is being used by this project, or null if there isn't a rule set file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.GetParsedCommandLineArguments">
            <summary>
            Returns the parsed command line arguments for the arguments set with <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.SetCommandLine(System.Collections.Immutable.ImmutableArray{System.String})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.ComputeCompilationOptionsWithHostValues(Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.IRuleSetFile)">
            <summary>
            Overridden by derived classes to provide a hook to modify a <see cref="T:Microsoft.CodeAnalysis.CompilationOptions"/> with any host-provided values that didn't come from
            the command line string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.ComputeParseOptionsWithHostValues(Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Override by derived classes to provide a hook to modify a <see cref="T:Microsoft.CodeAnalysis.ParseOptions"/> with any host-provided values that didn't come from 
            the command line string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.UpdateProjectForNewHostValues">
            <summary>
            Called by a derived class to notify that we need to update the settings in the project system for something that will be provided
            by either <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.ComputeCompilationOptionsWithHostValues(Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Workspaces.ProjectSystem.IRuleSetFile)"/> or <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.ProjectSystemProjectOptionsProcessor.ComputeParseOptionsWithHostValues(Microsoft.CodeAnalysis.ParseOptions)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator">
            <summary>
            A little helper type to hold onto the <see cref="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.Solution"/> being updated in a batch, which also
            keeps track of the right <see cref="T:Microsoft.CodeAnalysis.WorkspaceChangeKind"/> to raise when we are done.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.#ctor(Microsoft.CodeAnalysis.Solution)">
            <summary>
            A little helper type to hold onto the <see cref="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.Solution"/> being updated in a batch, which also
            keeps track of the right <see cref="T:Microsoft.CodeAnalysis.WorkspaceChangeKind"/> to raise when we are done.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator._workspaceChangeKind">
            <summary>
            The kind that encompasses all the changes we've made. It's null if no changes have been made,
            and <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectChanged"/> or
            <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionChanged"/> if we can't give a more precise type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.UpdateSolutionForRemovedDocumentAction(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.WorkspaceChangeKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            The same as <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.UpdateSolutionForDocumentAction(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.WorkspaceChangeKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId})" /> but also records
            the removed documents into <see cref="P:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.DocumentIdsRemoved"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.UpdateSolutionForProjectAction(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Should be called to update the solution if there isn't a specific document change kind that should be
            given to <see cref="M:Microsoft.CodeAnalysis.Workspaces.ProjectSystem.SolutionChangeAccumulator.UpdateSolutionForDocumentAction(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.WorkspaceChangeKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId})"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.AbstractSyntaxComparer.TryComputeWeightedDistance(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Double@)">
            <summary>
            Calculates distance of two nodes based on their significant parts.
            Returns false if the nodes don't have any significant parts and should be compared as a whole.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.Edit`1">
            <summary>
            Represents an edit operation on a tree or a sequence of nodes.
            </summary>
            <typeparam name="TNode">Tree node.</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.Edit`1.OldNode">
            <summary>
            Insert: 
            default(TNode).
            
            Delete: 
            Deleted node.
            
            Move, Update: 
            Node in the old tree/sequence.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.Edit`1.NewNode">
            <summary>
            Insert: 
            Inserted node.
            
            Delete: 
            default(TNode)
            
            Move, Update:
            Node in the new tree/sequence.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.None">
            <summary>
            No change.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Update">
            <summary>
            Node value was updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Insert">
            <summary>
            Node was inserted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Delete">
            <summary>
            Node was deleted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Move">
            <summary>
            Node changed parent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Reorder">
            <summary>
            Node changed position within its parent. The parent nodes of the old node and the new node are matching.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.EditScript`1">
            <summary>
            Represents a sequence of tree edits.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonImmutableArraySubsequence`1">
            <summary>
            Calculates Longest Common Subsequence for immutable arrays.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.MaxSequenceLengthForDistanceCalculation">
            <summary>
            Limit the number of tokens used to compute distance between sequences of tokens so that 
            we always use the pooled buffers. The combined length of the two sequences being compared
            must be less than <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.PooledSegmentMaxDepthThreshold"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer">
            <summary>
            Underlying storage for <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VArray"/>s allocated on <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VStack"/>.
            </summary>
            <remarks>
            The LCS algorithm allocates <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VArray"/>s of sizes (3, 2*1 + 1, ..., 2*D + 1), always in this order, 
            where D is at most the sum of lengths of the compared sequences.
            The arrays get pushed on a stack as they are built up, then all consumed in the reverse order (stack pop).
            
            Since the exact length of each array in the above sequence is known we avoid allocating each individual array.
            Instead we allocate a large buffer serving as a a backing storage of a contiguous sequence of arrays 
            corresponding to stack depths <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.MinDepth"/> to <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.MaxDepth"/>.
            If more storage is needed we chain next large buffer to the previous one in a linked list.
            
            We pool a few of these linked buffers on <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VStack"/> to conserve allocations.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.FirstSegmentMaxDepth">
            <summary>
            The max stack depth backed by the fist buffer.
            Size of the buffer for 100 is ~10K. 
            For 150 it'd be 91KB, which would be allocated on LOH.
            The buffers grow by factor of <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.GrowFactor"/>, so the next buffer will be allocated on LOH.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.PooledSegmentMaxDepthThreshold">
            <summary>
            Do not expand pooled buffers to more than ~12 MB total size (sum of all linked segment sizes).
            This threshold is achieved when <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.MaxDepth"/> is greater than <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence.VBuffer.PooledSegmentMaxDepthThreshold"/> = sqrt(size_limit / sizeof(int)).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1">
            <summary>
            Calculates Longest Common Subsequence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ComputeDistance(`0,System.Int32,`0,System.Int32)">
            <summary>
            Returns a distance [0..1] of the specified sequences.
            The smaller distance the more similar the sequences are.
            </summary>
            <summary>
            Returns a distance [0..1] of the specified sequences.
            The smaller distance the more similar the sequences are.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ComputeEditPaths(`0,System.Int32,`0,System.Int32)">
             <summary>
             Calculates a list of "V arrays" using Eugene W. Myers O(ND) Difference Algorithm
             </summary>
             <remarks>
             
             The algorithm was inspired by Myers' Diff Algorithm described in an article by Nicolas Butler:
             https://www.codeproject.com/articles/42279/investigating-myers-diff-algorithm-part-of
             The author has approved the use of his code from the article under the Apache 2.0 license.
             
             The algorithm works on an imaginary edit graph for A and B which has a vertex at each point in the grid(i, j), i in [0, lengthA] and j in [0, lengthB].
             The vertices of the edit graph are connected by horizontal, vertical, and diagonal directed edges to form a directed acyclic graph.
             Horizontal edges connect each vertex to its right neighbor. 
             Vertical edges connect each vertex to the neighbor below it.
             Diagonal edges connect vertex (i,j) to vertex (i-1,j-1) if <see cref="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ItemsEqual(`0,System.Int32,`0,System.Int32)"/>(sequenceA[i-1],sequenceB[j-1]) is true.
             
             Move right along horizontal edge (i-1,j)-(i,j) represents a delete of sequenceA[i-1].
             Move down along vertical edge (i,j-1)-(i,j) represents an insert of sequenceB[j-1].
             Move along diagonal edge (i-1,j-1)-(i,j) represents an match of sequenceA[i-1] to sequenceB[j-1].
             The number of diagonal edges on the path from (0,0) to (lengthA, lengthB) is the length of the longest common sub.
            
             The function does not actually allocate this graph. Instead it uses Eugene W. Myers' O(ND) Difference Algoritm to calculate a list of "V arrays" and returns it in a Stack. 
             A "V array" is a list of end points of so called "snakes". 
             A "snake" is a path with a single horizontal (delete) or vertical (insert) move followed by 0 or more diagonals (matching pairs).
             
             Unlike the algorithm in the article this implementation stores 'y' indexes and prefers 'right' moves instead of 'down' moves in ambiguous situations
             to preserve the behavior of the original diff algorithm (deletes first, inserts after).
             
             The number of items in the list is the length of the shortest edit script = the number of inserts/edits between the two sequences = D. 
             The list can be used to determine the matching pairs in the sequences (GetMatchingPairs method) or the full editing script (GetEdits method).
             
             The algorithm uses O(ND) time and memory where D is the number of delete/inserts and N is the sum of lengths of the two sequences.
             
             VArrays store just the y index because x can be calculated: x = y + k.
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubstring">
            <summary>
            Calculates longest common substring using Wagner algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.Match`1.GetTreeEdits">
            <summary>
            Returns an edit script (a sequence of edits) that transform <see cref="P:Microsoft.CodeAnalysis.Differencing.Match`1.OldRoot"/> subtree 
            to <see cref="P:Microsoft.CodeAnalysis.Differencing.Match`1.NewRoot"/> subtree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.Match`1.GetSequenceEdits(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns an edit script (a sequence of edits) that transform a sequence of nodes <paramref name="oldNodes"/>
            to a sequence of nodes <paramref name="newNodes"/>. 
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="oldNodes"/> or <paramref name="newNodes"/> is a null reference.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.SequenceEdit">
            <summary>
            Represents an edit operation on a sequence of values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.SequenceEdit.Kind">
            <summary>
            The kind of edit: <see cref="F:Microsoft.CodeAnalysis.Differencing.EditKind.Delete"/>, <see cref="F:Microsoft.CodeAnalysis.Differencing.EditKind.Insert"/>, or <see cref="F:Microsoft.CodeAnalysis.Differencing.EditKind.Update"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.SequenceEdit.OldIndex">
            <summary>
            Index in the old sequence, or -1 if the edit is insert.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.SequenceEdit.NewIndex">
            <summary>
            Index in the new sequence, or -1 if the edit is delete.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.TreeComparer`1">
            <summary>
            Implements a tree differencing algorithm.
            </summary>
            <remarks>
            Subclasses define relationships among tree nodes, and parameters to the differencing algorithm.
            </remarks>
            <typeparam name="TNode">Tree node.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ComputeEditScript(`0,`0)">
            <summary>
            Returns an edit script that transforms <paramref name="oldRoot"/> to <paramref name="newRoot"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ComputeMatch(`0,`0,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`0}})">
            <summary>
            Returns a match map of <paramref name="oldRoot"/> descendants to <paramref name="newRoot"/> descendants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetDistance(`0,`0)">
            <summary>
            Calculates the distance [0..1] of two nodes.
            </summary>
            <remarks>
            The more similar the nodes the smaller the distance.
            
            Used to determine whether two nodes of the same label match.
            Even if 0 is returned the nodes might be slightly different.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ValuesEqual(`0,`0)">
            <summary>
            Returns true if the specified nodes have equal values.
            </summary>
            <remarks>
            Called with matching nodes (<paramref name="oldNode"/>, <paramref name="newNode"/>).
            Return true if the values of the nodes are the same, or their difference is not important.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.LabelCount">
            <summary>
            The number of distinct labels used in the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetLabel(`0)">
            <summary>
            Returns an integer label corresponding to the given node.
            </summary>
            <remarks>Returned value must be within [0, LabelCount).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TiedToAncestor(System.Int32)">
            <summary>
            Returns N > 0 if the node with specified label can't change its N-th ancestor node, zero otherwise.
            </summary>
            <remarks>
            1st ancestor is the node's parent node.
            2nd ancestor is the node's grandparent node.
            etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetChildren(`0)">
            <summary>
            May return null if the <paramref name="node"/> is a leaf.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetDescendants(`0)">
            <summary>
            Enumerates all descendant nodes of the given node in depth-first prefix order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TryGetParent(`0,`0@)">
            <summary>
            Returns a parent for the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TreesEqual(`0,`0)">
            <summary>
            Return true if specified nodes belong to the same tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetSpan(`0)">
            <summary>
            Returns the position of the node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.DeclarationKind">
            <devdocs>
            This should contain only language-agnostic declarations. Things like record struct should fall under struct, etc.
            </devdocs>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.DeclarationKind.Class">
            <summary>
            Represents a class declaration, including record class declarations in C#.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.DeclarationKind.Struct">
            <summary>
            Represents a struct declaration, including record struct declarations in C#.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.DeclarationKind.SetAccessor">
            <summary>
            Represents set accessor declaration of a property, including init accessors in C#.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.DocumentEditor">
            <summary>
            An editor for making changes to a document's syntax tree. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.DocumentEditor.CreateAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.DocumentEditor.OriginalDocument">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Document"/> specified when the editor was first created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.DocumentEditor.SemanticModel">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> of the original document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.DocumentEditor.GetChangedDocument">
            <summary>
            Returns the changed <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the span specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the sub-trees annotated with the <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the spans specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the sub-trees annotated with the <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the spans specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSymbolAnnotationAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSymbolAnnotationAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the sub-trees annotated with the <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.ImplicitConversion">
            <summary>
            The name assigned to an implicit (widening) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.ExplicitConversion">
            <summary>
            The name assigned to an explicit (narrowing) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Addition">
            <summary>
            The name assigned to the Addition operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.BitwiseAnd">
            <summary>
            The name assigned to the BitwiseAnd operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.BitwiseOr">
            <summary>
            The name assigned to the BitwiseOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Decrement">
            <summary>
            The name assigned to the Decrement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Division">
            <summary>
            The name assigned to the Division operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Equality">
            <summary>
            The name assigned to the Equality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.ExclusiveOr">
            <summary>
            The name assigned to the ExclusiveOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.False">
            <summary>
            The name assigned to the False operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.GreaterThan">
            <summary>
            The name assigned to the GreaterThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.GreaterThanOrEqual">
            <summary>
            The name assigned to the GreaterThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Increment">
            <summary>
            The name assigned to the Increment operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Inequality">
            <summary>
            The name assigned to the Inequality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LeftShift">
            <summary>
            The name assigned to the LeftShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LessThan">
            <summary>
            The name assigned to the LessThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LessThanOrEqual">
            <summary>
            The name assigned to the LessThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LogicalNot">
            <summary>
            The name assigned to the LogicalNot operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Modulus">
            <summary>
            The name assigned to the Modulus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Multiply">
            <summary>
            The name assigned to the Multiply operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.OnesComplement">
            <summary>
            The name assigned to the OnesComplement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.RightShift">
            <summary>
            The name assigned to the RightShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Subtraction">
            <summary>
            The name assigned to the Subtraction operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.True">
            <summary>
            The name assigned to the True operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.UnaryNegation">
            <summary>
            The name assigned to the UnaryNegation operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.UnaryPlus">
            <summary>
            The name assigned to the UnaryPlus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.UnsignedRightShift">
            <summary>
            The name assigned to the UnsignedRightShift operator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SolutionEditor">
            <summary>
            An editor for making changes to multiple documents in a solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SolutionEditor.#ctor(Microsoft.CodeAnalysis.Solution)">
            <summary>
            An editor for making changes to multiple documents in a solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SolutionEditor.OriginalSolution">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Solution"/> that was specified when the <see cref="T:Microsoft.CodeAnalysis.Editing.SolutionEditor"/> was constructed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SolutionEditor.GetDocumentEditorAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> for the corresponding <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SolutionEditor.GetChangedSolution">
            <summary>
            Returns the changed <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SymbolEditor">
            <summary>
            An editor for making changes to symbol source declarations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.Create(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SymbolEditor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.Create(Microsoft.CodeAnalysis.Document)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SymbolEditor"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SymbolEditor.OriginalSolution">
            <summary>
            The original solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SymbolEditor.ChangedSolution">
            <summary>
            The solution with the edits applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetChangedDocuments">
            <summary>
            The documents changed since the <see cref="T:Microsoft.CodeAnalysis.Editing.SymbolEditor"/> was constructed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetCurrentSymbolAsync(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the current symbol for a source symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetCurrentDeclarationsAsync(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the current declarations for the specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the declaration syntax nodes for a given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.TryGetBestDeclarationForSingleEdit(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the best declaration node for adding members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction">
            <summary>
            An action that make changes to a declaration node within a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
            <param name="editor">The <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> to apply edits to.</param>
            <param name="declaration">The declaration to edit.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction">
            <summary>
            An action that make changes to a declaration node within a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
            <param name="editor">The <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> to apply edits to.</param>
            <param name="declaration">The declaration to edit.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="location">A location within one of the symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="location">A location within one of the symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the symbol's declaration where the member is also declared.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="member">A symbol whose declaration is contained within one of the primary symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the symbol's declaration where the member is also declared.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="member">A symbol whose declaration is contained within one of the primary symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditAllDeclarationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing all the symbol's declarations. 
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to be edited.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditAllDeclarationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing all the symbol's declarations. 
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to be edited.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.GetBaseOrInterfaceDeclarationReferenceAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the reference to the declaration of the base or interface type as part of the symbol's declaration. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Func{Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Changes the base type of the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Changes the base type of the symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor">
            <summary>
            An editor for making changes to a syntax tree. The editor works by giving a list of changes to perform to a
            particular tree <em>in order</em>.  Changes are given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> they will apply to in the
            original tree the editor is created for.  The semantics of application are as follows:
            
            <list type="number">
            <item>
            The original root provided is used as the 'current' root for all operations.  This 'current' root will
            continually be updated, becoming the new 'current' root.  The original root is never changed.
            </item>
            <item>
            Each change has its given <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> tracked, using a <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>, producing a
            'current' root that tracks all of them.  This allows that same node to be found after prior changes are applied
            which mutate the tree.
            </item>
            <item>
            Each change is then applied in order it was added to the editor.
            </item>
            <item>
            A change first attempts to find its <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> in the 'current' root.  If that node cannot be
            found, the operation will fail with an <see cref="T:System.ArgumentException"/>.
            </item>
            <item>
            The particular change will run on that node, removing, replacing, or inserting around it according to the
            change.  If the change is passed a delegate as its 'compute' argument, it will be given the <see
            cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> found in the current root.  The 'current' root will then be updated by replacing the current
            node with the new computed node.
            </item>
            <item>
            The 'current' root is then returned.
            </item>
            </list>
            </summary>
            <remarks>
            The above editing strategy makes it an error for a client of the editor to add a change that updates a parent
            node and then adds a change that updates a child node (unless the parent change is certain to contain the
            child), and attempting this will throw at runtime.  If a client ever needs to update both a child and a parent,
            it <em>should</em> add the child change first, and then the parent change.  And the parent change should pass an
            appropriate 'compute' callback so it will see the results of the child change.
            <para/> If a client wants to make a replacement, then find the <em>value</em> <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> put into
            the tree, that can be done by adding a dedicated annotation to that node and then looking it back up in the
            'current' node passed to a 'compute' callback.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Host.HostWorkspaceServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SyntaxEditor.OriginalRoot">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> that was specified when the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor"/> was constructed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SyntaxEditor.Generator">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> to use to create and change <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.GetChangedRoot">
            <summary>
            Returns the changed root node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.TrackNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Makes sure the node is tracked, even if it is not changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Remove the node from the tree.
            </summary>
            <param name="node">The node to remove that currently exists as part of the tree.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Remove the node from the tree.
            </summary>
            <param name="node">The node to remove that currently exists as part of the tree.</param>
            <param name="options">Options that affect how node removal works.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.ReplaceNode(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Replace the specified node with a node produced by the function.
            </summary>
            <param name="node">The node to replace that already exists in the tree.</param>
            <param name="computeReplacement">A function that computes a replacement node. 
            The node passed into the compute function includes changes from prior edits. It will not appear as a descendant of the original root.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.ReplaceNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Replace the specified node with a different node.
            </summary>
            <param name="node">The node to replace that already exists in the tree.</param>
            <param name="newNode">The new node that will be placed into the tree in the existing node's location.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertBefore(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Insert the new nodes before the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed before. This must be a node this is contained within a syntax list.</param>
            <param name="newNodes">The nodes to place before the existing node. These nodes must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertBefore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Insert the new node before the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed before. This must be a node this is contained within a syntax list.</param>
            <param name="newNode">The node to place before the existing node. This node must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertAfter(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Insert the new nodes after the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed after. This must be a node this is contained within a syntax list.</param>
            <param name="newNodes">The nodes to place after the existing node. These nodes must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertAfter(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Insert the new node after the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed after. This must be a node this is contained within a syntax list.</param>
            <param name="newNode">The node to place after the existing node. This node must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator">
            <summary>
            A language agnostic factory for creating syntax nodes.
            
            This API can be used to create language specific syntax nodes that are semantically 
            similar between languages.
            
            The trees generated by this API will try to respect user preferences when
            possible.  For example, generating <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.String)"/> 
            will be done in a way such that "this." or "Me." will be simplified according to user
            preference if <see cref="T:Microsoft.CodeAnalysis.Simplification.Simplifier" /> is used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Workspace,System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the specified language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Host.SolutionServices,System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the specified language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the language corresponding to the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the language corresponding to the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the node if it is a declaration, the immediate enclosing declaration if one exists, or null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationKind)">
            <summary>
            Returns the enclosing declaration of the specified kind or null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FieldDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol)">
            <summary>
            Creates a field declaration matching an existing field symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field declaration matching an existing field symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MethodDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration matching an existing method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.OperatorDeclaration(Microsoft.CodeAnalysis.Editing.OperatorKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.OperatorDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a operator or conversion declaration matching an existing method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ParameterDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            Creates a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ParameterDeclaration(Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a parameter declaration matching an existing parameter symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.PropertyDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a property declaration. The property will have a <c>get</c> accessor if
            <see cref="P:Microsoft.CodeAnalysis.Editing.DeclarationModifiers.IsWriteOnly"/> is <see langword="false"/> and will have
            a <c>set</c> accessor if <see cref="P:Microsoft.CodeAnalysis.Editing.DeclarationModifiers.IsReadOnly"/> is <see
            langword="false"/>.
            </summary>
            <remarks>
            In C# there is a distinction between passing in <see langword="null"/> for <paramref
            name="getAccessorStatements"/> or <paramref name="setAccessorStatements"/> versus
            passing in an empty list. <see langword="null"/> will produce an auto-property-accessor
            (i.e. <c>get;</c>) whereas an empty list will produce an accessor with an empty block
            (i.e. <c>get { }</c>).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.PropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a property declaration using an existing property symbol as a signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IndexerDeclaration(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an indexer declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IndexerDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an indexer declaration matching an existing indexer symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddEventHandler(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that adds the given handler to the given event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveEventHandler(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that removes the given handler from the given event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EventDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)">
            <summary>
            Creates an event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EventDeclaration(Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Creates an event declaration from an existing event symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CustomEventDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a custom event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CustomEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a custom event declaration from an existing event symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConstructorDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a constructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConstructorDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Create a constructor declaration using 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPublicInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Converts method, property and indexer declarations into public interface implementations.
            This is equivalent to an implicit C# interface implementation (you can access it via the interface or directly via the named member.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPublicInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Converts method, property and indexer declarations into public interface implementations.
            This is equivalent to an implicit C# interface implementation (you can access it via the interface or directly via the named member.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPrivateInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Converts method, property and indexer declarations into private interface implementations.
            This is equivalent to a C# explicit interface implementation (you can declare it for access via the interface, but cannot call it directly).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPrivateInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Converts method, property and indexer declarations into private interface implementations.
            This is equivalent to a C# explicit interface implementation (you can declare it for access via the interface, but cannot call it directly).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ClassDeclaration(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a class declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.StructDeclaration(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a struct declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InterfaceDeclaration(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.Accessibility,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a interface declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EnumDeclaration(System.String,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an enum declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EnumDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an enum declaration
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EnumMember(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an enum member
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DelegateDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)">
            <summary>
            Creates a delegate declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Declaration(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Creates a declaration matching an existing symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeParameters(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Converts a declaration (method, class, etc) into a declaration with type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeParameters(Microsoft.CodeAnalysis.SyntaxNode,System.String[])">
            <summary>
            Converts a declaration (method, class, etc) into a declaration with type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeConstraint(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Adds a type constraint to a type parameter of a declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeConstraint(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Adds a type constraint to a type parameter of a declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeConstraint(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Adds a type constraint to a type parameter of a declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CompilationUnit(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a compilation unit declaration
            </summary>
            <param name="declarations">Zero or more namespace import, namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CompilationUnit(Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a compilation unit declaration
            </summary>
            <param name="declarations">Zero or more namespace import, namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceImportDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a namespace import declaration.
            </summary>
            <param name="name">The name of the namespace being imported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceImportDeclaration(System.String)">
            <summary>
            Creates a namespace import declaration.
            </summary>
            <param name="name">The name of the namespace being imported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AliasImportDeclaration(System.String,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol)">
            <summary>
            Creates an alias import declaration.
            </summary>
            <param name="aliasIdentifierName">The name of the alias.</param>
            <param name="symbol">The namespace or type to be aliased.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AliasImportDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an alias import declaration.
            </summary>
            <param name="aliasIdentifierName">The name of the alias.</param>
            <param name="name">The namespace or type to be aliased.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(Microsoft.CodeAnalysis.AttributeData)">
            <summary>
            Creates an attribute matching existing attribute data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AttributeArgument(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an attribute argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AttributeArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an attribute argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveAllAttributes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes all attributes from the declaration, including return attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveAllComments(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes comments from leading and trailing trivia, as well
            as potentially removing comments from opening and closing tokens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAttributes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the attributes of a declaration, not including the return attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of a declaration with the specified attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAttributes(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of a declaration with the specified attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the return attributes from the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of a method declaration with return attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of a method declaration with return attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of a method declaration with return attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of a method declaration node with return attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAttributeArguments(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the attribute arguments for the attribute declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAttributeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the attribute with the arguments inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAttributeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the attribute with the arguments added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the namespace imports that are part of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the namespace imports inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the namespace imports inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the namespace imports added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the namespace imports added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetMembers(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the current members of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertMembers(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the members inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertMembers(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the members inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddMembers(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the members added to the end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddMembers(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the members added to the end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAccessibility(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the accessibility of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithAccessibility(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility)">
            <summary>
            Changes the accessibility of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetModifiers(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.DeclarationModifiers"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithModifiers(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)">
            <summary>
            Changes the <see cref="T:Microsoft.CodeAnalysis.Editing.DeclarationModifiers"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetDeclarationKind(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.DeclarationKind"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the name of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithName(Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Changes the name of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetType(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the type of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Changes the type of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetParameters(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of parameters for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertParameters(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the parameters at the specified index into the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddParameters(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Adds the parameters to the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetSwitchSections(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of switch sections for the statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertSwitchSections(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the switch sections at the specified index into the statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddSwitchSections(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Adds the switch sections to the statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the expression associated with the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Changes the expression associated with the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statements for the body of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Changes the statements for the body of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAccessors(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the accessors for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAccessor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationKind)">
            <summary>
            Gets the accessor of the specified kind for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAccessors(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the accessors inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAccessors(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the accessors added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statements for the body of the get-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithGetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Changes the statements for the body of the get-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetSetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statements for the body of the set-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithSetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Changes the statements for the body of the set-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetBaseAndInterfaceTypes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of the base and interface types for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddBaseType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Adds a base type to the declaration
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddInterfaceType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Adds an interface type to the declaration
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReplaceNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Replaces the node in the root's tree with the new node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNodesBefore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the new node before the specified declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNodesAfter(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the new node before the specified declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes the node from the sub tree starting at the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Removes the node from the sub tree starting at the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveNodes(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Removes all the declarations from the sub tree starting at the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ClearTrivia``1(``0)">
            <summary>
            Creates a new instance of the node with the leading and trailing trivia removed and replaced with elastic markers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ExpressionStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates statement that allows an expression to execute in a statement context.
            This is typically an invocation or assignment expression.
            </summary>
            <param name="expression">The expression that is to be executed. This is usually a method invocation expression.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReturnStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to return a value from a method body.
            </summary>
            <param name="expression">An optional expression that can be returned.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.YieldReturnStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to yield a value from an iterator method.
            </summary>
            <param name="expression">An expression that can be yielded.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThrowStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to throw an exception.
            </summary>
            <param name="expression">An optional expression that can be thrown.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThrowExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that can be used to throw an exception.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SupportsThrowExpression">
            <summary>
            True if <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThrowExpression(Microsoft.CodeAnalysis.SyntaxNode)"/> can be used
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RequiresLocalDeclarationType">
            <summary>
            <see langword="true"/> if the language requires a <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.ITypeSymbol)"/>
            (including <see langword="var"/>) to be stated when making a 
            <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.ITypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)"/>.
            <see langword="false"/> if the language allows the type node to be entirely elided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.ITypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IfStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an if-statement
            </summary>
            <param name="condition">A condition expression.</param>
            <param name="trueStatements">The statements that are executed if the condition is true.</param>
            <param name="falseStatements">The statements that are executed if the condition is false.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IfStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an if statement
            </summary>
            <param name="condition">A condition expression.</param>
            <param name="trueStatements">The statements that are executed if the condition is true.</param>
            <param name="falseStatement">A single statement that is executed if the condition is false.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a switch statement that branches to individual sections based on the value of the specified expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a switch statement that branches to individual sections based on the value of the specified expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchSection(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a section for a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchSection(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a single-case section a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DefaultSwitchSection(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a default section for a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ExitSwitchStatement">
            <summary>
            Create a statement that exits a switch statement and continues after it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.UsingStatement(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a using-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.UsingStatement(System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a using-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.UsingStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a using-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LockStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a lock-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCatchStatement(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a try-catch or try-catch-finally statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCatchStatement(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a try-catch or try-catch-finally statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryFinallyStatement(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a try-finally statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CatchClause(Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a catch-clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CatchClause(Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a catch-clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WhileStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a while-loop statement
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ScopeBlock(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a block of statements. Not supported in VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DefaultExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            An expression that represents the default value of a type.
            This is typically a null value for reference types or a zero-filled value for value types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThisExpression">
            <summary>
            Creates an expression that denotes the containing method's this-parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BaseExpression">
            <summary>
            Creates an expression that denotes the containing method's base-parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LiteralExpression(System.Object)">
            <summary>
            Creates a literal expression. This is typically numeric primitives, strings or chars.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LiteralExpression(System.Object,System.Boolean)">
            <summary>
            Creates a literal expression. This is typically numeric primitives, strings or chars.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypedConstantExpression(Microsoft.CodeAnalysis.TypedConstant)">
            <summary>
            Creates an expression for a typed constant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FalseLiteralExpression">
            <summary>
            Creates an expression that denotes the boolean false literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TrueLiteralExpression">
            <summary>
            Creates an expression that denotes the boolean true literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NullLiteralExpression">
            <summary>
            Creates an expression that denotes the null literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IdentifierName(System.String)">
            <summary>
            Creates an expression that denotes a simple identifier name.
            </summary>
            <param name="identifier"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ITypeSymbol})">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Converts an expression that ends in a name into an expression that ends in a generic name.
            If the expression already ends in a generic name, the new type arguments are used instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeArguments(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Converts an expression that ends in a name into an expression that ends in a generic name.
            If the expression already ends in a generic name, the new type arguments are used instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.QualifiedName(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a name expression that denotes a qualified name. 
            The left operand can be any name expression.
            The right operand can be either and identifier or generic name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GlobalAliasedName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns a new name node qualified with the 'global' alias ('Global' in VB).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DottedName(System.String)">
            <summary>
            Creates a name expression from a dotted name string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NameExpression(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol)">
            <summary>
            Creates a name that denotes a type or namespace.
            </summary>
            <param name="namespaceOrTypeSymbol">The symbol to create a name for.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an expression that denotes a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Creates an expression that denotes a type. If addImport is false,
            adds a <see cref="T:Microsoft.CodeAnalysis.Simplification.DoNotAddImportsAnnotation"/> which will prevent any
            imports or usings from being added for the type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Creates an expression that denotes a special type name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ArrayTypeExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an array type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NullableTypeExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a nullable type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleTypeExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that denotes a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleTypeExpression(Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that denotes a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleTypeExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an expression that denotes a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleElementExpression(Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Creates an expression that denotes a tuple element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleElementExpression(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Creates an expression that denotes a tuple element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AssignmentStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an assignment from the right argument to left argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a value-type equality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReferenceEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a reference-type equality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueNotEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a value-type inequality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReferenceNotEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a reference-type inequality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LessThanExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a less-than test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LessThanOrEqualExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a less-than-or-equal test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GreaterThanExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a greater-than test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a greater-than-or-equal test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NegateExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a unary negation operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an addition operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SubtractExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an subtraction operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MultiplyExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a multiplication operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DivideExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a division operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ModuloExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a modulo operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BitwiseAndExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a bitwise-and operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BitwiseOrExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a bitwise-or operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BitwiseNotExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a bitwise-not operation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LogicalAndExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a logical-and operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LogicalOrExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a logical-or operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LogicalNotExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a logical not operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConditionalExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a conditional evaluation operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConditionalAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a conditional access operation. Use <see
            cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberBindingExpression(Microsoft.CodeAnalysis.SyntaxNode)"/> and <see
            cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementBindingExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})"/> to generate the <paramref
            name="whenNotNull"/> argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberBindingExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a member binding operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementBindingExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that denotes an element binding operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementBindingExpression(Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that denotes an element binding operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CoalesceExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a coalesce operation. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a member access expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Creates a member access expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an array creation expression for a single dimensional array of specified size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an array creation expression for a single dimensional array with specified initial element values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.ITypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InvocationExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a invocation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InvocationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a invocation expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Argument(System.String,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a node that is an argument to an invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Argument(Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a node that is an argument to an invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Argument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a node that is an argument to an invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that access an element of an array or indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that access an element of an array or indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeOfExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that evaluates to the type at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IsTypeExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an is-type-check operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IsTypeExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an expression that denotes an is-type-check operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCastExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an try-cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCastExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an expression that denotes an try-cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CastExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CastExpression(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConvertExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type conversion operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConvertExpression(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type conversion operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a void returning lambda expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a single parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a single parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a single parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a single parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a zero parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a zero parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a zero parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a zero parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LambdaParameter(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a lambda parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LambdaParameter(System.String,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates a lambda parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AwaitExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an await expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddParentheses(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Wraps with parens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NameOfExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an nameof expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an tuple expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ParseExpression(System.String)">
            <summary>
            Parses an expression from string
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind.ReferenceType">
            <summary>
            Has the reference type constraint (i.e. 'class' constraint in C#)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind.ValueType">
            <summary>
            Has the value type constraint (i.e. 'struct' constraint in C#)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind.Constructor">
            <summary>
            Has the constructor constraint (i.e. 'new' constraint in C#)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.GenerationOptions.EditorConfigOptions">
            <summary>
            Options that we expect the user to set in editorconfig.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdderService.AddPotentiallyConflictingImportsAsync(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamespaceSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.INamespaceSymbol},System.Threading.CancellationToken)">
            <summary>
            Looks at the contents of the document for top level identifiers (or existing extension method calls), and
            blocks off imports that could potentially bring in a name that would conflict with them.
            <paramref name="container"/> is the node that the import will be added to.  This will either be the
            compilation-unit node, or one of the namespace-blocks in the file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdderService.IsInsideNamespace(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Checks if the namespace declaration <paramref name="node"/> is contained inside,
            or any of its ancestor namespaces are the same as <paramref name="symbol"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal">
            <summary>
            Internal extensions to <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/>.
            
            This interface is available in the shared CodeStyle and Workspaces layer to allow
            sharing internal generator methods between them. Once the methods are ready to be
            made public APIs, they can be moved to <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Creates a statement that declares a single local variable with an optional initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.AddParentheses(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Wraps with parens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.YieldReturnStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to yield a value from an iterator method.
            </summary>
            <param name="expression">An expression that can be yielded.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.RequiresLocalDeclarationType">
            <summary>
            <see langword="true"/> if the language requires a "TypeExpression"
            (including <see langword="var"/>) to be stated when making a 
            <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)"/>.
            <see langword="false"/> if the language allows the type node to be entirely elided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal.Type(Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Produces an appropriate TypeSyntax for the given <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/>.  The <paramref name="typeContext"/>
            flag controls how this should be created depending on if this node is intended for use in a type-only
            context, or an expression-level context.  In the former case, both C# and VB will create QualifiedNameSyntax
            nodes for dotted type names, whereas in the latter case both languages will create MemberAccessExpressionSyntax
            nodes.  The final stringified result will be the same in both cases.  However, the structure of the trees
            will be substantively different, which can impact how the compilation layers analyze the tree and how
            transformational passes affect it.
            </summary>
            <remarks>
            Passing in the right value for <paramref name="typeContext"/> is necessary for correctness and for use
            of compilation (and other) layers in a supported fashion.  For example, if a QualifiedTypeSyntax is
            sed in a place the compiler would have parsed out a MemberAccessExpression, then it is undefined behavior
            what will happen if that tree is passed to any other components.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorReporting.IErrorReportingService.HostDisplayName">
            <summary>
            Name of the host to be used in error messages (e.g. "Visual Studio").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.IErrorReportingService.ShowGlobalErrorInfo(System.String,Microsoft.CodeAnalysis.Telemetry.TelemetryFeatureName,System.Exception,Microsoft.CodeAnalysis.ErrorReporting.InfoBarUI[])">
             <summary>
             Show global error info.
            
             this kind error info should be something that affects whole roslyn such as
             background compilation is disabled due to memory issue and etc
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorReporting.OperationCanceledIgnoringCallerTokenException">
            <summary>
            Thrown when async code must cancel the current execution but does not have access to the <see cref="T:System.Threading.CancellationTokenSource"/> of the <see cref="T:System.Threading.CancellationToken"/> passed to the code.
            Should be used in very rare cases where the <see cref="T:System.Threading.CancellationTokenSource"/> is out of our control (e.g. owned but not exposed by JSON RPC in certain call-back scenarios).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.SetHandlers(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler,Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)">
            <summary>
            Set by the host to handle an error report; this may crash the process or report telemetry.
            </summary>
            <param name="nonFatalHandler">A handler that will not crash the process when called.  Used when calling <see
            cref="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportNonFatalError(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity,System.Boolean)"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.OverwriteHandler(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)">
            <summary>
            Same as setting the Handler property except that it avoids the assert.  This is useful in
            test code which needs to verify the handler is called in specific cases and will continually
            overwrite this value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.CopyHandlersTo(System.Reflection.Assembly)">
            <summary>
            Copies the handler in this instance to the linked copy of this type in this other assembly.
            </summary>
            <remarks>
            This file is in linked into multiple layers, but we want to ensure that all layers have the same copy.
            This lets us copy the handler in this instance into the same in another instance.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagate(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error without catching the exception.
            The error is reported by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>.
            </summary>
            <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>), unless the
            operation has been cancelled. The exception is never caught.
            </summary>
            <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndPropagateUnlessCanceled(System.Exception,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
             <summary>
             <para>Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>), unless the
             operation has been cancelled at the request of <paramref name="contextCancellationToken"/>. The exception is
             never caught.</para>
            
             <para>Cancellable operations are only expected to throw <see cref="T:System.OperationCanceledException"/> if the
             applicable <paramref name="contextCancellationToken"/> indicates cancellation is requested by setting
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>. Unexpected cancellation, i.e. an
             <see cref="T:System.OperationCanceledException"/> which occurs without <paramref name="contextCancellationToken"/>
             requesting cancellation, is treated as an error by this method.</para>
            
             <para>This method does not require <see cref="P:System.OperationCanceledException.CancellationToken"/> to match
             <paramref name="contextCancellationToken"/>, provided cancellation is expected per the previous
             paragraph.</para>
             </summary>
             <param name="contextCancellationToken">A <see cref="T:System.Threading.CancellationToken"/> which will have
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> set if cancellation is expected.</param>
             <returns><see langword="false"/> to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatch(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Report an error.
            Calls <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/> and doesn't pass the exception through (the method returns true).
            This is generally expected to be used within an exception filter as that allows us to
            capture data at the point the exception is thrown rather than when it is handled.
            However, it can also be used outside of an exception filter. If the exception has not
            already been thrown the method will throw and catch it itself to ensure we get a useful
            stack trace.
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatchUnlessCanceled(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
            <summary>
            Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>) and catch
            the exception, unless the operation was cancelled.
            </summary>
            <returns><see langword="true"/> to catch the exception if the error was reported; otherwise,
            <see langword="false"/> to propagate the exception if the operation was cancelled.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportAndCatchUnlessCanceled(System.Exception,System.Threading.CancellationToken,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity)">
             <summary>
             <para>Use in an exception filter to report an error (by calling <see cref="F:Microsoft.CodeAnalysis.ErrorReporting.FatalError.s_handler"/>) and
             catch the exception, unless the operation was cancelled at the request of
             <paramref name="contextCancellationToken"/>.</para>
            
             <para>Cancellable operations are only expected to throw <see cref="T:System.OperationCanceledException"/> if the
             applicable <paramref name="contextCancellationToken"/> indicates cancellation is requested by setting
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>. Unexpected cancellation, i.e. an
             <see cref="T:System.OperationCanceledException"/> which occurs without <paramref name="contextCancellationToken"/>
             requesting cancellation, is treated as an error by this method.</para>
            
             <para>This method does not require <see cref="P:System.OperationCanceledException.CancellationToken"/> to match
             <paramref name="contextCancellationToken"/>, provided cancellation is expected per the previous
             paragraph.</para>
             </summary>
             <param name="contextCancellationToken">A <see cref="T:System.Threading.CancellationToken"/> which will have
             <see cref="P:System.Threading.CancellationToken.IsCancellationRequested"/> set if cancellation is expected.</param>
             <returns><see langword="true"/> to catch the exception if the error was reported; otherwise,
             <see langword="false"/> to propagate the exception if the operation was cancelled.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportNonFatalError(System.Exception,Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity,System.Boolean)">
            <summary>
            Used to report a non-fatal-watson (when possible) to report an exception.  The exception is not caught. Does
            nothing if no non-fatal error handler is registered.  See the second argument to <see
            cref="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.SetHandlers(Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler,Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity">
            <summary>
            The severity of the error, see the enum members for a description of when to use each. This is metadata that's included
            in a non-fatal fault report, which we can take advantage of on the backend to automatically triage bugs. For example,
            a critical severity issue we can open with a lower bug count compared to a low priority one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Uncategorized">
            <summary>
            The severity hasn't been categorized. Don't use this in new code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Diagnostic">
            <summary>
            Something failed, but the user is unlikely to notice. Especially useful for background things that we can silently recover
            from, like bugs in caching systems.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.General">
            <summary>
            Something failed, and the user might notice, but they're still likely able to carry on. For example, if the user
            asked for some information from the IDE (find references, completion, etc.) and we were able to give partial results.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity.Critical">
            <summary>
            Something failed, and the user likely noticed. For example, the user pressed a button to do an action, and
            we threw an exception so we completely failed to do that in an unrecoverable way. This may also be used
            for back-end systems where a failure is going to result in a highly broken experience, for example if parsing a file
            catastrophically failed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IExtensionManager.HandleException(System.Object,System.Exception)">
            <summary>
            Returns <see langword="true"/> to make it easy to use in an exception filter.  Note: will be called with any
            exception, so this should not do anything in the case of <see cref="T:System.OperationCanceledException"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodGenerationOptions">
            <summary>
            All options needed to perform method extraction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder">
            <summary>
            Provides helper methods for finding dependent projects across a solution that a given symbol can be referenced within.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.s_metadataIdToAssemblyName">
            <summary>
            Cache from the <see cref="T:Microsoft.CodeAnalysis.MetadataId"/> for a particular <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> to the
            name of the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> defined by it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.GetDependentProjectsWorkerAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Threading.CancellationToken)">
            <summary>
            This method computes the dependent projects that need to be searched for references of the given <paramref
            name="symbols"/>.
            <para/>
            This computation depends on the given symbol's visibility:
            <list type="number">
            <item>Public: Dependent projects include the symbol definition project and all the referencing
            projects.</item>
            <item>Internal: Dependent projects include the symbol definition project and all the referencing projects
            that have internals access to the definition project..</item>
            <item>Private: Dependent projects include the symbol definition project and all the referencing submission
            projects (which are special and can reference private fields of the previous submission).</item>
            </list>
            We perform this computation in two stages:
            <list type="number">
            <item>Compute all the dependent projects (submission + non-submission) and their InternalsVisibleTo semantics to the definition project.</item>
            <item>Filter the above computed dependent projects based on symbol visibility.</item>
            Dependent projects computed in stage (1) are cached to avoid recomputation.
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.GetSymbolOriginations(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Threading.CancellationToken)">
            <summary>
            Returns information about where <paramref name="symbols"/> originate from.  It's <see
            cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> for both source and metadata symbols, and an optional <see cref="T:Microsoft.CodeAnalysis.Project"/> if this
            was a symbol from source. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder">
            <summary>
            Provides helper methods for finding dependent types (derivations, implementations, etc.) across a solution. This
            is effectively a graph walk between INamedTypeSymbols walking down the inheritance hierarchy to find related
            types based either on <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.BaseType"/> or <see cref="P:Microsoft.CodeAnalysis.ITypeSymbol.Interfaces"/>.
            </summary>
            <remarks>
            While walking up the inheritance hierarchy is trivial (as the information is directly contained on the <see
            cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/>'s themselves), walking down is complicated.  The general way this works is by using
            out-of-band indices that are built that store this type information in a weak manner.  Specifically, for both
            source and metadata types we have indices that map between the base type name and the inherited type name. i.e.
            for the case <c>class A { } class B : A { }</c> the index stores a link saying "There is a type 'A' somewhere
            which has derived type called 'B' somewhere".  So when the index is examined for the name 'A', it will say
            'examine types called 'B' to see if they're an actual match'.
            <para/>
            These links are then continually traversed to get the full set of results.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.DescendInheritanceTreeAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Func{Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.INamedTypeSymbol},System.Boolean},System.Func{Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Walks down a <paramref name="type"/>'s inheritance tree looking for more <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>'s
            that match the provided <paramref name="typeMatches"/> predicate.
            </summary>
            <param name="shouldContinueSearching">Called when a new match is found to check if that type's inheritance
            tree should also be walked down.  Can be used to stop the search early if a type could have no types that
            inherit from it that would match this search.</param>
            <param name="transitive">If this search after finding the direct inherited types that match the provided
            predicate, or if the search should continue recursively using those types as the starting point.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.PropagateTemporaryResults(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.INamedTypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.INamedTypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.INamedTypeSymbol},System.Boolean,System.Func{Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean})">
            <summary>
            Moves all the types in <paramref name="tempBuffer"/> to <paramref name="result"/>.  If these are types we
            haven't seen before, and the caller says we <paramref name="shouldContinueSearching"/> on them, then add
            them to <paramref name="typesToSearchFor"/> for the next round of searching.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.FindDocumentsAsync``1(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Action{Microsoft.CodeAnalysis.Document,``0},``0,System.Threading.CancellationToken,System.String[])">
            <summary>
            Finds all the documents in the provided project that contain the requested string
            values
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.FindDocumentsWithGlobalSuppressMessageAttributeAsync``1(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Action{Microsoft.CodeAnalysis.Document,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Finds all the documents in the provided project that contain a global attribute in them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.CollectMatchingReferences`1">
            <summary>
            If the `node` implicitly matches the `symbol`, then it will be added to `locations`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.FindReferencesInDocumentInsideGlobalSuppressions``1(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState,System.Action{Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Find references to a symbol inside global suppressions.
            For example, consider a field 'Field' defined inside a type 'C'.
            This field's documentation comment ID is 'F:C.Field'
            A reference to this field inside a global suppression would be as following:
                [assembly: SuppressMessage("RuleCategory", "RuleId', Scope = "member", Target = "~F:C.Field")]
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.ValidateAndSplitDocumentationCommentId(System.String,System.ReadOnlyMemory{System.Char}@,System.ReadOnlyMemory{System.Char}@)">
            <summary>
            Validate and split a documentation comment ID into a prefix and complete symbol ID. For the
            <paramref name="docCommentId"/> <c>~M:C.X(System.String)</c>, the <paramref name="prefix"/> would be
            <c>~M:</c> and <paramref name="id"/> would be <c>C.X(System.String)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.SplitIdAndArguments(System.ReadOnlyMemory{System.Char},System.ReadOnlyMemory{System.Char}@,System.ReadOnlyMemory{System.Char}@)">
            <summary>
            Split a full documentation symbol ID into the core symbol ID and optional parameter list. For the
            <paramref name="id"/> <c>C.X(System.String)</c>, the <paramref name="idPartBeforeArguments"/> would be
            <c>C.X</c> and <paramref name="arguments"/> would be <c>(System.String)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.ValidateAndSplitDocumentationCommentId(System.String,System.ReadOnlyMemory{System.Char}@,System.ReadOnlyMemory{System.Char}@,System.ReadOnlyMemory{System.Char}@)">
             <summary>
             Validate and split symbol documentation comment ID.
             For example, "~M:C.X(System.String)" represents the documentation comment ID of a method named 'X'
             that takes a single string-typed parameter and is contained in a type named 'C'.
            
             We divide the ID into 3 groups:
             1. Prefix:
                 - Starts with an optional '~'
                 - Followed by a single capital letter indicating the symbol kind (for example, 'M' indicates method symbol)
                 - Followed by ':'
             2. Core symbol ID, which is its fully qualified name before the optional parameter list and return type (i.e. before the '(' or '[' tokens)
             3. Optional parameter list and/or return type that begins with a '(' or '[' tokens.
            
             For the above example, "~M:" is the prefix, "C.X" is the core symbol ID and "(System.String)" is the parameter list.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder.AddReferencesInDocumentWorker``1(Microsoft.CodeAnalysis.IMethodSymbol,System.String,Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState,System.Action{Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Finds references to <paramref name="symbol"/> in this <paramref name="state"/>, but only if it referenced
            though <paramref name="name"/> (which might be the actual name of the type, or a global alias to it).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Node">
            <summary>
            The actual node that we found the reference on.  Normally the 'Name' portion
            of any piece of syntax.  Might also be something like a 'foreach' statement node
            when finding results for something like GetEnumerator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Location">
            <summary>
            The location we want want to return through the FindRefs API.  The location contains
            additional information (like if this was a Write, or if it was Implicit).  This value
            also has a <see cref="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Location"/> property.  Importantly, this value
            is not necessarily the same location you would get by calling <see cref="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Node"/>.<see
            cref="M:Microsoft.CodeAnalysis.SyntaxNode.GetLocation"/>.  Instead, this location is where we want to navigate
            the user to.  A case where this can be different is with an indexer reference.  The <see
            cref="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Node"/> will be the node for the full 'ElementAccessExpression', whereas the 
            location we will take the user to will be the zero-length position immediately preceding
            the `[` character.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.ILanguageServiceReferenceFinder">
            <summary>
            Extensibility interface to allow individual languages to extend the 'Find References' service. 
            Languages can use this to provide specialized cascading logic between symbols that 'Find 
            References' is searching for.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder">
            <summary>
            Extensibility interface to allow extending the IFindReferencesService service.  Implementations
            must be thread-safe as the methods on this interface may be called on multiple threads
            simultaneously.  Implementations should also respect the provided cancellation token and
            should try to cancel themselves quickly when requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineGlobalAliasesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Determines what, if any, global alias names could potentially map this symbol in this project.
            Note that this result is allowed to return global aliases that don't actually map to this symbol.
            For example, given symbol <c>A.X</c> and <c>global alias G = B.X</c>, <c>G</c> might be returned
            in a search for <c>A.X</c> because they both end in <c>X</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineCascadedSymbolsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine when a new symbol definition is found.
            Implementations can then choose to request more symbols be searched for.  For example, an
            implementation could choose for the find references search engine to cascade to
            constructors when searching for standard types.
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineDocumentsToSearchAsync``1(Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.HashSet{System.String},Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Action{Microsoft.CodeAnalysis.Document,``0},``0,Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine which documents in the supplied
            project need to be searched for references.  Only projects returned by
            DetermineProjectsToSearch will be passed to this method.
            
            Implementations should endeavor to keep the list of returned documents as small as
            possible to keep search time down to a minimum.  Returning the entire list of documents
            in a project is not recommended (unless, of course, there is reasonable reason to
            believe there are references in every document).
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.FindReferencesInDocument``1(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState,System.Action{Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation,``0},``0,Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine the set of reference locations
            in the provided document.  Only documents returned by DetermineDocumentsToSearch will be
            passed to this method. 
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder.AddDocumentsToSearchAsync``1(System.String,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Action{Microsoft.CodeAnalysis.Document,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Looks for documents likely containing <paramref name="throughName"/> in them.  That name will either be the actual
            name of the named type we're looking for, or it might be a global alias to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder.AddNonAliasReferences``1(Microsoft.CodeAnalysis.INamedTypeSymbol,System.String,Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState,System.Action{Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Finds references to <paramref name="symbol"/> in this <paramref name="state"/>, but
            only if it referenced though <paramref name="name"/> (which might be the actual name
            of the type, or a global alias to it).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder.AddNamedReferences``1(Microsoft.CodeAnalysis.INamespaceSymbol,System.String,Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState,System.Action{Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation,``0},``0,System.Threading.CancellationToken)">
            <summary>
            Finds references to <paramref name="symbol"/> in this <paramref name="state"/>, but only if it referenced
            though <paramref name="name"/> (which might be the actual name of the type, or a global alias to it).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.ReferenceFinders.DefaultReferenceFinders">
            <summary>
            The list of common reference finders.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache">
            <summary>
            Caches information find-references needs associated with each document.  Computed and cached so that multiple calls
            to find-references in a row can share the same data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache._nullableEnabledSemanticModel">
            <summary>
            Not used by FAR directly.  But we compute and cache this while processing a document so that if we call any
            other services that use this semantic model, that they don't end up recreating it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState">
            <summary>
            Ephemeral information that find-references needs for a particular document when searching for a <em>specific</em>
            symbol.  Importantly, it contains the global aliases to that symbol within the current project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState.#ctor(Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Ephemeral information that find-references needs for a particular document when searching for a <em>specific</em>
            symbol.  Importantly, it contains the global aliases to that symbol within the current project.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.NoOpFindReferencesProgress">
            <summary>
            A does-nothing version of the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress"/>. Useful for
            clients that have no need to report progress as they work.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.BidirectionalSymbolSet">
            <summary>
            Symbol set used when <see cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.UnidirectionalHierarchyCascade"/> is <see
            langword="false"/>.  This symbol set will cascade up *and* down the inheritance hierarchy for all symbols we
            are searching for.  This is the symbol set used for features like 'Rename', where all cascaded symbols must
            be updated in order to keep the code compiling.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.BidirectionalSymbolSet._allSymbols">
            <summary>
            When we're cascading in both direction, we can just keep all symbols in a single set.  We'll always be
            examining all of them to go in both up and down directions in every project we process.  Any time we
            add a new symbol to it we'll continue to cascade in both directions looking for more.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.s_exclusiveScheduler">
            <summary>
            Scheduler we use when we're doing operations in the BG and we want to rate limit them to not saturate the threadpool.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.GetParallelOptions(System.Threading.CancellationToken)">
            <summary>
            Options to control the parallelism of the search.   If we're in <see
            cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.Explicit"/> mode, we'll run all our tasks concurrently.  Otherwise, we will
            run them serially using <see cref="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.s_exclusiveScheduler"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.ReportGroupsSeriallyAsync(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.SymbolGroup},System.Threading.CancellationToken)">
            <summary>
            Notify the caller of the engine about the definitions we've found that we're looking for.  We'll only notify
            them once per symbol group, but we may have to notify about new symbols each time we expand our symbol set
            when we walk into a new project.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.NonCascadingSymbolSet">
            <summary>
            A symbol set used when the find refs caller does not want cascading.  This is a trivial impl that basically
            just wraps the initial symbol provided and doesn't need to do anything beyond that.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.NonCascadingSymbolSet.#ctor(Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine,Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet)">
            <summary>
            A symbol set used when the find refs caller does not want cascading.  This is a trivial impl that basically
            just wraps the initial symbol provided and doesn't need to do anything beyond that.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet">
            <summary>
            Represents the set of symbols that the engine is searching for.  While the find-refs engine is passed an
            initial symbol to find results for, the engine will often have to 'cascade' that symbol to many more symbols
            that clients will also need.  This includes:
            <list type="number">
            <item>Cascading to all linked symbols for the requested symbol.  This ensures a unified set of results for a
            particular symbol, regardless of what project context it was originally found in.</item>
            <item>Symbol specific cascading.  For example, when searching for a named type, references to that named
            type will be found through its constructors.</item>
            <item>Cascading up and down the inheritance hierarchy for members (e.g. methods, properties, events). This
            is controllable through the <see cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.UnidirectionalHierarchyCascade"/>
            option.</item>
            </list>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.GetAllSymbols">
            <summary>
            Get a copy of all the symbols in the set.  Cannot be called concurrently with <see
            cref="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.InheritanceCascadeAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.InheritanceCascadeAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Update the set of symbols in this set with any appropriate symbols in the inheritance hierarchy brought
            in within <paramref name="project"/>.  For example, given a project 'A' with interface <c>interface IGoo
            { void Goo(); }</c>, and a project 'B' with class <c>class Goo : IGoo { public void Goo() { } }</c>,
            then initially the symbol set will only contain IGoo.Goo.  However, when project 'B' is processed, this
            will add Goo.Goo is added to the set as well so that references to it can be found.
            </summary>
            <remarks>
            This method is non thread-safe as it mutates the symbol set instance.  As such, it should only be called
            serially.  <see cref="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.GetAllSymbols"/> should not be called concurrently with this.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.DetermineInitialSearchSymbolsAsync(Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine,Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet,System.Threading.CancellationToken)">
            <summary>
            Determines the initial set of symbols that we should actually be finding references for given a request
            to find refs to <paramref name="symbols"/>.  This will include any symbols that a specific <see
            cref="T:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder"/> cascades to, as well as all the linked symbols to those across any
            multi-targeting/shared-project documents.  This will not include symbols up or down the inheritance
            hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.AddDownSymbolsAsync(Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ISymbol},System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds all the symbols 'down' the inheritance hierarchy of <paramref name="symbol"/> in the given
            project.  The symbols found are added to <paramref name="seenSymbols"/>.  If <paramref name="seenSymbols"/> did not
            contain that symbol, then it is also added to <paramref name="workQueue"/> to allow fixed point
            algorithms to continue.
            </summary>
            <remarks><paramref name="projects"/> will always be a single project.  We just pass this in as a set to
            avoid allocating a fresh set every time this calls into FindMemberImplementationsArrayAsync.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.SymbolSet.AddUpSymbolsAsync(Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ISymbol},System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Project},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Finds all the symbols 'up' the inheritance hierarchy of <paramref name="symbol"/> in the solution.  The
            symbols found are added to <paramref name="seenSymbols"/>.  If <paramref name="seenSymbols"/> did not contain that symbol,
            then it is also added to <paramref name="workQueue"/> to allow fixed point algorithms to continue.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.UnidirectionalSymbolSet">
            <summary>
            Symbol set used when <see cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.UnidirectionalHierarchyCascade"/> is <see
            langword="true"/>.  This symbol set will only cascade in a uniform direction once it walks either up or down
            from the initial set of symbols. This is the symbol set used for features like 'Find Refs', where we only
            want to return location results for members that could feasible actually end up calling into that member at
            runtime.  See the docs of <see cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.UnidirectionalHierarchyCascade"/> for more
            information on this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.UnidirectionalSymbolSet.#ctor(Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine,Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet,Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet)">
            <summary>
            Symbol set used when <see cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.UnidirectionalHierarchyCascade"/> is <see
            langword="true"/>.  This symbol set will only cascade in a uniform direction once it walks either up or down
            from the initial set of symbols. This is the symbol set used for features like 'Find Refs', where we only
            want to return location results for members that could feasible actually end up calling into that member at
            runtime.  See the docs of <see cref="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.UnidirectionalHierarchyCascade"/> for more
            information on this.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine.UnidirectionalSymbolSet._upSymbols">
            <summary>
            When we're doing a unidirectional find-references, the initial set of up-symbols can never change.
            That's because we have computed the up set entirely up front, and no down symbols can produce new
            up-symbols (as going down then up would not be unidirectional).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions">
             <summary>
             <param name="AssociatePropertyReferencesWithSpecificAccessor">
             When searching for property, associate specific references we find to the relevant
             accessor symbol (if there is one).  For example, in C#, this would result in:
             
                 P = 0;     // A reference to the P.set accessor
                 var v = P; // A reference to the P.get accessor
                 P++;       // A reference to P.get and P.set accessors
                 nameof(P); // A reference only to P.  Not associated with a particular accessor.
                 
             The default for this is false.  With that default, all of the above references
             are associated with the property P and not the accessors.
             </param>
             <param name="Cascade">
             Whether or not we should cascade from the original search symbol to new symbols as we're
             doing the find-references search.
             </param>
             <param name="Explicit">
             Whether or not this find ref operation was explicitly invoked or not.  If explicit invoked, the find
             references operation may use more resources to get the results faster.
             
             Features that run automatically should consider setting this to <see langword="false"/> to avoid
             unnecessarily impacting the user while they are doing other work.
             </param>
             <param name="UnidirectionalHierarchyCascade">
             When cascading if we should only travel in a consistent direction away from the starting symbol.  For
             example, starting on a virtual method, this would cascade upwards to implemented interface methods, and
             downwards to overridden methods.  However, it would not then travel back down to other implementations of
             those interface methods.  This is useful for cases where the client only wants references that could lead to
             this symbol actually being called into at runtime.
             
             There are cases where a client will not want this behavior.  An example of that is 'Rename'.  In rename,
             there is a implicit link between members in a hierarchy with the same name (and appropriate signature).  For example, in:
            
             <code>
             interface I { void Goo(); }
             class C1 : I { public void Goo() { } }
             class C2 : I { public void Goo() { } }
             </code>
             
             If <c>C1.Goo</c> is renamed, this will need to rename <c>C2.Goo</c> as well to keep the code properly
             compiling.  So, by default 'Rename' will cascade to all of these so it can appropriately update them.  This
             option is the more relevant with knowing if a particular reference would actually result in a call to the
             original member, not if it has a relation to the original member.
             </param>
             <param name="DisplayAllDefinitions">
             Displays all definitions regardless of whether they have a reference or not.
             </param>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
             <summary>
             <param name="AssociatePropertyReferencesWithSpecificAccessor">
             When searching for property, associate specific references we find to the relevant
             accessor symbol (if there is one).  For example, in C#, this would result in:
             
                 P = 0;     // A reference to the P.set accessor
                 var v = P; // A reference to the P.get accessor
                 P++;       // A reference to P.get and P.set accessors
                 nameof(P); // A reference only to P.  Not associated with a particular accessor.
                 
             The default for this is false.  With that default, all of the above references
             are associated with the property P and not the accessors.
             </param>
             <param name="Cascade">
             Whether or not we should cascade from the original search symbol to new symbols as we're
             doing the find-references search.
             </param>
             <param name="Explicit">
             Whether or not this find ref operation was explicitly invoked or not.  If explicit invoked, the find
             references operation may use more resources to get the results faster.
             
             Features that run automatically should consider setting this to <see langword="false"/> to avoid
             unnecessarily impacting the user while they are doing other work.
             </param>
             <param name="UnidirectionalHierarchyCascade">
             When cascading if we should only travel in a consistent direction away from the starting symbol.  For
             example, starting on a virtual method, this would cascade upwards to implemented interface methods, and
             downwards to overridden methods.  However, it would not then travel back down to other implementations of
             those interface methods.  This is useful for cases where the client only wants references that could lead to
             this symbol actually being called into at runtime.
             
             There are cases where a client will not want this behavior.  An example of that is 'Rename'.  In rename,
             there is a implicit link between members in a hierarchy with the same name (and appropriate signature).  For example, in:
            
             <code>
             interface I { void Goo(); }
             class C1 : I { public void Goo() { } }
             class C2 : I { public void Goo() { } }
             </code>
             
             If <c>C1.Goo</c> is renamed, this will need to rename <c>C2.Goo</c> as well to keep the code properly
             compiling.  So, by default 'Rename' will cascade to all of these so it can appropriately update them.  This
             option is the more relevant with knowing if a particular reference would actually result in a call to the
             original member, not if it has a relation to the original member.
             </param>
             <param name="DisplayAllDefinitions">
             Displays all definitions regardless of whether they have a reference or not.
             </param>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.GetFeatureOptionsForStartingSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the appropriate options for a given symbol for the specific 'Find References' feature.  This should
            not be used for other features (like 'Rename').  For the 'Find References' feature, if the user starts
            searching on an accessor, then we want to give results associated with the specific accessor.  Otherwise, if
            they search on a property, then associate everything with the property.  We also only want to travel an
            inheritance hierarchy unidirectionally so that we only see potential references that could actually reach
            this particular member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.NoOpStreamingFindReferencesProgress">
            <summary>
            A does-nothing version of the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress"/>. Useful for
            clients that have no need to report progress as they work.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.StreamingFindReferencesProgressAdapter">
            <summary>
            Wraps an <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress"/> into an <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress"/>
            so it can be used from the new streaming find references APIs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress">
            <summary>
            Reports the progress of the FindReferences operation.  Note: these methods may be called on
            any thread.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolGroup">
            <summary>
            Represents a group of <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s that should be treated as a single entity for
            the purposes of presentation in a Find UI.  For example, when a symbol is defined in a file
            that is linked into multiple project contexts, there will be several unique symbols created
            that we search for.  Placing these in a group allows the final consumer to know that these 
            symbols can be merged together.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolGroup.Symbols">
            <summary>
            All the symbols in the group.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress">
            <summary>
            Reports the progress of the FindReferences operation.  Note: these methods may be called on
            any thread.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.LinkedFileReferenceLocationEqualityComparer">
            <summary>
            Helper comparer to enable consumers of <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/> to process references found in linked files only a single time.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol">
            <summary>
            Represents a single result of the call to the synchronous
            IFindReferencesService.FindReferences method. Finding the references to a symbol will result
            in a set of definitions being returned (containing at least the symbol requested) as well as
            any references to those definitions in the source. Multiple definitions may be found due to
            how C# and VB allow a symbol to be both a definition and a reference at the same time (for
            example, a method which implements an interface method).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Definition">
            <summary>
            The symbol definition that these are references to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.LocationsArray">
            <summary>
            Same as <see cref="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Locations"/> but exposed as an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> for performance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Locations">
            <summary>
            The set of reference locations in the solution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation">
            <summary>
            Information about a reference to a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Document">
            <summary>
            The document that the reference was found in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Alias">
            <summary>
            If the symbol was bound through an alias, then this is the alias that was used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Location">
            <summary>
            The actual source location for a given symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsImplicit">
            <summary>
            Indicates if this is an implicit reference to the definition.  i.e. the definition wasn't
            explicitly stated in the source code at this position, but it was still referenced. For
            example, this can happen with special methods like GetEnumerator that are used
            implicitly by a 'for each' statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsWrittenTo">
            <summary>
            Indicates if this is a location where the reference is written to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.SymbolUsageInfo">
            <summary>
            Symbol usage info for this reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.AdditionalProperties">
            <summary>
            Additional properties for this reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.ContainingStringLocation">
            <summary>
            If this reference location is within a string literal, then this property
            indicates the location of the containing string literal token.
            Otherwise, <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.IAliasSymbol,Microsoft.CodeAnalysis.Location,System.Boolean,Microsoft.CodeAnalysis.SymbolUsageInfo,System.Collections.Immutable.ImmutableArray{System.ValueTuple{System.String,System.String}},Microsoft.CodeAnalysis.CandidateReason)">
            <summary>
            Creates a reference location with the given properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location)">
            <summary>
            Creates a reference location within a string literal.
            For example, location inside the target string of a global SuppressMessageAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsCandidateLocation">
            <summary>
            Indicates if this was not an exact reference to a location, but was instead a possible
            location that was found through error tolerance.  For example, a call to a method like
            "Goo()" could show up as an error tolerance location to a method "Goo(int i)" if no
            actual "Goo()" method existed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Exact">
            <summary>
            Use an case-sensitive comparison when searching for matching items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.ExactIgnoreCase">
            <summary>
            Use a case-insensitive comparison when searching for matching items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Fuzzy">
            <summary>
            Use a fuzzy comparison when searching for matching items. Fuzzy matching allows for 
            a certain amount of misspellings, missing words, etc. See <see cref="T:Roslyn.Utilities.SpellChecker"/> for 
            more details.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Custom">
            <summary>
            Search term is matched in a custom manner (i.e. with a user provided predicate).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery.Name">
            <summary>The name being searched for.  Is null in the case of custom predicate searching..  But 
            can be used for faster index based searching when it is available.</summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery.Kind">
            <summary>The kind of search this is.  Faster index-based searching can be used if the 
             SearchKind is not <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Custom"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery._predicate">
            <summary>The predicate to fall back on if faster index searching is not possible.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery._wordSimilarityChecker">
            <summary>
            Not readonly as this is mutable struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1.s_serializationFormatChecksum">
            <summary>
            Increment this whenever the data format of the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1"/> changes.  This ensures
            that we will not try to read previously cached data from a prior version of roslyn with a different format and
            will instead regenerate all the indices with the new format.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1.s_ppDirectivesToChecksum">
            <summary>
            Cache of ParseOptions to a checksum for the <see cref="P:Microsoft.CodeAnalysis.ParseOptions.PreprocessorSymbolNames"/> contained
            within.  Useful so we don't have to continually reenumerate and regenerate the checksum given how rarely
            these ever change.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.StreamingProgressCollector">
            <summary>
            Collects all the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> definitions and <see cref="T:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation"/> 
            references that are reported independently and packages them up into the final list
            of <see cref="T:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol" />.  This is used by the old non-streaming Find-References
            APIs to return all the results at the end of the operation, as opposed to broadcasting
            the results as they are found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.StreamingProgressCollector.#ctor(Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress)">
            <summary>
            Collects all the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> definitions and <see cref="T:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation"/> 
            references that are reported independently and packages them up into the final list
            of <see cref="T:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol" />.  This is used by the old non-streaming Find-References
            APIs to return all the results at the end of the operation, as opposed to broadcasting
            the results as they are found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo">
            <summary>
            Contains information about a call from one symbol to another.  The symbol making the call is
            stored in CallingSymbol and the symbol that the call was made to is stored in CalledSymbol.
            Whether or not the call is direct or indirect is also stored.  A direct call is a call that
            does not go through any other symbols in the inheritance hierarchy of CalledSymbol, while an
            indirect call does go through the inheritance hierarchy.  For example, calls through a base
            member that this symbol overrides, or through an interface member that this symbol
            implements will be considered 'indirect'. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CallingSymbol">
            <summary>
            The symbol that is calling the symbol being called.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.Locations">
            <summary>
            The locations inside the calling symbol where the called symbol is referenced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CalledSymbol">
            <summary>
            The symbol being called.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.IsDirect">
            <summary>
            True if the CallingSymbol is directly calling CalledSymbol.  False if it is calling a
            symbol in the inheritance hierarchy of the CalledSymbol.  For example, if the called
            symbol is a class method, then an indirect call might be through an interface method that
            the class method implements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPosition(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Obsolete.  Use <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPositionAsync(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPositionAsync(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Finds the symbol that is associated with a position in the text of a document.
            </summary>
            <param name="semanticModel">The semantic model associated with the document.</param>
            <param name="position">The character position within the document.</param>
            <param name="workspace">A workspace to provide context.</param>
            <param name="cancellationToken">A CancellationToken.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPositionAsync(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Host.SolutionServices,System.Threading.CancellationToken)">
            <summary>
            Finds the symbol that is associated with a position in the text of a document.
            </summary>
            <param name="semanticModel">The semantic model associated with the document.</param>
            <param name="position">The character position within the document.</param>
            <param name="cancellationToken">A CancellationToken.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDefinitionAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds the definition symbol declared in source code for a corresponding reference symbol. 
            Returns null if no such symbol can be found in the specified solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDefinition(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDefinitionAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSimilarSymbols``1(``0,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Finds symbols in the given compilation that are similar to the specified symbol.
            
            A found symbol may be the exact same symbol instance if the compilation is the origin of the specified symbol, 
            or it may be a different symbol instance if the compilation is not the originating compilation.
            
            Multiple symbols may be returned if there are ambiguous matches.
            No symbols may be returned if the compilation does not define or have access to a similar symbol.
            </summary>
            <param name="symbol">The symbol to find corresponding matches for.</param>
            <param name="compilation">A compilation to find the corresponding symbol within. The compilation may or may not be the origin of the symbol.</param>
            <param name="cancellationToken">A CancellationToken.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindLinkedSymbolsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="symbol"/> is declared in a linked file, then this function returns all the symbols that
            are defined by the same symbol's syntax in the all projects that the linked file is referenced from.
            <para/>
            In order to be returned the other symbols must have the same <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/> and <see
            cref="P:Microsoft.CodeAnalysis.ISymbol.Kind"/> as <paramref name="symbol"/>.  This matches general user intuition that these are all
            the 'same' symbol, and should be examined, regardless of the project context and <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> they
            originally started with.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesServerCallback">
            <summary>
            Callback object we pass to the OOP server to hear about the result 
            of the FindReferencesEngine as it executes there.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesServerCallback.#ctor(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress)">
            <summary>
            Callback object we pass to the OOP server to hear about the result 
            of the FindReferencesEngine as it executes there.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindCallersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds all the callers of a specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindCallersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all the callers of a specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the declared symbols from either source, referenced projects or metadata assemblies with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the declared symbols from either source, referenced projects or metadata assemblies with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Boolean,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Solution,System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Project,System.String,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Project,System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="documents">A set of documents to be searched. If documents is null, then that means "all documents".</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="progress">An optional progress object that will receive progress
            information as the search is undertaken.</param>
            <param name="documents">An optional set of documents to be searched. If documents is null, then that means "all documents".</param>
            <param name="cancellationToken">An optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.VerifyForwardedTypes(Microsoft.CodeAnalysis.Solution,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Verifies that all pairs of named types in equivalentTypesWithDifferingAssemblies are equivalent forwarded types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.VerifyForwardedType(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns <see langword="true"/> if <paramref name="candidate"/> was forwarded to <paramref name="forwardedTo"/> in
            <paramref name="forwardedTo"/>'s <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindOverridesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Find symbols for members that override the specified member symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindOverridesArrayAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindOverridesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>
            <remarks>
            Use this overload to avoid boxing the result into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementedInterfaceMembersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Find symbols for declarations that implement members of the specified interface symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementedInterfaceMembersArrayAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementedInterfaceMembersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>
            <remarks>
            Use this overload to avoid boxing the result into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedClassesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds all the derived classes of the given type. Implementations of an interface are not considered
            "derived", but can be found with <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="type">The symbol to find derived types of.</param>
            <param name="solution">The solution to search in.</param>
            <param name="projects">The projects to search. Can be null to search the entire solution.</param>
            <param name="cancellationToken"></param>
            <returns>The derived types of the symbol. The symbol passed in is not included in this list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedClassesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds the derived classes of the given type. Implementations of an interface are not considered
            "derived", but can be found with <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="type">The symbol to find derived types of.</param>
            <param name="solution">The solution to search in.</param>
            <param name="transitive">If the search should stop at immediately derived classes, or should continue past that.</param>
            <param name="projects">The projects to search. Can be null to search the entire solution.</param>
            <param name="cancellationToken"></param>
            <returns>The derived types of the symbol. The symbol passed in is not included in this list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedClassesArrayAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedClassesArrayAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>
            <remarks> Use this overload to avoid boxing the result into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedInterfacesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds the derived interfaces of the given interfaces.
            </summary>
            <param name="type">The symbol to find derived types of.</param>
            <param name="solution">The solution to search in.</param>
            <param name="transitive">If the search should stop at immediately derived interfaces, or should continue past that.</param>
            <param name="projects">The projects to search. Can be null to search the entire solution.</param>
            <returns>The derived interfaces of the symbol. The symbol passed in is not included in this list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedInterfacesArrayAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedInterfacesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>
            <remarks> Use this overload to avoid boxing the result into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds the accessible <see langword="class"/> or <see langword="struct"/> types that implement the given
            interface.
            </summary>
            <param name="type">The symbol to find derived types of.</param>
            <param name="solution">The solution to search in.</param>
            <param name="transitive">If the search should stop at immediately derived interfaces, or should continue past that.</param>
            <param name="projects">The projects to search. Can be null to search the entire solution.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsArrayAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Boolean,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>
            <remarks> Use this overload to avoid boxing the result into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds all the accessible symbols that implement an interface or interface member.  For an <see
            cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/> this will be both immediate and transitive implementations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindMemberImplementationsArrayAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>
            <remarks>
            Use this overload to avoid boxing the result into an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.ISymbolTreeInfoCacheService">
            <summary>
            Computes and caches <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> indices for the source symbols in <see cref="T:Microsoft.CodeAnalysis.Project"/>s and
            for metadata symbols in <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheServiceFactory.MetadataInfo.SymbolTreeInfo">
            <summary>
            Can't be null.  Even if we weren't able to read in metadata, we'll still create an empty
            index.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheServiceFactory.MetadataInfo.ReferencingProjects">
            <summary>
            The set of projects that are referencing this metadata-index.  When this becomes empty we can dump the
            index from memory.
            </summary>
            <remarks>
            <para>Accesses to this collection must lock the set.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheServiceFactory.SymbolTreeInfoCacheService.EntireProjectWorkerBackOff">
            <summary>
            Same value as SolutionCrawlerTimeSpan.EntireProjectWorkerBackOff
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheServiceFactory.SymbolTreeInfoCacheService._scheduler">
            <summary>
            Scheduler to run our tasks on.  If we're in the remote host , we'll run all our tasks concurrently.
            Otherwise, we will run them serially using <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheServiceFactory.SymbolTreeInfoCacheService.s_exclusiveScheduler"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheServiceFactory.SymbolTreeInfoCacheService.TryGetPotentiallyStaleMetadataSymbolTreeInfoAsync(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken)">
            <summary>
            Gets the latest computed <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> for the requested <paramref name="reference"/>.
            This may return an index corresponding to a prior version of the reference if it has since changed.
            Another system is responsible for bringing these indices up to date in the background.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo">
            <summary>
            Represents a tree of names of the namespaces, types (and members within those types) within a <see
            cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.  This tree can be used to quickly determine if
            there is a name match, and can provide the named path to that named entity.  This path can then be used to
            produce a corresponding <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> that can be used by a feature.  The primary purpose of this index
            is to allow features to quickly determine that there is <em>no</em> name match, so that acquiring symbols is not
            necessary.  The secondary purpose is to generate a minimal set of symbols when there is a match, though that
            will still incur a heavy cost (for example, getting the <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> root symbol for a
            particular project).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._nodes">
            <summary>
            The list of nodes that represent symbols. The primary key into the sorting of this list is the name. They
            are sorted case-insensitively . Finding case-sensitive matches can be found by binary searching for
            something that matches insensitively, and then searching around that equivalence class for one that matches.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._inheritanceMap">
            <summary>
            Inheritance information for the types in this assembly.  The mapping is between
            a type's simple name (like 'IDictionary') and the simple metadata names of types 
            that implement it or derive from it (like 'Dictionary').
            
            Note: to save space, all names in this map are stored with simple ints.  These
            ints are the indices into _nodes that contain the nodes with the appropriate name.
            
            This mapping is only produced for metadata assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._receiverTypeNameToExtensionMethodMap">
            <summary>
            Maps the name of receiver type name to its <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo" />.
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo"/> for the definition of simple/complex methods.
            For non-array simple types, the receiver type name would be its metadata name, e.g. "Int32".
            For any array types with simple type as element, the receiver type name would be just "ElementTypeName[]", e.g. "Int32[]" for int[][,]
            For non-array complex types, the receiver type name is "".
            For any array types with complex type as element, the receiver type name is "[]"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FuzzyFindAsync(Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.IAssemblySymbol},System.String,System.Threading.CancellationToken)">
            <summary>
            Finds symbols in this assembly that match the provided name in a fuzzy manner.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ContainsSymbolWithName(System.String)">
            <summary>
            Returns <see langword="true"/> if this index contains some symbol that whose name matches <paramref
            name="name"/> case <em>sensitively</em>. <see langword="false"/> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FindAsync(Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.IAssemblySymbol},System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get all symbols that have a name matching the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BinarySearch(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node},System.String)">
            <summary>
            Searches for a name in the ordered list that matches per the <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_caseInsensitiveComparer" />.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FirstEntityHandleProvider">
            <summary>
            Used to produce the simple-full-name components of a type from metadata.
            The name is 'simple' in that it does not contain things like backticks,
            generic arguments, or nested type + separators.  Instead just hte name
            of the type, any containing types, and the component parts of its namespace
            are added.  For example, for the type "X.Y.O`1.I`2, we will produce [X, Y, O, I]
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BuilderNode">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BuilderNode"/>s are produced when initially creating our indices.
            They store Names of symbols and the index of their parent symbol.  When we
            produce the final <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> though we will then convert
            these to <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BuilderNode.#ctor(System.String,System.Int32,Roslyn.Utilities.MultiDictionary{Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.MetadataNode,Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo}.ValueSet)">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BuilderNode"/>s are produced when initially creating our indices.
            They store Names of symbols and the index of their parent symbol.  When we
            produce the final <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> though we will then convert
            these to <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node"/>s.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node.Name">
            <summary>
            The Name of this Node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node.ParentIndex">
            <summary>
            Index in <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._nodes"/> of the parent Node of this Node.
            Value will be <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.RootNodeParentIndex"/> if this is the 
            Node corresponding to the root symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.Name">
            <summary>
            This is the type name of the parameter when <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.IsComplexType"/> is false. 
            For array types, this is just the element type name.
            e.g. `int` for `int[][,]` 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.IsArray">
            <summary>
            Indicate if the type of parameter is any kind of array.
            This is relevant for both simple and complex types. For example:
            - array of simple type like int[], int[][], int[][,], etc. are all ultimately represented as "int[]" in index.
            - array of complex type like T[], T[][], etc are all represented as "[]" in index, 
              in contrast to just "" for non-array types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.IsComplexType">
            <summary>
            Similar to <see cref="T:Microsoft.CodeAnalysis.FindSymbols.TopLevelSyntaxTreeIndex.ExtensionMethodInfo"/>, we divide extension methods into
            simple and complex categories for filtering purpose. Whether a method is simple is determined based on
            if we can determine it's receiver type easily with a pure text matching. For complex methods, we will
            need to rely on symbol to decide if it's feasible.
            
            Simple types include:
            - Primitive types
            - Types which is not a generic method parameter
            - By reference type of any types above
            - Array types with element of any types above
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo.Name">
            <summary>
            Name of the extension method. 
            This can be used to retrieve corresponding symbols via <see cref="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers(System.String)"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo.FullyQualifiedContainerName">
            <summary>
            Fully qualified name for the type that contains this extension method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_peReferenceToInfo">
            <summary>
            Cache the symbol tree infos for assembly symbols produced from a particular <see
            cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>. Generating symbol trees for metadata can be expensive (in large
            metadata cases).  And it's common for us to have many threads to want to search the same metadata
            simultaneously. As such, we use an AsyncLazy to compute the value that can be shared among all callers.
            <para>
            We store this keyed off of the <see cref="P:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Checksum"/> produced by <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetMetadataChecksum(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken)"/>.  This
            ensures that 
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_metadataIdToSymbolTreeInfo">
            <summary>
            Similar to <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_peReferenceToInfo"/> except that this caches based on metadata id.  The primary
            difference here is that you can have the same MetadataId from two different <see
            cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>s, while having different checksums.  For example, if the aliases of a
            <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/> are changed (see <see
            cref="M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(System.Collections.Generic.IEnumerable{System.String})"/>, then it will have a different
            checksum, but same metadata ID.  As such, we can use this table to ensure we only do the expensive
            computation of the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> once per <see cref="T:Microsoft.CodeAnalysis.MetadataId"/>, but we may then have to
            make a copy of it with a new <see cref="P:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Checksum"/> if the checksums differ.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetInfoForMetadataReferenceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.PortableExecutableReference,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Produces a <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> for a given <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.
            Note:  will never return null;
            </summary>
            <param name="checksum">Optional checksum for the <paramref name="reference"/> (produced by <see
            cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetMetadataChecksum(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken)"/>).  Can be provided if already computed.  If not provided it will be computed
            and used for the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetInfoForMetadataReferenceAsync(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.Storage.SolutionKey,Microsoft.CodeAnalysis.PortableExecutableReference,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Produces a <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> for a given <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.
            Note:  will never return null;
            </summary>
            <param name="checksum">Optional checksum for the <paramref name="reference"/> (produced by <see
            cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetMetadataChecksum(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken)"/>).  Can be provided if already computed.  If not provided it will be computed
            and used for the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.LoadAnyInfoForMetadataReferenceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken)">
            <summary>
            Loads any info we have for this reference from our persistence store.  Will succeed regardless of the
            checksum of the <paramref name="reference"/>.  Should only be used by clients that are ok with potentially
            stale data.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.MetadataNode.Name">
            <summary>
            Represent this as non-null because that will be true when this is not in a pool and it is being used by
            other services.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.MetadataDefinition.ReceiverTypeInfo">
            <summary>
            Only applies to member kind. Represents the type info of the first parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.LoadOrCreateAsync(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.Storage.SolutionKey,Microsoft.CodeAnalysis.Checksum,System.Func{Microsoft.CodeAnalysis.Checksum,System.Threading.Tasks.ValueTask{Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo}},System.String,System.Threading.CancellationToken)">
            <summary>
            Generalized function for loading/creating/persisting data.  Used as the common core code for serialization
            of source and metadata SymbolTreeInfos.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.LoadAnyInfoForSourceAssemblyAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Loads any info we have for this project from our persistence store.  Will succeed regardless of the
            checksum of the <paramref name="project"/>.  Should only be used by clients that are ok with potentially
            stale data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_projectToSourceChecksum">
            <summary>
            Cache of project to the checksum for it so that we don't have to expensively recompute
            this each time we get a project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.IdentifierInfo.ProbablyContainsIdentifier(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) to be within the
            syntax tree.  Returns false when the identifier is guaranteed to not be within the
            syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.IdentifierInfo.ProbablyContainsEscapedIdentifier(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) escaped within the
            text of the syntax tree.  Returns false when the identifier is guaranteed to not be
            escaped within the text of the syntax tree.  An identifier that is not escaped within
            the text can be found by searching the text directly.  An identifier that is escaped can
            only be found by parsing the text and syntactically interpreting any escaping
            mechanisms found in the language ("\uXXXX" or "@XXXX" in C# or "[XXXX]" in Visual
            Basic).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.LiteralInfo.ProbablyContainsStringValue(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) to be within the
            syntax tree.  Returns false when the identifier is guaranteed to not be within the
            syntax tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.s_projectStringTable">
            <summary>
            String interning table so that we can share many more strings in our DeclaredSymbolInfo
            buckets.  Keyed off a Project instance so that we share all these strings as we create
            the or load the index items for this a specific Project.  This helps as we will generally 
            be creating or loading all the index items for the documents in a Project at the same time.
            Once this project is let go of (which happens with any solution change) then we'll dump
            this string table.  The table will have already served its purpose at that point and 
            doesn't need to be kept around further.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.GetGlobalAliases(System.String,System.Int32)">
            <summary>
            Gets the set of global aliases that point to something with the provided name and arity.
            For example of there is <c>global alias X = A.B.C&lt;int&gt;</c>, then looking up with
            <c>name="C"</c> and arity=1 will return <c>X</c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.Name">
            <summary>
            The name to pattern match against, and to show in a final presentation layer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.NameSuffix">
            <summary>
            An optional suffix to be shown in a presentation layer appended to <see cref="F:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.Name"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.ContainerDisplayName">
            <summary>
            Container of the symbol that can be shown in a final presentation layer. 
            For example, the container of a type "KeyValuePair" might be 
            "System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;".  This can 
            then be shown with something like "type System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;"
            to indicate where the symbol is located.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.FullyQualifiedContainerName">
            <summary>
            Dotted container name of the symbol, used for pattern matching.  For example
            The fully qualified container of a type "KeyValuePair" would be 
            "System.Collections.Generic.Dictionary" (note the lack of type parameters).
            This way someone can search for "D.KVP" and have the "D" part of the pattern
            match against this.  This should not be shown in a presentation layer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.InheritanceNames">
            <summary>
            The names directly referenced in source that this type inherits from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.TopLevelSyntaxTreeIndex.DeclaredSymbolInfoSet">
            <summary>
            Same as <see cref="P:Microsoft.CodeAnalysis.FindSymbols.TopLevelSyntaxTreeIndex.DeclaredSymbolInfos"/>, just stored as a set for easy containment checks.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.TopLevelSyntaxTreeIndex.ExtensionMethodInfo.ReceiverTypeNameToExtensionMethodMap">
            <summary>
            Name of the extension method's receiver type to the index of its DeclaredSymbolInfo in `_declarationInfo`.
            
            For simple types, the receiver type name is it's metadata name. All predefined types are converted to its metadata form.
            e.g. int => Int32. For generic types, type parameters are ignored.
            
            For complex types, the receiver type name is "".
            
            For any kind of array types, it's "{element's receiver type name}[]".
            e.g. 
            int[][,] => "Int32[]"
            T (where T is a type parameter) => ""
            T[,] (where T is a type parameter) => "T[]"
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractFormattingService">
            <summary>
            Base implementation of C# and VB formatting services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Formatter">
            <summary>
            Formats whitespace in documents or syntax trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation">
            <summary>
            The annotation used to mark portions of a syntax tree to be formatted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetDefaultFormattingRules(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the formatting rules that would be applied if left unspecified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in a document.
            </summary>
            <param name="document">The document to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in an area of a document corresponding to a text span.
            </summary>
            <param name="document">The document to format.</param>
            <param name="span">The span of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to multiple non-overlapping spans.
            </summary>
            <param name="document">The document to format.</param>
            <param name="spans">The spans of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to annotated nodes.
            </summary>
            <param name="document">The document to format.</param>
            <param name="annotation">The annotation used to find on nodes to identify spans to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree corresponding to annotated nodes.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="annotation">The annotation used to find nodes to identify spans to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree identified by a span.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="span">The span within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree identified by multiple non-overlapping spans.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="spans">The spans within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="span">The span within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="spans">The spans within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.OrganizeImportsAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Organizes the imports in the document.
            </summary>
            <param name="document">The document to organize.</param>
            <param name="cancellationToken">The cancellation token that the operation will observe.</param>
            <returns>The document with organized imports. If the language does not support organizing imports, or if no changes were made, this method returns <paramref name="document"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingOptions">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Formatting.FormattingOptions2"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions.UseTabs">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.UseTabs"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions.TabSize">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.TabSize"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions.IndentationSize">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.IndentationSize"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions.NewLine">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.NewLine"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions.SmartIndent">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.IndentStyle"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.IFormattingService.FormatAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Formatting.LineFormattingOptions,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to multiple non-overlapping spans.
            </summary>
            <param name="document">The document to format.</param>
            <param name="spans">The spans of the document's text to format. If null, the entire document should be formatted.</param>
            <param name="lineFormattingOptions">Line formatting options.</param>
            <param name="syntaxFormattingOptions">Formatting options, if available. Null for non-Roslyn languages.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule">
            <summary>
            Provide a custom formatting operation provider that can intercept/filter/replace default formatting operations.
            </summary>
            <remarks>All methods defined in this class can be called concurrently. Must be thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddSuppressOperations(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddAnchorIndentationOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddIndentBlockOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddAlignTokensOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.GetAdjustNewLinesOperation(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.GetAdjustSpacesOperation(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddSuppressOperationsSlow(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddAnchorIndentationOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddIndentBlockOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddAlignTokensOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.GetAdjustNewLinesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.GetAdjustSpacesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation">
            <summary>
            indicate how many lines are needed between two tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption">
             <summary>
             Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation"/>.
            
             <list type="bullet">
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption.PreserveLines"/></term>
                 <description>the operation will leave lineBreaks as it is if original lineBreaks are equal or greater than given lineBreaks</description>
               </item>
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption.ForceLines"/></term>
                 <description>the operation will force existing lineBreaks to the given lineBreaks</description>
               </item>
             </list>
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation">
            <summary>
            indicate how many spaces are needed between two spaces
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption">
            <summary>
            Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.PreserveSpaces">
            <summary>
            Preserve spaces as it is
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DefaultSpacesIfOnSingleLine">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DefaultSpacesIfOnSingleLine"/> means a default space operation created by the formatting
            engine by itself. It has its own option kind to indicates that this is an operation
            generated by the engine itself. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpacesIfOnSingleLine">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpacesIfOnSingleLine"/> means forcing the specified spaces between two tokens if two
            tokens are on a single line. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpaces">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpaces"/> means forcing the specified spaces regardless of positions of two tokens.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DynamicSpaceToIndentationIfOnSingleLine">
            <summary>
            If two tokens are on a single line, second token will be placed at current indentation if possible
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation">
            <summary>
            align first tokens on lines among the given tokens to the base token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption">
            <summary>
            option to control <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation"/> behavior
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation">
            <summary>
            preserve relative spaces between anchor token and first tokens on lines within the given text span 
            as long as it doesn't have explicit line operations associated with them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            create anchor indentation region around start and end token
            right after anchor token to end of end token will become anchor region
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            create anchor indentation region more explicitly by providing all necessary information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around start and end token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around the given text span
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAlignTokensOperation(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption)">
            <summary>
            instruct the engine to try to align first tokens on the lines among the given tokens to be aligned to the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustNewLinesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption)">
            <summary>
            instruct the engine to try to put the give lines between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustSpacesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption)">
            <summary>
            instruct the engine to try to put the given spaces between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAnchorIndentationOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions)">
            <summary>
            return AnchorIndentationOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetIndentBlockOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions)">
            <summary>
            return IndentBlockOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAlignTokensOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions)">
            <summary>
            return AlignTokensOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustNewLinesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions)">
            <summary>
            return AdjustNewLinesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustSpacesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions)">
            <summary>
            return AdjustSpacesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation">
            <summary>
            set indentation level for the given text span. it can be relative, absolute or dependent to other tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption">
            <summary>
            Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine">
            <summary>
            This indentation will be a delta to the first token in the line in which the base token is present
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePosition">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation.IndentationDeltaOrPosition"/> will be interpreted as delta of its enclosing indentation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.AbsolutePosition">
            <summary>
            <see cref="P:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation.IndentationDeltaOrPosition"/> will be interpreted as absolute position
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePositionMask">
            <summary>
            Mask for relative position options
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.PositionMask">
            <summary>
            Mask for position options.
            </summary>
            <remarks>
            Each <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation"/> specifies one of the position options to indicate the primary
            behavior for the operation.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.IndentIfConditionOfAnchorToken">
            <summary>
            Increase the <see cref="P:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation.IndentationDeltaOrPosition"/> if the block is part of a
            condition of the anchor token. For example:
            
            <code>
            if (value is
                { // This open brace token is part of a condition of the 'if' token.
                    Length: 2
                })
            </code>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation">
            <summary>
            suppress formatting operations within the given text span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption">
             <summary>
             Options for <see cref="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation"/>.
            
             <list type="bullet">
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.NoWrappingIfOnSingleLine"/></term>
                 <description>no wrapping if given tokens are on same line</description>
               </item>
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.NoWrapping"/></term>
                 <description>no wrapping regardless of relative positions of two tokens</description>
               </item>
               <item>
                 <term><see cref="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.NoSpacing"/></term>
                 <description>no spacing regardless of relative positions of two tokens</description>
               </item>
             </list>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.DisableFormatting">
            <summary>
            Completely disable formatting within a span.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AutoFormattingOptions">
            <summary>
            Automatic (on-type) formatting options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingOptions2">
            <summary>
            Formatting options stored in editorconfig.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.IndentStyle">
            <summary>
            For use in the shared CodeStyle layer.  Keep in syntax with FormattingOptions.IndentStyle.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.WrappingColumn">
            <summary>
            Default value of 120 was picked based on the amount of code in a github.com diff at 1080p.
            That resolution is the most common value as per the last DevDiv survey as well as the latest
            Steam hardware survey.  This also seems to a reasonable length default in that shorter
            lengths can often feel too cramped for .NET languages, which are often starting with a
            default indentation of at least 16 (for namespace, class, member, plus the final construct
            indentation).
            
            TODO: Currently the option has no storage and always has its default value. See https://github.com/dotnet/roslyn/pull/30422#issuecomment-436118696.
            
            Internal option -- not exposed to tooling.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.ConditionalExpressionWrappingLength">
            <summary>
            Internal option -- not exposed to editorconfig tooling.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.EditorConfigOptions">
            <summary>
            Options that we expect the user to set in editorconfig.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingOptions2.UndocumentedOptions">
            <summary>
            Options that can be set via editorconfig but we do not provide tooling support.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions.CommonDefaults">
            <summary>
            Language agnostic defaults.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.ContextMutableIntervalTree`2">
            <summary>
            a tweaked version of our interval tree to meet the formatting engine's need
            
            it now has an ability to return a smallest span that contains a position rather than
            all Intersecting or overlapping spans
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext">
            <summary>
            this class maintain contextual information such as 
            indentation of current position, based token to follow in current position and etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData">
            <summary>
            data that will be used in an interval tree related to Anchor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData.#ctor(Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation,Microsoft.CodeAnalysis.SyntaxToken,System.Int32)">
            <summary>
            data that will be used in an interval tree related to Anchor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData">
            <summary>
            data that will be used in an interval tree related to indentation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData.#ctor(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            data that will be used in an interval tree related to indentation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData._lazyIndentationDelta">
            <summary>
            Caches the value produced by <see cref="M:Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData.GetOrComputeIndentationDelta"/>.
            </summary>
            <value>
            <see cref="F:Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData.UninitializedIndentationDelta"/> if the field is not yet initialized; otherwise, the value
            returned from <see cref="F:Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData._indentationDeltaGetter"/>.
            </value>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.AdjustedIndentationData">
            <summary>
            Represents an indentation in which a fixed offset (<see cref="P:Microsoft.CodeAnalysis.Formatting.FormattingContext.AdjustedIndentationData.Adjustment"/>) is applied to a reference
            indentation amount (<see cref="P:Microsoft.CodeAnalysis.Formatting.FormattingContext.AdjustedIndentationData.BaseIndentationData"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingContext.AdjustedIndentationData.BaseIndentationData">
            <summary>
            The reference indentation data which needs to be adjusted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingContext.AdjustedIndentationData.Adjustment">
            <summary>
            The adjustment to apply to the <see cref="P:Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData.Indentation"/> value providede by
            <see cref="P:Microsoft.CodeAnalysis.Formatting.FormattingContext.AdjustedIndentationData.BaseIndentationData"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressSpacingData">
            <summary>
            data that will be used in an interval tree related to suppressing spacing operations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.SuppressSpacingData.#ctor(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            data that will be used in an interval tree related to suppressing spacing operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressWrappingData">
            <summary>
            data that will be used in an interval tree related to suppressing wrapping operations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.SuppressWrappingData.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean)">
            <summary>
            data that will be used in an interval tree related to suppressing wrapping operations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult.Rewriter(System.Collections.Generic.Dictionary{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the node with the given trivia information in the map
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.s_lastRulesAndOptions">
            <summary>
            It is very common to be formatting lots of documents at teh same time, with the same set of formatting rules and
            options. To help with that, cache the last set of ChainedFormattingRules that was produced, as it is not a cheap
            type to create.
            </summary>
            <remarks>
            Stored as a <see cref="T:System.Tuple`3"/> instead of a <see cref="T:System.ValueTuple`3"/> so we don't have
            to worry about torn write concerns.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.FormatSummary">
            <summary>
            return summary for current formatting work
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.OperationApplier">
            <summary>
            this actually applies formatting operations to trivia between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.OperationApplier.#ctor(Microsoft.CodeAnalysis.Formatting.FormattingContext,Microsoft.CodeAnalysis.Formatting.ChainedFormattingRules)">
            <summary>
            this actually applies formatting operations to trivia between two tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.FormattedSpan">
            <summary>
            span in the tree to format
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.Rewriter(System.Collections.Generic.Dictionary{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the tree info root node with the trivia information in the map
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory.Whitespace">
            <summary>
            represents a general trivia between two tokens. slightly more expensive than others since it
            needs to calculate stuff unlike other cases
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.NodeOperations">
            <summary>
            this collector gathers formatting operations that are based on a node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenData">
            <summary>
            it represents a token that is inside of token stream not also outside of token stream
            
            it uses an index to navigate previous and after tokens in the stream to make navigation faster. and regular
            Previous/NextToken for tokens outside of the stream.
            
            this object is supposed to be live very short but created a lot of time. that is why it is struct. 
            (same reason why SyntaxToken is struct - to reduce heap allocation)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations">
            <summary>
            it holds onto space and wrapping operation need to run between two tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream">
            <summary>
            This class takes care of tokens consumed in the formatting engine.
            
            It will maintain information changed compared to original token information. and answers
            information about tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream.Changes">
            <summary>
            Thread-safe collection that holds onto changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.TokenStream.GetColumn(Microsoft.CodeAnalysis.Formatting.TokenData,System.Func{Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TriviaData})">
            <summary>
            Get column of the token 
            * column means text position on a line where all tabs are converted to spaces that first position on a line becomes 0
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TreeData">
            <summary>
            this provides information about the syntax tree formatting service is formatting.
            this provides necessary abstraction between different kinds of syntax trees so that ones that contain
            actual text or cache can answer queries more efficiently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TriviaData">
            <summary>
            it holds onto trivia information between two tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds.FormattingDiagnosticId">
            <summary>
            This is the ID reported for formatting diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds.FormatDocumentControlDiagnosticId">
            <summary>
            This special diagnostic can be suppressed via <c>#pragma</c> to prevent the formatter from making changes to
            code formatting within the span where the diagnostic is suppressed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.IFormattingResult">
            <summary>
            Contains changes that can be either applied to different targets such as a buffer or a tree
            or examined to be used in other places such as quick fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.#cctor">
            <summary>
            set up space string caches
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Formatter`1">
            <summary>
            format the trivia at the line column and put changes to the changes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.WhitespaceAppender`1">
            <summary>
            create whitespace for the delta at the line column and put changes to the changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Succeeded">
            <summary>
            return whether this formatting succeeded or not
            for example, if there is skipped tokens in one of trivia between tokens
            we consider formatting this region is failed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsWhitespace(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is whitespace trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsEndOfLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is end of line trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.LineContinuationFollowedByWhitespaceComment(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            true if previoustrivia is _ and nextTrivia is a Visual Basic comment
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsVisualBasicComment(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is a Comment in VB or not
            It is never reachable in C# since it follows a test for
            LineContinuation Character.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsNullOrWhitespace(System.String)">
            <summary>
            check whether given string is either null or whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsWhitespace(System.Char)">
            <summary>
            check whether given char is whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsNewLine(System.Char)">
            <summary>
            check whether given char is new line char
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.CreateWhitespace(System.String)">
            <summary>
            create whitespace trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.CreateEndOfLine">
            <summary>
            create end of line trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,System.Boolean,Microsoft.CodeAnalysis.SyntaxTrivia,System.Threading.CancellationToken)">
            <summary>
            return line column rule for the given two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.SyntaxTrivia},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put text change result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.ContainsImplicitLineBreak(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            returns true if the trivia contains a Line break
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetOverallLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,System.Boolean,Microsoft.CodeAnalysis.SyntaxTrivia,System.Threading.CancellationToken)">
            <summary>
            get line column rule between two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetTokensAtEdgeOfStructureTrivia(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            if the given trivia is the very first or the last trivia between two normal tokens and
            if the trivia is structured trivia, get one token that belongs to the structured trivia and one belongs to the normal token stream
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.ContainsOnlyWhitespace(System.Int32,System.Int32)">
            <summary>
            check whether string between start and end position only contains whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.FirstLineBlank">
            <summary>
            check whether first line between two tokens contains only whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetTrailingLinesAtEndOfTrivia1(Microsoft.CodeAnalysis.Formatting.LineColumn)">
            <summary>
            return 0 or 1 based on line column of the trivia1's end point
            this is based on our structured trivia's implementation detail that some structured trivia can have
            one new line at the end of the trivia
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumn.Line">
            <summary>
            absolute line number from first token
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumn.Column">
            <summary>
            absolute column from beginning of a line
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumn.WhitespaceOnly">
            <summary>
            there is only whitespace on this line
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.Lines">
            <summary>
            relative line number between calls
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.Spaces">
            <summary>
            relative spaces between calls
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.WhitespaceOnly">
            <summary>
            there is only whitespace in this space
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.LineColumnDelta.ForceUpdate">
            <summary>
            force text change regardless line and space changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.AbstractDeclaredSymbolInfoFactoryService`10.GetReceiverTypeName(`5)">
            <summary>
            Get the name of the target type of specified extension method declaration. The node provided must be an
            extension method declaration,  i.e. calling `TryGetDeclaredSymbolInfo()` on `node` should return a
            `DeclaredSymbolInfo` of kind `ExtensionMethod`. If the return value is null, then it means this is a
            "complex" method (as described at <see cref="T:Microsoft.CodeAnalysis.FindSymbols.TopLevelSyntaxTreeIndex.ExtensionMethodInfo"/>).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageService.IBlockFacts">
            <summary>
            Provides helpers for working across "blocks" of statements in an agnostic fashion across VB and C#.  Both
            languages have quirks here that this API attempts to smooth out.  For example, many things in VB are 'blocks'
            (like ClassBlocks and MethodBlocks).  However, only a subset of those can have executable statements. Similarly,
            C# has actual BlockSyntax nodes (<c>{ ... }</c>), but it can also have sequences of executable statements not
            contained by those (for example statements in a case-clause in a switch-statement).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IBlockFacts.IsScopeBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A block that has no semantics other than introducing a new scope. That is only C# BlockSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IBlockFacts.IsExecutableBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A node that contains a list of statements. In C#, this is BlockSyntax and SwitchSectionSyntax. In VB, this
            includes all block statements such as a MultiLineIfBlockSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IBlockFacts.IsStatementContainer(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A node that can host a list of statements or a single statement. In addition to every "executable block",
            this also includes C# embedded statement owners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IBlockFactsExtensions.GetStatementContainer(Microsoft.CodeAnalysis.LanguageService.IBlockFacts,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statement container node for the statement <paramref name="node"/>.
            </summary>
            <returns>The statement container for <paramref name="node"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IHeaderFactsExtensions.IsOnTypeHeader(Microsoft.CodeAnalysis.LanguageService.IHeaderFacts,Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Checks if the position is on the header of a type (from the start of the type up through it's name).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.AbstractHeaderFacts.TryGetAncestorForLocation``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Tries to get an ancestor of a Token on current position or of Token directly to left:
            e.g.: tokenWithWantedAncestor[||]tokenWithoutWantedAncestor
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IAccessibilityFacts.CanHaveAccessibility(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns whether a given declaration can have accessibility or not.
            </summary>
            <param name="declaration">The declaration node to check</param>
            <param name="ignoreDeclarationModifiers">A flag that indicates whether to consider modifiers on the given declaration that blocks adding accessibility.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.SupportsImplicitInterfaceImplementation">
            <summary>
            True if this language supports implementing an interface by signature only. If false,
            implementations must specific explicitly which symbol they're implementing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.ExposesAnonymousFunctionParameterNames">
            <summary>
            True if anonymous functions in this language have signatures that include named
            parameters that can be referenced later on when the function is invoked.  Or, if the
            anonymous function is simply a signature that will be assigned to a delegate, and the
            delegate's parameter names are used when invoking.  
            
            For example, in VB one can do this: 
            
            dim v = Sub(x as Integer) Blah()
            v(x:=4)
            
            However, in C# that would need to be:
            
            Action&lt;int&gt; v = (int x) => Blah();
            v(obj:=4)
            
            Note that in VB one can access 'x' outside of the declaration of the anonymous type.
            While in C# 'x' can only be accessed within the anonymous type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.IsWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: reads may also be performed
            to the expression as well.  For example, "++a".  In this expression 'a' is both read from
            and written to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.IsOnlyWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: unlike IsWrittenTo, this
            will not return true if reads are performed on the expression as well.  For example,
            "++a" will return 'false'.  However, 'a' in "out a" or "a = 1" will return true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            return speculative semantic model for supported node. otherwise, it will return null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.GetAliasNameSet(Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            get all alias names defined in the semantic model
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.GetLocalFunctionSymbols(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Finds all local function definitions within the syntax references for a given <paramref name="symbol"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISemanticFacts.GetInterceptorSymbolAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a location in a document, returns the symbol that intercepts the original symbol called at that location.
            The position must be the location of an identifier token used as the name of an invocation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.IHeaderFacts.IsOnTypeHeader(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            <paramref name="fullHeader"/> controls how much of the type header should be considered. If <see
            langword="false"/> only the span up through the type name will be considered.  If <see langword="true"/>
            then the span through the base-list will be considered.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts">
             <summary>
             Contains helpers to allow features and other algorithms to run over C# and Visual Basic code in a uniform fashion.
             It should be thought of a generalized way to apply type-pattern-matching and syntax-deconstruction in a uniform
             fashion over the languages. Helpers in this type should only be one of the following forms:
             <list type="bullet">
             <item>
             'IsXXX' where 'XXX' exactly matches one of the same named syntax (node, token, trivia, list, etc.) constructs that 
             both C# and VB have. For example 'IsSimpleName' to correspond to C# and VB's SimpleNameSyntax node.  These 'checking' 
             methods should never fail.  For non leaf node types this should be implemented as a typecheck ('is' in C#, 'typeof ... is'
             in VB).  For leaf nodes, this should be implemented by deffering to <see cref="T:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds"/> to check against the 
             raw kind of the node.
             </item>
             <item>
             'GetPartsOfXXX(SyntaxNode node, out SyntaxNode/SyntaxToken part1, ...)' where 'XXX' one of the same named Syntax constructs
             that both C# and VB have, and where the returned parts correspond to the members those nodes have in common across the 
             languages.  For example 'GetPartsOfQualifiedName(SyntaxNode node, out SyntaxNode left, out SyntaxToken dotToken, out SyntaxNode right)'
             VB.  These functions should throw if passed a node that the corresponding 'IsXXX' did not return <see langword="true"/> for.
             For nodes that only have a single child, 'GetPartsOfXXX' is not not needed and can be replaced with the easier to use
             'GetXXXOfYYY' to get that single child.
             </item>
             <item>
             'GetXxxOfYYY' where 'XXX' matches the name of a property on a 'YYY' syntax construct that both C# and VB have.  For
             example 'GetExpressionOfMemberAccessExpression' corresponding to MemberAccessExpressionsyntax.Expression in both C# and
             VB.  These functions should throw if passed a node that the corresponding 'IsYYY' did not return <see langword="true"/> for.
             For nodes that only have a single child, these functions can stay here.  For nodes with multiple children, these should migrate
             to <see cref="T:Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions"/> and be built off of 'GetPartsOfXXX'.
             </item>
             <item>
             Absolutely trivial questions that relate to syntax and can be asked sensibly of each language.  For example,
             if certain constructs (like 'patterns') are supported in that language or not.
             </item>
             </list>
            
             <para>Importantly, avoid:</para>
            
             <list type="bullet">
             <item>
             Functions that attempt to blur the lines between similar constructs in the same language.  For example, a QualifiedName
             is not the same as a MemberAccessExpression (despite A.B being representable as either depending on context). 
             Features that need to handle both should make it clear that they are doing so, showing that they're doing the right
             thing for the contexts each can arise in (for the above example in 'type' vs 'expression' contexts).
             </item>
             <item>
             Functions which are effectively specific to a single feature are are just trying to find a place to place complex
             feature logic in a place such that it can run over VB or C#.  For example, a function to determine if a position
             is on the 'header' of a node.  a 'header' is a not a well defined syntax concept that can be trivially asked of
             nodes in either language.  It is an excapsulation of a feature (or set of features) level idea that should be in
             its own dedicated service.
             </item>
             <item>
             Functions that mutate or update syntax constructs for example 'WithXXX'.  These should be on SyntaxGenerator or
             some other feature specific service.
             </item>
             <item>
             Functions that a single item when one language may allow for multiple.  For example 'GetIdentifierOfVariableDeclarator'.
             In VB a VariableDeclarator can itself have several names, so calling code must be written to check for that and handle
             it apropriately.  Functions like this make it seem like that doesn't need to be considered, easily allowing for bugs
             to creep in.
             </item>
             <item>
             Abbreviating or otherwise changing the names that C# and VB share here.  For example use 'ObjectCreationExpression'
             not 'ObjectCreation'.  This prevents accidental duplication and keeps consistency with all members.
             </item>
             </list>
             </summary>
             <remarks>
             Many helpers in this type currently violate the above 'dos' and 'do nots'.  They should be removed and either 
             inlined directly into the feature that needs if (if only a single feature), or moved into a dedicated service
             for that purpose if needed by multiple features.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
             <summary>
             Returns 'true' if this a 'reserved' keyword for the language.  A 'reserved' keyword is a
             identifier that is always treated as being a special keyword, regardless of where it is
             found in the token stream.  Examples of this are tokens like <see langword="class"/> and
             <see langword="Class"/> in C# and VB respectively.
            
             Importantly, this does *not* include contextual keywords.  If contextual keywords are
             important for your scenario, use <see cref="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)"/> or <see
             cref="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions.IsReservedOrContextualKeyword(Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxToken)"/>.  Also, consider using
             <see cref="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions.IsWord(Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxToken)"/> if all you need is the ability to know
             if this is effectively any identifier in the language, regardless of whether the language
             is treating it as a keyword or not.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
             <summary>
             Returns <see langword="true"/> if this a 'contextual' keyword for the language.  A
             'contextual' keyword is a identifier that is only treated as being a special keyword in
             certain *syntactic* contexts.  Examples of this is 'yield' in C#.  This is only a
             keyword if used as 'yield return' or 'yield break'.  Importantly, identifiers like <see
             langword="var"/>, <see langword="dynamic"/> and <see langword="nameof"/> are *not*
             'contextual' keywords.  This is because they are not treated as keywords depending on
             the syntactic context around them.  Instead, the language always treats them identifiers
             that have special *semantic* meaning if they end up not binding to an existing symbol.
            
             Importantly, if <paramref name="token"/> is not in the syntactic construct where the
             language thinks an identifier should be contextually treated as a keyword, then this
             will return <see langword="false"/>.
            
             Or, in other words, the parser must be able to identify these cases in order to be a
             contextual keyword.  If identification happens afterwards, it's not contextual.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            The set of identifiers that have special meaning directly after the `#` token in a
            preprocessor directive.  For example `if` or `pragma`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetLeftSideOfDot(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Get the node on the left side of the dot if given a dotted expression.
            </summary>
            <param name="allowImplicitTarget">
            In VB, we have a member access expression with a null expression, this may be one of the
            following forms:
                1) new With { .a = 1, .b = .a      .a refers to the anonymous type
                2) With obj : .m                   .m refers to the obj type
                3) new T() With { .a = 1, .b = .a  'a refers to the T type
            If `allowImplicitTarget` is set to true, the returned node will be set to approperiate node, otherwise, it will return null.
            This parameter has no affect on C# node.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetStandaloneExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetRootConditionalAccessExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Call on the `.y` part of a `x?.y` to get the entire `x?.y` conditional access expression.  This also works
            when there are multiple chained conditional accesses.  For example, calling this on '.y' or '.z' in
            `x?.y?.z` will both return the full `x?.y?.z` node.  This can be used to effectively get 'out' of the RHS of
            a conditional access, and commonly represents the full standalone expression that can be operated on
            atomically.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetExpressionOfMemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns the expression node the member is being accessed off of.  If <paramref name="allowImplicitTarget"/>
            is <see langword="false"/>, this will be the node directly to the left of the dot-token.  If <paramref name="allowImplicitTarget"/>
            is <see langword="true"/>, then this can return another node in the tree that the member will be accessed
            off of.  For example, in VB, if you have a member-access-expression of the form ".Length" then this
            may return the expression in the surrounding With-statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsSimpleArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if this is an argument with just an expression and nothing else (i.e. no ref/out,
            no named params, no omitted args).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsMethodBody(Microsoft.CodeAnalysis.SyntaxNode)">
             <summary>
             Returns true for nodes that represent the body of a method.
            
             For VB this will be
             MethodBlockBaseSyntax.  This will be true for things like constructor, method, operator
             bodies as well as accessor bodies.  It will not be true for things like sub() function()
             lambdas.
            
             For C# this will be the BlockSyntax or ArrowExpressionSyntax for a
             method/constructor/deconstructor/operator/accessor.  It will not be included for local
             functions.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.IsTypeCharacter(System.Char)">
            <summary>
            Returns true if the given character is a character which may be included in an
            identifier to specify the type of a variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetMemberBodySpanForSpeculativeBinding(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, return the <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> representing the span of the member body
            it is contained within. This <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> is used to determine whether speculative binding should be
            used in performance-critical typing scenarios. Note: if this method fails to find a relevant span, it returns
            an empty <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> at position 0.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.TryGetBindableParent(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns the parent node that binds to the symbols that the IDE prefers for features like Quick Info and Find
            All References. For example, if the token is part of the type of an object creation, the parenting object
            creation expression is returned so that binding will return constructor symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetNameForArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, that represents and argument return the string representation of
            that arguments name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetNameForAttributeArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, that represents an attribute argument return the string representation of
            that arguments name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions.SpansPreprocessorDirective(Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Determines if there is preprocessor trivia *between* any of the <paramref name="tokens"/>
            provided.  The <paramref name="tokens"/> will be deduped and then ordered by position.
            Specifically, the first token will not have it's leading trivia checked, and the last
            token will not have it's trailing trivia checked.  All other trivia will be checked to
            see if it contains a preprocessor directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions.GetRootStandaloneExpression(Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Similar to <see cref="M:Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts.GetStandaloneExpression(Microsoft.CodeAnalysis.SyntaxNode)"/>, this gets the containing
            expression that is actually a language expression and not just typed as an ExpressionSyntax for convenience.
            However, this goes beyond that that method in that if this expression is the RHS of a conditional access
            (i.e. <c>a?.b()</c>) it will also return the root of the conditional access expression tree.
            <para/> The intuition here is that this will give the topmost expression node that could realistically be
            replaced with any other expression.  For example, with <c>a?.b()</c> technically <c>.b()</c> is an
            expression.  But that cannot be replaced with something like <c>(1 + 1)</c> (as <c>a?.(1 + 1)</c> is not
            legal).  However, in <c>a?.b()</c>, then <c>a</c> itself could be replaced with <c>(1 + 1)?.b()</c> to form
            a legal expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds">
            <summary>
            Provides a uniform view of SyntaxKinds over C# and VB for constructs they have
            in common.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds.MultiLineCommentTrivia">
            <summary>
            Gets the syntax kind for a multi-line comment.
            </summary>
            <value>
            The raw syntax kind for a multi-line comment; otherwise, <see langword="null"/> if the language does not
            support multi-line comments.
            </value>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageService.ISyntaxKindsService">
            <summary>
            Provides a uniform view of SyntaxKinds over C# and VB for constructs they have
            in common.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageService.ITypeInferenceService">
            <summary>
            Helper service for telling you what type can be inferred to be viable in a particular
            location in code.  This is useful for features that are starting from code that doesn't bind,
            but would like to know type that code should be in the location that it can be found in.  For
            example:
            
              int i = Here(); 
            
            If 'Here()' doesn't bind, then this class can be used to say that it is currently in a
            location whose type has been inferred to be 'int' from the surrounding context.  Note: this
            is simply a best effort guess.  'byte/short/etc.' as well as any user convertible types to
            int would also be valid here, however 'int' seems the most reasonable when considering user
            intuition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.AbstractSemanticFactsService.GetCollidableSymbols(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Retrieves all symbols that could collide with a symbol at the specified location.
            A symbol can possibly collide with the location if it is available to that location and/or
            could cause a compiler error if its name is re-used at that location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageService.ISymbolDeclarationService.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Given a symbol in source, returns the syntax nodes that compromise its declarations.
            This differs from symbol.Locations in that Locations returns a list of ILocations that
            normally correspond to the name node of the symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.AbstractLogAggregator`2">
            <summary>
            helper class to aggregate some numeric value log in client side
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.AbstractLogAggregator`2._map">
            <remarks>
            The key here is an object even though we will often be putting enums into this map; the problem with the use of enums or other value
            types is they prevent the runtime from sharing the same JITted code for each different generic instantiation. In this case,
            the cost of boxing is cheaper than the cost of the extra JIT.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.AggregateLogger">
            <summary>
            a logger that aggregate multiple loggers
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogger">
            <summary>
            a logger that doesn't do anything
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.EtwLogger.#ctor(System.Func{Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Boolean})">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.HistogramLogAggregator`1">
            <summary>
            Defines a log aggregator to create a histogram
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.HistogramLogAggregator`1.HistogramCounter.WriteTelemetryPropertiesTo(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Writes out these statistics to a property bag for sending to telemetry.
            </summary>
            <param name="prefix">The prefix given to any properties written. A period is used to delimit between the 
            prefix and the value.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.InteractionClass">
            <summary>
            An interaction class defines how much time is expected to reach a time point, the response 
            time point being the most commonly used. The interaction classes correspond to human perception,
            so, for example, all interactions in the Fast class are perceived as fast and roughly feel like 
            they have the same performance. By defining these interaction classes, we can describe 
            performance using adjectives that have a precise, consistent meaning.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage">
            <summary>
            LogMessage that creates key value map lazily
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage.Create(System.Action{System.Collections.Generic.Dictionary{System.String,System.Object}},Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage"/> with default <see cref="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Information"/>, since
            KV Log Messages are by default more informational and should be logged as such. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.LogType">
            <summary>
            Type of log it is making.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogType.Trace">
            <summary>
            Log some traces of an activity (default)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogType.UserAction">
            <summary>
            Log an user explicit action
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.PiiValue">
            <summary>
            Represents telemetry data that's classified as personally identifiable information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.PiiValue.#ctor(System.Object)">
            <summary>
            Represents telemetry data that's classified as personally identifiable information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogInformationalBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Object,System.Threading.CancellationToken)">
            <summary>
            Logs an informational block with given <paramref name="entity"/>'s <see cref="M:System.Object.ToString"/> representation as the message
            and specified <paramref name="functionId"/>.
            On dispose of the returned disposable object, it logs the 'tick' count between the start and end of the block.
            Unlike other logging methods on <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/>, this method does not check
            if the specified <paramref name="functionId"/> was explicitly enabled.
            Instead it checks if the <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/> was enabled at <see cref="F:System.Diagnostics.Tracing.EventLevel.Informational"/> level.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogInformationalBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Threading.CancellationToken)">
            <summary>
            Logs an informational message block with the given <paramref name="message"/>> and specified <paramref name="functionId"/>.
            On dispose of the returned disposable object, it logs the 'tick' count between the start and end of the block.
            Unlike other logging methods on <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/>, this method does not check
            if the specified <paramref name="functionId"/> was explicitly enabled.
            Instead it checks if the <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/> was enabled at <see cref="F:System.Diagnostics.Tracing.EventLevel.Informational"/> level.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogBlock">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogBlock.s_lastUniqueBlockId">
            <summary>
            next unique block id that will be given to each LogBlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogBlock.GetNextUniqueBlockId">
            <summary>
            return next unique pair id
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Maximum">
            <summary>
            maximum value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Minimum">
            <summary>
            minimum value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Mean">
            <summary>
            average value of the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Mode">
            <summary>
            most frequent value in the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Range">
            <summary>
            difference between max and min value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Count">
            <summary>
            number of data points in the total data set
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.WriteTelemetryPropertiesTo(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Writes out these statistics to a property bag for sending to telemetry.
            </summary>
            <param name="prefix">The prefix given to any properties written. A period is used to delimit between the 
            prefix and the value.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.TraceLogger">
            <summary>
            Implementation of <see cref="T:Microsoft.CodeAnalysis.Internal.Log.ILogger"/> that produce timing debug output. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.TraceLogger.#ctor(System.Func{Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Boolean})">
            <summary>
            Implementation of <see cref="T:Microsoft.CodeAnalysis.Internal.Log.ILogger"/> that produce timing debug output. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock">
            <summary>
            no op log block
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.FunctionId">
            <summary>
            Enum to uniquely identify each function location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.ILogger">
            <summary>
            logger interface actual logger should implements
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.IsEnabled(Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            answer whether it is enabled or not for the specific function id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage)">
            <summary>
            log a specific event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlockStart(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log a start event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlockEnd(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log an end event
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger">
            <summary>
            provide a way to log activities to various back end such as etl, code marker and etc
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.Logger.s_lastUniqueBlockId">
            <summary>
            next unique block id that will be given to each LogBlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.SetLogger(Microsoft.CodeAnalysis.Internal.Log.ILogger)">
            <summary>
            give a way to explicitly set/replace the logger
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetLogger">
            <summary>
            ensure we have a logger by putting one from workspace service if one is not there already.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a specific event with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String},Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a specific event with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``1(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``2(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``3(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``4(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage)">
            <summary>
            log a specific event with a context message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetNextUniqueBlockId">
            <summary>
            return next unique pair id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            simplest way to log a start and end pair
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            simplest way to log a start and end pair with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String},System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a start and end pair with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``1(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``2(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``3(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``4(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3,System.Threading.CancellationToken,Microsoft.CodeAnalysis.Internal.Log.LogLevel)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger.RoslynLogBlock">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.RoslynLogBlock.#ctor(Microsoft.CodeAnalysis.PooledObjects.ObjectPool{Microsoft.CodeAnalysis.Internal.Log.Logger.RoslynLogBlock})">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.LogLevel">
            <summary>
            Defines logging severity levels. Each logger may choose to report differently based on the level of the message being logged.
            
            Copied from Microsoft.Extensions.Logging https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loglevel
            
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Trace">
            <summary>
            Logs that contain the most detailed messages. These messages may contain sensitive application data. These messages are disabled by default and should never be enabled in a production environment.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Debug">
            <summary>
            Logs that are used for interactive investigation during development. These logs should primarily contain information useful for debugging and have no long-term value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Information">
            <summary>
            Logs that track the general flow of the application. These logs should have long-term value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Warning">
            <summary>
            Logs that highlight an abnormal or unexpected event in the application flow, but do not otherwise cause the application execution to stop.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Error">
            <summary>
            Logs that highlight when the current flow of execution is stopped due to a failure. These should indicate a failure in the current activity, not an application-wide failure.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.Critical">
            <summary>
            Logs that describe an unrecoverable application or system crash, or a catastrophic failure that requires immediate attention.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogLevel.None">
            <summary>
            Not used for writing log messages. Specifies that a logging category should not write any messages.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.LogMessage">
            <summary>
            log message that can generate string lazily
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.LogMessage.FreeCore">
            <summary>
            Logger will call this to return LogMessage to its pool
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService">
            <summary>
            Optional interface that can be used to hear about when expensive global operations (like a 'build') occur in the
            current host.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Started">
            <summary>
            raised when global operation is started
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Stopped">
            <summary>
            raised when global operation is stopped
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Start(System.String)">
            <summary>
            start new global operation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ObsoleteSymbol.AbstractObsoleteSymbolService._dimKeywordKind">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.RawKind"/> of the <see langword="Dim"/> keyword in Visual Basic, or
            <see langword="null"/> for C# scenarios. This value is used to improve performance in the token classification
            fast-path by avoiding unnecessary calls to <see cref="M:Microsoft.CodeAnalysis.ObsoleteSymbol.AbstractObsoleteSymbolService.ProcessDimKeyword(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Text.TextSpan}@,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ObsoleteSymbol.IObsoleteSymbolService">
            <summary>
            Service which can analyze a span of a document and identify all locations of declarations or references to
            symbols which are marked <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.DocumentOptionSet">
            <summary>
            An <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> that comes from <see cref="M:Microsoft.CodeAnalysis.Document.GetOptionsAsync(System.Threading.CancellationToken)"/>. It behaves just like a normal
            <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> but remembers which language the <see cref="T:Microsoft.CodeAnalysis.Document"/> is, so you don't have to
            pass that information redundantly when calling <see cref="M:Microsoft.CodeAnalysis.Options.DocumentOptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0})"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.DocumentOptionSet._values">
            <summary>
            Cached internal values read from <see cref="F:Microsoft.CodeAnalysis.Options.DocumentOptionSet._configOptions"/> or <see cref="F:Microsoft.CodeAnalysis.Options.DocumentOptionSet._underlyingOptions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.DocumentOptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.DocumentOptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the value of the option, or the default value if not otherwise set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the value of the option, or the default value if not otherwise set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.Option{``0})">
            <summary>
            Gets the value of the option, or the default value if not otherwise set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.Option{``0},``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String)">
            <summary>
            Gets the value of the option, or the default value if not otherwise set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String,``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption(Microsoft.CodeAnalysis.Options.OptionKey,System.Object)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.IsInternalOptionValue(System.Object)">
            <summary>
            Checks if the value is an internal representation -- does not cover all cases, just code style options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.IsPublicOptionValue(System.Object)">
            <summary>
            Checks if the value is an public representation -- does not cover all cases, just code style options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IGlobalOptionService">
            <summary>
            Provides services for reading and writing global client (in-proc) options
            shared across all workspaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.Option2{``0})">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption2{``0},System.String)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.OptionKey2)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOptions(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Options.OptionKey2})">
            <summary>
            Gets the current values of specified options.
            All options are read atomically.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.SetGlobalOption(Microsoft.CodeAnalysis.Options.OptionKey2,System.Object)">
            <summary>
            Sets and persists the value of a global option.
            Sets the value of a global option.
            Invokes registered option persisters.
            Triggers option changed event for handlers registered with <see cref="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.AddOptionChangedHandler(System.Object,Microsoft.CodeAnalysis.WeakEventHandler{Microsoft.CodeAnalysis.Options.OptionChangedEventArgs})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.SetGlobalOptions(System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.Options.OptionKey2,System.Object}})">
            <summary>
            Atomically sets the values of specified global options. The option values are persisted.
            Triggers option changed event for handlers registered with <see cref="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.AddOptionChangedHandler(System.Object,Microsoft.CodeAnalysis.WeakEventHandler{Microsoft.CodeAnalysis.Options.OptionChangedEventArgs})"/>.
            </summary>
            <remarks>
            Returns true if any option changed its value stored in the global options.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.RefreshOption(Microsoft.CodeAnalysis.Options.OptionKey2,System.Object)">
            <summary>
            Refreshes the stored value of an option. This should only be called from persisters.
            Does not persist the new option value.
            </summary>
            <remarks>
            Returns true if the option changed its value stored in the global options.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ILegacyGlobalOptionsWorkspaceService">
            <summary>
            Enables legacy APIs to access global options from workspace.
            Not available OOP. Only use in client code and when IGlobalOptionService can't be MEF imported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ILegacyWorkspaceOptionService">
            <summary>
            Only used by <see cref="T:Microsoft.CodeAnalysis.Workspace"/> and <see cref="T:Microsoft.CodeAnalysis.Options.SolutionOptionSet"/> to implement legacy public APIs:
            <see cref="P:Microsoft.CodeAnalysis.Workspace.Options"/> and <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOptionPersister">
            <summary>
            Exportable by a host to specify the save and restore behavior for a particular set of
            values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionPersisterProvider.GetOrCreatePersisterAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Options.IOptionPersister"/>. If the persister does not already exist, it is created.
            </summary>
            <remarks>
            This method is safe for concurrent use from any thread. No guarantees are made regarding the use of the UI
            thread.
            </remarks>
            <param name="cancellationToken">A cancellation token the operation may observe.</param>
            <returns>The option persister.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.LegacyGlobalOptionService._currentExternallyDefinedOptionValues">
            <summary>
            Stores options that are not defined by Roslyn and do not implement <see cref="T:Microsoft.CodeAnalysis.Options.IOption2"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.LegacyGlobalOptionService.SetOptions(System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.Options.OptionKey2,System.Object}},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.Options.OptionKey,System.Object}})">
            <summary>
            Sets values of options that may be stored in <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/> (public options).
            Clears <see cref="T:Microsoft.CodeAnalysis.Options.SolutionOptionSet"/> of registered workspaces so that next time
            <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/> are queried for the options new values are fetched from 
            <see cref="T:Microsoft.CodeAnalysis.Options.GlobalOptionService"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.Option`1">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Options.Option2`1"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionKey">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Options.OptionKey2"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionKey.Option">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionKey2.Option"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionKey.Language">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionKey2.Language"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionStorageLocation">
            <summary>
            The base type of all types that specify where options are stored.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.PerLanguageOption`1">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Type">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Type"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.DefaultValue">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Options.OptionDefinition.DefaultValue"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.PredefinedDocumentOptionsProviderNames.EditorConfig">
            <summary>
            The name of the providers for .editorconfig. Both the current and legacy providers will use this name, so that way any other clients can
            order relative to the pair. The two factories are unordered themselves because only one ever actually gives a real provider.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.SolutionOptionSet">
            <summary>
            Implements in-proc only storage for <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            Supports tracking changed options.
            Options that are not set in the option set are read from global options and cached.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SolutionOptionSet._values">
            <summary>
            Cached values read from global options. Stores internal values of options.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SolutionOptionSet._changedOptionKeys">
            <summary>
            Keys of options whose current value stored in <see cref="F:Microsoft.CodeAnalysis.Options.SolutionOptionSet._values"/> differs from the value originally read from global options.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionStorageMapping">
            <summary>
            Some options store their values in a type that's not accessible publicly.
            The mapping provides translation between the two representations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionStorageMapping.#ctor(Microsoft.CodeAnalysis.Options.IOption2)">
            <summary>
            Some options store their values in a type that's not accessible publicly.
            The mapping provides translation between the two representations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionStorageMapping.InternalOption">
            <summary>
            The option that stores the value internally.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionStorageMapping.ToPublicOptionValue(System.Object)">
            <summary>
            Converts internal option value representation to public.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionStorageMapping.UpdateInternalOptionValue(System.Object,System.Object)">
            <summary>
            Returns a new internal value created by updating <paramref name="currentInternalValue"/> to <paramref name="newPublicValue"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IPublicOption">
            <summary>
            Interface implemented by public options (Option and PerLanguageOption)
            to distinguish them from internal ones (<see cref="T:Microsoft.CodeAnalysis.Options.Option2`1"/> and <see cref="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer.CreateSerializerForEnum``1">
            <summary>
            Creates a serializer for an enum value that uses the enum field names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer.CreateSerializerForEnum``1(Roslyn.Utilities.BidirectionalMap{System.String,``0})">
            <summary>
            Creates a serializer for an enum value given a <paramref name="map"/> between value names and the corresponding enum values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer.CreateSerializerForEnum``1(Roslyn.Utilities.BidirectionalMap{System.String,``0},System.Collections.Immutable.ImmutableDictionary{System.String,``0})">
            <summary>
            Creates a serializer for an enum value given a <paramref name="map"/> between value names and the corresponding enum values.
            <paramref name="alternative"/> specifies alternative value representations for backward compatibility.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer.CreateSerializerForEnum``1(System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,``0}},System.Collections.Generic.IEnumerable{System.ValueTuple{System.String,``0}})">
            <summary>
            Creates a serializer for an enum value given a <paramref name="entries"/> between value names and the corresponding enum values.
            <paramref name="alternativeEntries"/> specifies alternative value representations for backward compatibility.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer`1">
            <summary>
            Specifies that an option should be read from an .editorconfig file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer`1.#ctor(System.Func{System.String,Microsoft.CodeAnalysis.Optional{`0}},System.Func{`0,System.String})">
            <summary>
            Specifies that an option should be read from an .editorconfig file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IEditorConfigValueSerializer.Serialize(System.Object)">
            <summary>
            Gets the editorconfig string representation for the specified <paramref name="value"/>. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOption2">
            <summary>
            Internal base option type that is available in both the Workspaces layer and CodeStyle layer.
            Its definition in Workspaces layer sub-types "IOption" and its definition in CodeStyle layer
            explicitly defines all the members from "IOption" type as "IOption" is not available in CodeStyle layer.
            This ensures that all the sub-types of <see cref="T:Microsoft.CodeAnalysis.Options.IOption2"/> in either layer see an identical
            set of interface members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionGroup">
            <summary>
            Group/sub-feature associated with an option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionGroup.#ctor(System.String,System.String,System.Int32,Microsoft.CodeAnalysis.Options.OptionGroup)">
            <summary>
            Group/sub-feature associated with an option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Parent">
            <summary>
            Optional parent group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Description">
            <summary>
            A localizable resource description string for the option group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Name">
            <summary>
            Name of the option group
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Priority">
            <summary>
            Relative priority of the option group with respect to other option groups within the same feature.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Group">
            <summary>
            Optional group/sub-feature for this option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.ConfigName">
            <summary>
            A unique name of the option used in editorconfig.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.IsEditorConfigOption">
            <summary>
            True if the value of the option may be stored in an editorconfig file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.StorageMapping">
            <summary>
             Mapping between the public option storage and internal option storage.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.DefaultValue">
            <summary>
            The untyped/boxed default value of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionDefinition.Type">
            <summary>
            The type of the option value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ISingleValuedOption">
            <summary>
            Marker interface for options that has the same value for all languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.ISingleValuedOption.LanguageName">
            <summary>
            The language name that supports this option, or null if it's supported by multiple languages.
            </summary>
            <remarks>
            This is an optional metadata used for:
            <list type="bullet">
            <item><description>Analyzer id to option mapping, used (for example) by configure code-style code action</description></item>
            <item><description>EditorConfig UI to determine whether to put this option under <c>[*.cs]</c>, <c>[*.vb]</c>, or <c>[*.{cs,vb}]</c></description></item>
            </list>
            Note that this property is not (and should not be) used for computing option values or storing options.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ISingleValuedOption`1">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Options.ISingleValuedOption"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption">
            <summary>
            Marker interface for <see cref="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1"/>.
            This option may apply to multiple languages, such that the option can have a different value for each language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption`1">
            <inheritdoc cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.PerLanguageOption2`1">
            <summary>
            An option that can be specified once per language.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Packaging.IPackageInstallerService.TryGetPackageSources">
            <summary>
            Attempts to get the package sources applicable to the workspace.  Note: this call is made on a best effort
            basis.  If the results are not available (for example, they have not been computed, and doing so would
            require switching to the UI thread), then an empty array can be returned.
            </summary>
            <returns>
            <para>A collection of package sources.</para>
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher">
            <summary>
            The pattern matcher is not thread-safe.  Do not use the pattern matcher across mutiple threads concurrently.  It
            also keeps an internal cache of data for speeding up operations.  As such, it should be disposed when done to
            release the cached data back. and release the matcher appropriately once you no longer need it. Also, while the
            pattern matcher is culture aware, it uses the culture specified in the constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher">
            <summary>
            Encapsulated matches responsible for matching an all lowercase pattern against
            a candidate using CamelCase matching. i.e. this code is responsible for finding the
            match between "cofipro" and "CodeFixProvider". 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher.#ctor(System.Boolean,System.String,System.String,System.Globalization.TextInfo)">
            <summary>
            Encapsulated matches responsible for matching an all lowercase pattern against
            a candidate using CamelCase matching. i.e. this code is responsible for finding the
            match between "cofipro" and "CodeFixProvider". 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher.TryMatch(Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{Microsoft.CodeAnalysis.Text.TextSpan}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}@)">
            <summary>
            Returns null if no match was found, 1 if a contiguous match was found, 2 if a 
            match as found that starts at the beginning of the candidate, and 3 if a contiguous
            match was found that starts at the beginning of the candidate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher.UpdateBestResultIfBetter(Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.CamelCaseResult,System.Nullable{Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.CamelCaseResult}@,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{Microsoft.CodeAnalysis.Text.TextSpan}@)">
            <summary>
            Updates the currently stored 'best result' if the current result is better.
            Returns 'true' if no further work is required and we can break early, or 
            'false' if we need to keep on going.
            
            If 'weight' is better than 'bestWeight' and matchSpanToAdd is not null, then
            matchSpanToAdd will be added to matchedSpansInReverse.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.#ctor(System.Boolean,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Construct a new PatternMatcher using the specified culture.
            </summary>
            <param name="culture">The culture to use for string searching and comparison.</param>
            <param name="includeMatchedSpans">Whether or not the matching parts of the candidate should be supplied in results.</param>
            <param name="allowFuzzyMatching">Whether or not close matches should count as matches.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.MatchPatternSegment(System.String,Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PatternSegment@,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{Microsoft.CodeAnalysis.PatternMatching.PatternMatch}@,System.Boolean)">
            <summary>
            Internal helper for MatchPatternInternal
            </summary>
            <remarks>
            PERF: Designed to minimize allocations in common cases.
            If there's no match, then null is returned.
            If there's a single match, or the caller only wants the first match, then it is returned (as a Nullable)
            If there are multiple matches, and the caller wants them all, then a List is allocated.
            </remarks>
            <param name="candidate">The word being tested.</param>
            <param name="segment">The segment of the pattern to check against the candidate.</param>
            <param name="matches">The result array to place the matches in.</param>
            <param name="fuzzyMatch">If a fuzzy match should be performed</param>
            <returns>If there's only one match, then the return value is that match. Otherwise it is null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PartStartsWith(System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.Globalization.CompareOptions)">
            <summary>
            Do the two 'parts' match? i.e. Does the candidate part start with the pattern part?
            </summary>
            <param name="candidate">The candidate text</param>
            <param name="candidatePart">The span within the <paramref name="candidate"/> text</param>
            <param name="pattern">The pattern text</param>
            <param name="patternPart">The span within the <paramref name="pattern"/> text</param>
            <param name="compareOptions">Options for doing the comparison (case sensitive or not)</param>
            <returns>True if the span identified by <paramref name="candidatePart"/> within <paramref name="candidate"/> starts with
            the span identified by <paramref name="patternPart"/> within <paramref name="pattern"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PartStartsWith(System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.Globalization.CompareOptions)">
            <summary>
            Does the given part start with the given pattern?
            </summary>
            <param name="candidate">The candidate text</param>
            <param name="candidatePart">The span within the <paramref name="candidate"/> text</param>
            <param name="pattern">The pattern text</param>
            <param name="compareOptions">Options for doing the comparison (case sensitive or not)</param>
            <returns>True if the span identified by <paramref name="candidatePart"/> within <paramref name="candidate"/> starts with <paramref name="pattern"/></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PatternSegment">
            <summary>
            First we break up the pattern given by dots.  Each portion of the pattern between the
            dots is a 'Segment'.  The 'Segment' contains information about the entire section of 
            text between the dots, as well as information about any individual 'Words' that we 
            can break the segment into.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PatternSegment.#ctor(System.String,System.Boolean)">
            <summary>
            First we break up the pattern given by dots.  Each portion of the pattern between the
            dots is a 'Segment'.  The 'Segment' contains information about the entire section of 
            text between the dots, as well as information about any individual 'Words' that we 
            can break the segment into.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.TextChunk">
            <summary>
            Information about a chunk of text from the pattern.  The chunk is a piece of text, with 
            cached information about the character spans within in.  Character spans separate out
            capitalized runs and lowercase runs.  i.e. if you have AAbb, then there will be two 
            character spans, one for AA and one for BB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.TextChunk.PatternHumps">
            <summary>
            Character spans separate out
            capitalized runs and lowercase runs.  i.e. if you have AAbb, then there will be two 
            character spans, one for AA and one for BB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.TextChunk.SimilarityChecker">
            <summary>
            Not readonly as this value caches data within it, and so it needs to be able to mutate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.SimplePatternMatcher.AddMatches(System.String,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{Microsoft.CodeAnalysis.PatternMatching.PatternMatch}@)">
            <summary>
            Determines if a given candidate string matches under a multiple word query text, as you
            would find in features like Navigate To.
            </summary>
            <returns>If this was a match, a set of match types that occurred while matching the
            patterns. If it was not a match, it returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PatternMatching.PatternMatch.Kind">
            <summary>
            The type of match that occurred.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PatternMatching.PatternMatch.IsCaseSensitive">
            <summary>
            True if this was a case sensitive match.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PatternMatching.PatternMatch.MatchedSpans">
            <summary>
            The spans in the original text that were matched.  Only returned if the 
            pattern matcher is asked to collect these spans.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind">
            <summary>
            Note(cyrusn): this enum is ordered from strongest match type to weakest match type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Exact">
            <summary>
            The candidate string matched the pattern exactly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Prefix">
            <summary>
            The pattern was a prefix of the candidate string.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.NonLowercaseSubstring">
            <summary>
            The pattern was a substring of the candidate string, but in a way that wasn't a CamelCase match.  The
            pattern had to have at least one non lowercase letter in it, and the match needs to be case sensitive.
            This will match 'savedWork' against 'FindUnsavedWork'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.StartOfWordSubstring">
            <summary>
            The pattern was a substring of the candidate string, starting at a word within that candidate.  The pattern
            can be all lowercase here.  This will match 'save' or 'Save' in 'FindSavedWork'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseExact">
            <summary>
            All camel-humps in the pattern matched a camel-hump in the candidate.  All camel-humps
            in the candidate were matched by a camel-hump in the pattern.
            
            Example: "CFPS" matching "CodeFixProviderService"
            Example: "cfps" matching "CodeFixProviderService"
            Example: "CoFiPrSe" matching "CodeFixProviderService"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCasePrefix">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern matched the first camel-hump in the candidate.  There was no gap in the camel-
             humps in the candidate that were matched.
            
             Example: "CFP" matching "CodeFixProviderService"
             Example: "cfp" matching "CodeFixProviderService"
             Example: "CoFiPRo" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseNonContiguousPrefix">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern matched the first camel-hump in the candidate.  There was at least one gap in 
             the camel-humps in the candidate that were matched.
            
             Example: "CP" matching "CodeFixProviderService"
             Example: "cp" matching "CodeFixProviderService"
             Example: "CoProv" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseSubstring">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern did not match the first camel-hump in the pattern.  There was no gap in the camel-
             humps in the candidate that were matched.
            
             Example: "FP" matching "CodeFixProviderService"
             Example: "fp" matching "CodeFixProviderService"
             Example: "FixPro" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseNonContiguousSubstring">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern did not match the first camel-hump in the pattern.  There was at least one gap in 
             the camel-humps in the candidate that were matched.
            
             Example: "FS" matching "CodeFixProviderService"
             Example: "fs" matching "CodeFixProviderService"
             Example: "FixSer" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Fuzzy">
            <summary>
            The pattern matches the candidate in a fuzzy manner.  Fuzzy matching allows for 
            a certain amount of misspellings, missing words, etc. See <see cref="T:Roslyn.Utilities.SpellChecker"/> for 
            more details.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.LowercaseSubstring">
            <summary>
            The pattern was a substring of the candidate and wasn't either <see cref="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.NonLowercaseSubstring"/> or <see
            cref="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.StartOfWordSubstring"/>.  This can happen when the pattern is allow lowercases and matches some non
            word portion of the candidate.  For example, finding 'save' in 'GetUnsavedWork'.  This will not match across
            word boundaries.  i.e. it will not match 'save' to 'VisaVerify' even though 'saVe' is in that candidate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeAnalysisProgress">
            <summary>
            Represents the progress of an operation.  Commonly used to update a UI visible to a user when a long running
            operation is happening.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeAnalysisProgress.None">
            <summary>
            Used when bridging from an api that does not show progress to the user to an api that can update progress if
            available.  This should be used sparingly.  Locations that currently do not show progress should ideally be
            migrated to ones that do so that long running operations are visible to the user in a coherent fashion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.Description(System.String)">
            <summary>
            When passed to an appropriate <see cref="T:System.IProgress`1"/>, will updates the UI showing the progress of the
            current operation to the specified <paramref name="description"/>.
            </summary>
            <example>
            progress.Report(CodeAnalysisProgress.Description("Renaming files"));
            </example>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.AddIncompleteItems(System.Int32,System.String)">
            <summary>
            When passed to an appropriate <see cref="T:System.IProgress`1"/>, will add the requested number of incomplete items to
            the UI showing the progress of the current operation.  This is commonly presented with a progress bar.  An
            optional <paramref name="description"/> can also be provided to update the UI accordingly (see <see
            cref="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.Description(System.String)"/>).
            </summary>
            <param name="count">The number of incomplete items left to perform.</param>
            <param name="description">Optional description to update the UI to.</param>
            <example>
            progress.Report(CodeAnalysisProgress.AddIncompleteItems(20));
            </example>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.AddCompleteItems(System.Int32,System.String)">
            <summary>
            When passed to an appropriate <see cref="T:System.IProgress`1"/>, will indicate that some items of work have
            transitioned from being incomplete (see <see cref="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.AddIncompleteItems(System.Int32,System.String)"/> to complete.  This is commonly
            presented with a progress bar. An optional <paramref name="description"/> can also be provided to update the UI
            accordingly (see <see cref="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.Description(System.String)"/>).
            </summary>
            <param name="count">The number of items that were completed. Must be greater than or equal to 1.</param>
            <param name="description">Optional description to update the UI to.</param>
            <example>
            progress.Report(CodeAnalysisProgress.CompleteItem());
            </example>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.Clear">
            <summary>
            When passed to an appropriate <see cref="T:System.IProgress`1"/>, will indicate that all progress should be reset for
            the current operation. This is normally done when the code action is performing some new phase and wishes for
            the UI progress bar to restart from the beginning.
            </summary>
            <remarks>
            Currently internal as only roslyn needs this in the impl of our suggested action (we use a progress bar to
            compute the work, then reset the progress to apply all the changes).  Could be exposed later to 3rd party code
            if a demonstrable need is presented.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ReassignedVariable.IReassignedVariableService">
            <summary>
            Service which can analyze a span of a document and identify all locations of parameters or locals that are ever
            reassigned.  Note that the locations provided are not the reassignment points.  Rather if a local or parameter
            is ever reassigned, these are all the locations of those locals or parameters within that span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationService`2.AbstractRecommendationServiceRunner.GetTypeSymbols(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Tries to get a type of its' <paramref name="ordinalInLambda"/> lambda parameter of <paramref name="ordinalInInvocation"/> argument for each candidate symbol.
            </summary>
            <param name="candidateSymbols">symbols corresponding to <see cref="T:System.Linq.Expressions.Expression`1"/> or <see cref="T:System.Func`2"/>
            Here, some_args can be multi-variables lambdas as well, e.g. f((a,b) => a+b, (a,b,c)=>a*b*c.Length)
            </param>
            <param name="ordinalInInvocation">ordinal of the arguments of function: (a,b) or (a,b,c) in the example above</param>
            <param name="ordinalInLambda">ordinal of the lambda parameters, e.g. a, b or c.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationService`2.AbstractRecommendationServiceRunner.SuppressDefaultTupleElements(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            If container is a tuple type, any of its tuple element which has a friendly name will cause the suppression
            of the corresponding default name (ItemN). In that case, Rest is also removed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Recommendations.RecommendedSymbols.NamedSymbols">
            <summary>
            The named symbols to recommend.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Recommendations.RecommendedSymbols.UnnamedSymbols">
            <summary>
            The unnamed symbols to recommend.  For example, operators, conversions and indexers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.IRemoteHostClientProvider">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient"/> that a user can use to communicate with a remote host (i.e. ServiceHub) 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostClientProvider.TryGetRemoteHostClientAsync(System.Threading.CancellationToken)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient"/> to current RemoteHost
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostClientProvider.WaitForClientCreationAsync(System.Threading.CancellationToken)">
            <summary>
            Allows a caller to wait until the remote host client is is first create, without itself kicking off the work to
            spawn the remote host and make the client itself.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.IRemoteHostClientShutdownCancellationService.ShutdownToken">
            <summary>
            Token signaled when the host starts to shut down.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteKeepAliveService.KeepAliveAsync(Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Keeps alive this solution in the OOP process until the cancellation token is triggered.  Used so that long
            running features (like 'inline rename' or 'lightbulbs') we can call into oop several times, with the same
            snapshot, knowing that things will stay hydrated and alive on the OOP side.  Importantly, by keeping the
            same <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot alive on the OOP side, computed attached values (like <see
            cref="T:Microsoft.CodeAnalysis.Compilation"/>s) will stay alive as well.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteKeepAliveSession.Create(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener)">
            <summary>
            Creates a session between the host and OOP, effectively pinning this <paramref name="solution"/> until <see
            cref="M:System.IDisposable.Dispose"/> is called on it.  By pinning the solution we ensure that all calls to OOP for
            the same solution during the life of this session do not need to resync the solution.  Nor do they then need
            to rebuild any compilations they've already built due to the solution going away and then coming back.
            </summary>
            <remarks>
            The <paramref name="listener"/> is not strictly necessary for this type.  This class functions just as an
            optimization to hold onto data so it isn't resync'ed or recomputed.  However, we still want to let the
            system know when unobserved async work is kicked off in case we have any tooling that keep track of this for
            any reason (for example for tracking down problems in testing scenarios).
            </remarks>
            <remarks>
            This synchronous entrypoint should be used only in contexts where using the async <see
            cref="M:Microsoft.CodeAnalysis.Remote.RemoteKeepAliveSession.CreateAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/> is not possible (for example, in a constructor).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteKeepAliveSession.CreateAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Creates a session between the host and OOP, effectively pinning this <paramref name="solution"/> until <see
            cref="M:System.IDisposable.Dispose"/> is called on it.  By pinning the solution we ensure that all calls to OOP for
            the same solution during the life of this session do not need to resync the solution.  Nor do they then need
            to rebuild any compilations they've already built due to the solution going away and then coming back.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteKeepAliveSession.CreateAsync(Microsoft.CodeAnalysis.SolutionCompilationState,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Remote.RemoteKeepAliveSession.CreateAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient">
            <summary>
            This represents client in client/server model.
            
            user can create a connection to communicate with the server (remote host) through this client
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``1(Microsoft.CodeAnalysis.Project,System.Func{``0,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)">
            <summary>
            Equivalent to <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``1(Microsoft.CodeAnalysis.Solution,System.Func{``0,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)"/>
            except that only the project (and its dependent projects) will be sync'ed to the remote host before executing.
            This is useful for operations that don't every do any work outside of that project-cone and do not want to pay
            the high potential cost of a full sync.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``2(Microsoft.CodeAnalysis.Project,System.Func{``0,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Threading.CancellationToken)">
            <summary>
            Equivalent to <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``1(Microsoft.CodeAnalysis.Solution,System.Func{``0,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Threading.CancellationToken)"/>
            except that only the project (and its dependent projects) will be sync'ed to the remote host before executing.
            This is useful for operations that don't every do any work outside of that project-cone and do not want to pay
            the high potential cost of a full sync.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``1(Microsoft.CodeAnalysis.Project,System.Func{``0,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Object,System.Threading.CancellationToken)">
            <summary>
            Equivalent to <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``1(Microsoft.CodeAnalysis.Solution,System.Func{``0,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Object,System.Threading.CancellationToken)"/>
            except that only the project (and its dependent projects) will be sync'ed to the remote host before executing.
            This is useful for operations that don't every do any work outside of that project-cone and do not want to pay
            the high potential cost of a full sync.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``2(Microsoft.CodeAnalysis.Project,System.Func{``0,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Object,System.Threading.CancellationToken)">
            <summary>
            Equivalent to <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryInvokeAsync``1(Microsoft.CodeAnalysis.Solution,System.Func{``0,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Object,System.Threading.CancellationToken)"/>
            except that only the project (and its dependent projects) will be sync'ed to the remote host before executing.
            This is useful for operations that don't every do any work outside of that project-cone and do not want to pay
            the high potential cost of a full sync.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteOptionsProvider`1">
            <summary>
            Client-side object that is called back from the server when options for a certain language are required.
            Can be used when the remote API does not have an existing callback. If it does it can implement 
            <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteOptionsProvider`1.GetOptionsAsync(System.String,System.Threading.CancellationToken)"/> itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteOptionsProvider`1.#ctor(Microsoft.CodeAnalysis.Host.SolutionServices,Microsoft.CodeAnalysis.OptionsProvider{`0})">
            <summary>
            Client-side object that is called back from the server when options for a certain language are required.
            Can be used when the remote API does not have an existing callback. If it does it can implement 
            <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteOptionsProvider`1.GetOptionsAsync(System.String,System.Threading.CancellationToken)"/> itself.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteServiceConnection`1">
            <summary>
            Abstracts a connection to a service implementing type <typeparamref name="TService"/>.
            </summary>
            <typeparam name="TService">Remote interface type of the service.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteUtilities.GetDocumentTextChangesAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given two solution snapshots (<paramref name="oldSolution"/> and <paramref name="newSolution"/>), determines
            the set of document text changes necessary to convert <paramref name="oldSolution"/> to <paramref
            name="newSolution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteUtilities.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChange}}},System.Threading.CancellationToken)">
            <summary>
            Applies the result of <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteUtilities.GetDocumentTextChangesAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/> to <paramref name="oldSolution"/> to produce
            a solution textually equivalent to the <c>newSolution</c> passed to <see cref="M:Microsoft.CodeAnalysis.Remote.RemoteUtilities.GetDocumentTextChangesAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteProcessTelemetryService.EnableLoggingAsync(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Internal.Log.FunctionId},System.Threading.CancellationToken)">
            <summary>
            Enables logging of <paramref name="functionIds"/> using loggers of the specified <paramref name="loggerTypeNames"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteProcessTelemetryService.InitializeTelemetrySessionAsync(System.Int32,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Initializes telemetry session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteProcessTelemetryService.InitializeAsync(Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions,System.Threading.CancellationToken)">
            <summary>
            Sets <see cref="T:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions"/> for the process.
            Called as soon as the remote process is created but can't guarantee that solution entities (projects, documents, syntax trees) have not been created beforehand.
            </summary>
            <returns>Process ID of the remote process.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.IOptionsSerializationService">
            <summary>
            This deal with serializing/deserializing language specific data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ISupportTemporaryStorage">
            <summary>
            Interface for services that support dumping their contents to memory-mapped-files (generally speaking, our assembly
            reference objects).  This allows those objects to expose the memory-mapped-file info needed to read that data back
            in in any process.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.SerializableSourceText">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> which can be serialized for sending to another process. The text is not
            required to be a live object in the current process, and can instead be held in temporary storage accessible by
            both processes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._storageHandle">
            <summary>
            The storage location for <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
            <remarks>
            Exactly one of <see cref="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._storageHandle"/> or <see cref="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._text"/> will be non-<see langword="null"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._text">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> in the current process.
            </summary>
            <remarks>
            <inheritdoc cref="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._storageHandle"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._computedText">
            <summary>
            Weak reference to a SourceText computed from <see cref="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText._storageHandle"/>.  Useful so that if multiple requests
            come in for the source text, the same one can be returned as long as something is holding it alive.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText.ContentChecksum">
            <summary>
            Checksum of the contents (see <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetContentHash"/>) of the text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.SerializableSourceText.TryGetText">
            <summary>
            Returns the strongly referenced SourceText if we have it, or tries to retrieve it from the weak reference if
            it's still being held there.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.SerializableSourceText.SerializableSourceTextLoader">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.TextLoader"/> that wraps a <see cref="F:Microsoft.CodeAnalysis.Serialization.SerializableSourceText.SerializableSourceTextLoader.SerializableSourceText"/> and provides access to the text in
            a deferred fashion.  In practice, during a host and OOP sync, while all the documents will be 'serialized' over
            to OOP, the actual contents of the documents will only need to be loaded depending on which files are open, and
            thus what compilations and trees are needed.  As such, we want to be able to lazily defer actually getting the
            contents of the text until it's actually needed.  This loader allows us to do that, allowing the OOP side to
            simply point to the segments in the memory-mapped-file the host has dumped its text into, and only actually
            realizing the real text values when they're needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Serialization.SerializableSourceText.SerializableSourceTextLoader.AlwaysHoldStrongly">
            <summary>
            Documents should always hold onto instances of this text loader strongly.  In other words, they should load
            from this, and then dump the contents into a RecoverableText object that then dumps the contents to a memory
            mapped file within this process.  Doing that is pointless as the contents of this text are already in a
            memory mapped file on the host side.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.SerializerService">
            <summary>
            serialize and deserialize objects to stream.
            some of these could be moved into actual object, but putting everything here is a bit easier to find I believe.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.SerializerService.s_analyzerImageReferenceMapGate">
            <summary>
            Allow analyzer tests to exercise the oop codepaths, even though they're referring to in-memory instances of
            DiagnosticAnalyzers.  In that case, we'll just share the in-memory instance of the analyzer across the OOP
            boundary (which still runs in proc in tests), but we will still exercise all codepaths that use the RemoteClient
            as well as exercising all codepaths that send data across the OOP boundary.  Effectively, this allows us to
            pretend that a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference"/> is a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference"/> during tests.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.AssetPath">
            <summary>
            Required information passed with an asset synchronization request to tell the host where to scope the request to. In
            particular, this is often used to scope to a particular <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Document"/> to avoid
            having to search the entire solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPath.FullLookupForTesting">
            <summary>
            Special instance, allowed only in tests/debug-asserts, that can do a full lookup across the entire checksum
            tree.  Should not be used in normal release-mode product code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPath.ProjectId">
            <summary>
            If not null, the search should only descend into the single project with this id.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPath.DocumentId">
            <summary>
            If not null, the search should only descend into the single document with this id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.AssetPath.op_Implicit(Microsoft.CodeAnalysis.ProjectId)~Microsoft.CodeAnalysis.Serialization.AssetPath">
            <summary>
            Searches only for information about this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.AssetPath.op_Implicit(Microsoft.CodeAnalysis.DocumentId)~Microsoft.CodeAnalysis.Serialization.AssetPath">
            <summary>
            Searches only for information about this document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.AssetPath.SolutionAndProjectForTesting(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Searches the requested project, and all documents underneath it.  Used only in tests.
            </summary>
            <param name="projectId"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.AssetPath.DocumentsInProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Searches all documents within the specified project.
            </summary>
            <param name="projectId"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPathKind.SolutionCompilationState">
            <summary>
            Search solution-compilation-state level information.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPathKind.SolutionState">
            <summary>
            Search solution-state level information.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPathKind.Projects">
            <summary>
            Search projects for results.  All project-level information will be searched.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Serialization.AssetPathKind.Documents">
            <summary>
            Search documents for results.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ChecksumCollection">
            <summary>
            A wrapper around an array of <see cref="T:Microsoft.CodeAnalysis.Checksum"/>s, which also combines the value into a
            single aggregate checksum exposed through <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Checksum"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Checksum})">
            <summary>
            A wrapper around an array of <see cref="T:Microsoft.CodeAnalysis.Checksum"/>s, which also combines the value into a
            single aggregate checksum exposed through <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Checksum"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Checksum">
            <summary>
            Aggregate checksum produced from all the constituent checksums in <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Children"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.GetEnumerator">
            <summary>
            Enumerates the child checksums (found in <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Children"/>) that make up this collection.   This is
            equivalent to directly enumerating the <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Children"/> property.  Importantly, <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Checksum"/> is
            not part of this enumeration.  <see cref="P:Microsoft.CodeAnalysis.Serialization.ChecksumCollection.Checksum"/> is the checksum <em>produced</em> by all those child
            checksums.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ProjectChecksumsAndIds">
            <summary>
            A paired list of <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>s, and the checksums for their corresponding <see
            cref="T:Microsoft.CodeAnalysis.Serialization.ProjectStateChecksums"/>'s <see cref="P:Microsoft.CodeAnalysis.Serialization.ProjectStateChecksums.Checksum"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.DocumentChecksumsAndIds">
            <summary>
            A paired list of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s, and the checksums for their corresponding <see
            cref="T:Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums"/>'s <see cref="P:Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums.Info"/> and <see
            cref="P:Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums.Text"/> checksums.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Serialization.SolutionCompilationStateChecksums.FrozenSourceGeneratedDocuments">
            <summary>
            Checksums of the SourceTexts of the frozen documents directly.  Not checksums of their DocumentStates.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.SolutionStateChecksums">
            <param name="projectConeId">The particular <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> if this was a checksum tree made for a particular
            project cone.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Serialization.SolutionStateChecksums.#ctor(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Serialization.ProjectChecksumsAndIds,Microsoft.CodeAnalysis.Serialization.ChecksumCollection,Microsoft.CodeAnalysis.Checksum)">
            <param name="projectConeId">The particular <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> if this was a checksum tree made for a particular
            project cone.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ChecksumCache">
            <summary>
            hold onto object checksum that currently doesn't have a place to hold onto checksum
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictingIdentifierTracker._currentIdentifiersInScope">
            <summary>
            The core data structure of the tracker. This is a dictionary of variable name to the
            current identifier tokens that are declaring variables. This should only ever be updated
            via the AddIdentifier and RemoveIdentifier helpers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveLightweightConflictsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Rename.LightweightRenameLocations,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolKey},System.Threading.CancellationToken)">
            <summary>
            Performs the renaming of the symbol in the solution, identifies renaming conflicts and automatically
            resolves them where possible.
            </summary>
            <param name="replacementText">The new name of the identifier</param>
            <param name="nonConflictSymbolKeys">Used after renaming references. References that now bind to any of these
            symbols are not considered to be in conflict. Useful for features that want to rename existing references to
            point at some existing symbol. Normally this would be a conflict, but this can be used to override that
            behavior.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A conflict resolution containing the new solution.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveSymbolicLocationConflictsInCurrentProcessAsync(Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolKey},System.Threading.CancellationToken)">
            <summary>
            Finds any conflicts that would arise from using <paramref name="replacementText"/> as the new name for a
            symbol and returns how to resolve those conflicts.  Will not cross any process boundaries to do this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.SymbolsForEnclosingInvocationExpressionWorker(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Used to find the symbols associated with the Invocation Expression surrounding the Token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.AddDeclarationConflictsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location},System.Threading.CancellationToken)">
            <summary>
            Computes an adds conflicts relating to declarations, which are independent of
            location-based checks. Examples of these types of conflicts include renaming a member to
            the same name as another member of a type: binding doesn't change (at least from the
            perspective of find all references), but we still need to track it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.GetSymbolLocationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gives the First Location for a given Symbol by ordering the locations using DocumentId first and Location starting position second
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session">
            <summary>
            Helper class to track the state necessary for finding/resolving conflicts in a 
            rename session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.IdentifyConflictsAsync(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DocumentId},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.ConflictLocationInfo})">
            <summary>
            Find conflicts in the new solution 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.GetNodesOrTokensToCheckForConflicts(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of the nodes that were annotated for a conflict check 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.FindDocumentsAndPossibleNameConflictsAsync">
            <summary>
            The method determines the set of documents that need to be processed for Rename and also determines
            the possible set of names that need to be checked for conflicts.
            The list will contains Strings like Bar -> BarAttribute ; Property Bar -> Bar , get_Bar, set_Bar
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.ShouldIncludeLocation(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.RenameLocation},Microsoft.CodeAnalysis.Rename.RenameLocation)">
            We try to rewrite all locations that are invalid candidate locations. If there is only
            one location it must be the correct one (the symbol is ambiguous to something else)
            and we always try to rewrite it.  If there are multiple locations, we only allow it
            if the candidate reason allows for it).
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.GetSubSpansToRenameInStringAndCommentTextSpans(Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Rename.RenameLocation})">
            <summary>
            We try to compute the sub-spans to rename within the given <paramref name="containingLocationForStringOrComment"/>.
            If we are renaming within a string, the locations to rename are always within this containing string location
            and we can identify these sub-spans.
            However, if we are renaming within a comment, the rename locations can be anywhere in trivia,
            so we return null and the rename rewriter will perform a complete regex match within comment trivia
            and rename all matches instead of specific matches.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution">
            <summary>
            The result of the conflict engine. Can be made immutable by calling <see cref="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.ToConflictResolution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.#ctor(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker,System.String,System.Boolean)">
            <summary>
            The result of the conflict engine. Can be made immutable by calling <see cref="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.ToConflictResolution"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.OldSolution">
            <summary>
            The base workspace snapshot
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.ReplacementTextValid">
            <summary>
            Whether the text that was resolved with was even valid. This may be false if the
            identifier was not valid in some language that was involved in the rename.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.ReplacementText">
            <summary>
            The original text that is the rename replacement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution.CurrentSolution">
            <summary>
            The solution snapshot as it is being updated with specific rename steps.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation">
            <summary>
            Gives information about an identifier span that was affected by Rename (Reference or Non reference)
            </summary>
            <param name="ConflictCheckSpan">
            The Span of the original identifier if it was in source, otherwise the span to check for implicit
            references.
            </param>
            <param name="ComplexifiedTargetSpan">
            If there was a conflict at ConflictCheckSpan during rename, then the next phase in rename uses
            ComplexifiedTargetSpan span to be expanded to resolve the conflict.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType,System.Boolean,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gives information about an identifier span that was affected by Rename (Reference or Non reference)
            </summary>
            <param name="ConflictCheckSpan">
            The Span of the original identifier if it was in source, otherwise the span to check for implicit
            references.
            </param>
            <param name="ComplexifiedTargetSpan">
            If there was a conflict at ConflictCheckSpan during rename, then the next phase in rename uses
            ComplexifiedTargetSpan span to be expanded to resolve the conflict.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation.ConflictCheckSpan">
            <summary>
            The Span of the original identifier if it was in source, otherwise the span to check for implicit
            references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation.ComplexifiedTargetSpan">
            <summary>
            If there was a conflict at ConflictCheckSpan during rename, then the next phase in rename uses
            ComplexifiedTargetSpan span to be expanded to resolve the conflict.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.NoConflict">
            <summary>
            There was no conflict. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.ResolvedReferenceConflict">
            <summary>
            A conflict was resolved at a location that references the symbol being renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.ResolvedNonReferenceConflict">
            <summary>
            A conflict was resolved in a piece of code that does not reference the symbol being
            renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.PossiblyResolvableConflict">
            <summary>
            There was a conflict that could not be resolved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.UnresolvableConflict">
            <summary>
            These are the conflicts that cannot be resolved. E.g.: Declaration Conflict
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker">
            <summary>
            Tracks the text spans that were modified as part of a rename operation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker.MutableComplexifiedSpan">
            <summary>
            Information to track deltas of complexified spans
            
            Consider the following example where renaming a->b causes a conflict 
            and Goo is an extension method:
                "a.Goo(a)" is rewritten to "NS1.NS2.Goo(NS3.a, NS3.a)"
            
            The OriginalSpan is the span of "a.Goo(a)"
            
            The NewSpan is the span of "NS1.NS2.Goo(NS3.a, NS3.a)"
            
            The ModifiedSubSpans are the pairs of complexified symbols sorted 
            according to their order in the original source code span:
                "a", "NS3.a"
                "Goo", "NS1.NS2.Goo"
                "a", "NS3.a"
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker.MutableComplexifiedSpan.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.List{System.ValueTuple{Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan}})">
            <summary>
            Information to track deltas of complexified spans
            
            Consider the following example where renaming a->b causes a conflict 
            and Goo is an extension method:
                "a.Goo(a)" is rewritten to "NS1.NS2.Goo(NS3.a, NS3.a)"
            
            The OriginalSpan is the span of "a.Goo(a)"
            
            The NewSpan is the span of "NS1.NS2.Goo(NS3.a, NS3.a)"
            
            The ModifiedSubSpans are the pairs of complexified symbols sorted 
            according to their order in the original source code span:
                "a", "NS3.a"
                "Goo", "NS1.NS2.Goo"
                "a", "NS3.a"
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation">
            <summary>
            This annotation will be used by rename to mark all places where it needs to rename an identifier (token replacement) and where to 
            check if the semantics have been changes (conflict detection).
            </summary>
            <remarks>This annotation should be put on tokens only.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.#ctor(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.String,System.String,System.Boolean,Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            This annotation will be used by rename to mark all places where it needs to rename an identifier (token replacement) and where to 
            check if the semantics have been changes (conflict detection).
            </summary>
            <remarks>This annotation should be put on tokens only.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.OriginalSpan">
            <summary>
            The span this token occupied in the original syntax tree. Can be used to show e.g. conflicts in the UI.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsRenameLocation">
            <summary>
            A flag indicating whether this is a location that needs to be renamed or just tracked for conflicts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsOriginalTextLocation">
            <summary>
            A flag indicating whether the token at this location has the same ValueText then the original name 
            of the symbol that gets renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Prefix">
            <summary>
            When replacing the annotated token this string will be prepended to the token's value. This is used when renaming compiler 
            generated fields and methods backing properties (e.g. "get_X" or "_X" for property "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Suffix">
            <summary>
            When replacing the annotated token this string will be appended to the token's value. This is used when renaming compiler 
            generated types whose names are derived from user given names (e.g. "XEventHandler" for event "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.RenameDeclarationLocationReferences">
            <summary>
            A single dimensional array of annotations to verify after rename.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsNamespaceDeclarationReference">
            <summary>
            States if this token is a Namespace Declaration Reference
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsMemberGroupReference">
            <summary>
            States if this token is a member group reference, typically found in NameOf expressions
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsInvocationExpression">
            <summary>
            States if this token is annotated as a part of the Invocation Expression that needs to be checked for the Conflicts
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference">
            <summary>
            This class is used to refer to a Symbol definition which could be in source or metadata
            it has a metadata name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.Name">
            <summary>
            The metadata name for this symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.SymbolLocationsCount">
            <summary>
            Count of symbol location (Partial Types, Constructors, etc).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.IsOverriddenFromMetadata">
            <summary>
            A flag indicating that the associated symbol is an override of a symbol from metadata
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictResolution.IsSuccessful">
            <summary>
            A flag indicate if the rename operation is successful or not.
            If this is false, the <see cref="F:Microsoft.CodeAnalysis.Rename.ConflictResolution.ErrorMessage"/> would be with this resolution. All the other field or property would be <see langword="null"/> or empty.
            If this is true, the <see cref="F:Microsoft.CodeAnalysis.Rename.ConflictResolution.ErrorMessage"/> would be null. All the other fields or properties would be valid.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictResolution.NewSolution">
            <summary>
            The final solution snapshot.  Including any renamed documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictResolution.DocumentIds">
            <summary>
            The list of all document ids of documents that have been touched for this rename operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRemoteRenamerService.RenameSymbolAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId,System.String,Microsoft.CodeAnalysis.Rename.SymbolRenameOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolKey},System.Threading.CancellationToken)">
            <summary>
            Runs the entire rename operation OOP and returns the final result. More efficient (due to less back and
            forth marshaling) when the intermediary results of rename are not needed. To get the individual parts of
            rename remoted use <see cref="M:Microsoft.CodeAnalysis.Rename.IRemoteRenamerService.FindRenameLocationsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId,Microsoft.CodeAnalysis.Rename.SymbolRenameOptions,System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.Rename.IRemoteRenamerService.ResolveConflictsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId,Microsoft.CodeAnalysis.Rename.SerializableRenameLocations,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SymbolKey},System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.LightweightRenameLocations">
            <summary>
            Equivalent to <see cref="T:Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations"/> except that references to symbols are kept in a lightweight fashion
            to avoid expensive rehydration steps as a host and OOP communicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.LightweightRenameLocations.FindRenameLocationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Rename.SymbolRenameOptions,System.Threading.CancellationToken)">
            <summary>
            Find the locations that need to be renamed.  Can cross process boundaries efficiently to do this.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations">
            <summary>
            Holds the Locations of a symbol that should be renamed, along with the symbol and Solution for the set. It is
            considered 'heavy weight' because it holds onto large entities (like Symbols) and thus should not be marshaled
            to/from a host to OOP.
            </summary>
            <summary>
            A helper class that contains some of the methods and filters that must be used when
            processing the raw results from the FindReferences API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations.FindLocationsInCurrentProcessAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Rename.SymbolRenameOptions,System.Threading.CancellationToken)">
            <summary>
            Attempts to find all the locations to rename.  Will not cross any process boundaries to do this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations.ReferenceProcessing.GetRenamableDefinitionLocationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given a ISymbol, returns the renameable locations for a given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.AnnotateAndRename(Microsoft.CodeAnalysis.Rename.RenameRewriterParameters)">
            <summary>
            This method annotates the given syntax tree with all the locations that need to be checked for conflict
            after the rename operation.  It also renames all the reference locations and expands any conflict locations.
            </summary>
            <param name="parameters">The options describing this rename operation</param>
            <returns>The root of the annotated tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.TryAddPossibleNameConflicts(Microsoft.CodeAnalysis.ISymbol,System.String,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Based on the kind of the symbol and the new name, this function determines possible conflicting names that
            should be tracked for semantic changes during rename.
            </summary>
            <param name="symbol">The symbol that gets renamed.</param>
            <param name="newName">The new name for the symbol.</param>
            <param name="possibleNameConflicts">List where possible conflicting names will be added to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputeDeclarationConflictsAsync(System.String,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location},System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by the new declaration created during rename.
            </summary>
            <param name="replacementText">The replacementText as given from the user.</param>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="renameSymbol">The original symbol that got renamed.</param>
            <param name="referencedSymbols">All referenced symbols that are part of this rename session.</param>
            <param name="baseSolution">The original solution when rename started.</param>
            <param name="newSolution">The resulting solution after rename.</param>
            <param name="reverseMappedLocations">A mapping from new to old locations.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>All locations where conflicts were caused because the new declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputeImplicitReferenceConflictsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation},System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by implicitly referencing the renamed symbol.
            </summary>
            <param name="renameSymbol">The original symbol that got renamed.</param>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="implicitReferenceLocations">All implicit reference locations.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A list of implicit conflicts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputePossibleImplicitUsageConflicts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Location,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by implicitly referencing the renamed symbol.
            </summary>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="semanticModel">The SemanticModel of the document in the new solution containing the renamedSymbol</param>
            <param name="originalDeclarationLocation">The location of the renamedSymbol in the old solution</param>
            <param name="newDeclarationLocationStartingPosition">The starting position of the renamedSymbol in the new solution</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A list of implicit conflicts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.LocalVariableConflict(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Identifies potential Conflicts into the inner scope locals. This may give false positives.
            </summary>
            <param name="token">The Token that may introduce errors else where</param>
            <param name="newReferencedSymbols">The symbols that this token binds to after the rename
            has been applied</param>
            <returns>Returns if there is a potential conflict</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.IsIdentifierValid(System.String,Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService)">
            <summary>
            Used to find if the replacement Identifier is valid
            </summary>
            <param name="replacementText"></param>
            <param name="syntaxFactsService"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.GetExpansionTargetForLocation(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the top most enclosing statement as target to call MakeExplicit on.
            It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing
            statement of this lambda.
            </summary>
            <param name="token">The token to get the complexification target for.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.RenameEntityKind.BaseSymbol">
            <summary>
            mentions that the result is for the base symbol of the rename
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.RenameEntityKind.OverloadedSymbols">
            <summary>
            mentions that the result is for the overloaded symbols of the rename
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.SymbolRenameOptions">
            <summary>
            Options for renaming a symbol.
            </summary>
            <param name="RenameOverloads">If the symbol is a method rename its overloads as well.</param>
            <param name="RenameInStrings">Rename identifiers in string literals that match the name of the symbol.</param>
            <param name="RenameInComments">Rename identifiers in comments that match the name of the symbol.</param>
            <param name="RenameFile">If the symbol is a type renames the file containing the type declaration as well.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.SymbolRenameOptions.#ctor(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Options for renaming a symbol.
            </summary>
            <param name="RenameOverloads">If the symbol is a method rename its overloads as well.</param>
            <param name="RenameInStrings">Rename identifiers in string literals that match the name of the symbol.</param>
            <param name="RenameInComments">Rename identifiers in comments that match the name of the symbol.</param>
            <param name="RenameFile">If the symbol is a type renames the file containing the type declaration as well.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.SymbolRenameOptions.RenameOverloads">
            <summary>If the symbol is a method rename its overloads as well.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.SymbolRenameOptions.RenameInStrings">
            <summary>Rename identifiers in string literals that match the name of the symbol.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.SymbolRenameOptions.RenameInComments">
            <summary>Rename identifiers in comments that match the name of the symbol.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.SymbolRenameOptions.RenameFile">
            <summary>If the symbol is a type renames the file containing the type declaration as well.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.DocumentRenameOptions">
            <summary>
            Options for renaming a document.
            </summary>
            <param name="RenameMatchingTypeInStrings">If the document contains a type declaration with matching name rename identifiers in strings that match the name as well.</param>
            <param name="RenameMatchingTypeInComments">If the document contains a type declaration with matching name rename identifiers in comments that match the name as well.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.DocumentRenameOptions.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Options for renaming a document.
            </summary>
            <param name="RenameMatchingTypeInStrings">If the document contains a type declaration with matching name rename identifiers in strings that match the name as well.</param>
            <param name="RenameMatchingTypeInComments">If the document contains a type declaration with matching name rename identifiers in comments that match the name as well.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.DocumentRenameOptions.RenameMatchingTypeInStrings">
            <summary>If the document contains a type declaration with matching name rename identifiers in strings that match the name as well.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.DocumentRenameOptions.RenameMatchingTypeInComments">
            <summary>If the document contains a type declaration with matching name rename identifiers in comments that match the name as well.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Rename.DocumentRenameOptions,System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Threading.CancellationToken)">
             <summary>
             Call to perform a rename of document or change in document folders. Returns additional code changes related to the document
             being modified, such as renaming symbols in the file. 
            
             Each change is added as a <see cref="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction"/> in the returned <see cref="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions" />.
             
             Each action may individually encounter errors that prevent it from behaving correctly. Those are reported in <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction.GetErrors(System.Globalization.CultureInfo)"/>.
             
             <para />
             
             Current supported actions that may be returned: 
             <list>
              <item>Rename symbol action that will rename the type to match the document name.</item>
              <item>Sync namespace action that will sync the namespace(s) of the document to match the document folders. </item>
             </list>
             
             </summary>
             <param name="document">The document to be modified</param>
             <param name="newDocumentName">The new name for the document. Pass null or the same name to keep unchanged.</param>
             <param name="options">Options used to configure rename of a type contained in the document that matches the document's name.</param>
             <param name="newDocumentFolders">The new set of folders for the <see cref="P:Microsoft.CodeAnalysis.TextDocument.Folders"/> property</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.FindRenameLocationsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Rename.SymbolRenameOptions,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Rename.LightweightRenameLocations.FindRenameLocationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Rename.SymbolRenameOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction">
            <summary>
            Individual action from RenameDocument APIs in <see cref="T:Microsoft.CodeAnalysis.Rename.Renamer"/>. Represents
            changes that will be done to one or more document contents to help facilitate
            a smooth experience while moving documents around.
            
            See <see cref="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet" /> on use case and how to apply them to a solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction.GetErrors(System.Globalization.CultureInfo)">
            <summary>
            Get any errors that have been noted for this action before it is applied.
            Can be used to present to a user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction.GetDescription(System.Globalization.CultureInfo)">
            <summary>
            Gets the description of the action. Can be used to present to a user to describe
            what extra actions will be taken.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet">
            <summary>
            Information about rename document calls that allows them to be applied as individual actions. Actions are individual units of work
            that can change the contents of one or more document in the solution. Even if the <see cref="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions"/> is empty, the 
            document metadata will still be updated by calling <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction},System.Threading.CancellationToken)"/>
            <para />
            To apply all actions use <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)"/>, or use a subset
            of the actions by calling <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction},System.Threading.CancellationToken)"/>. 
            Actions can be applied in any order.
            Each action has a description of the changes that it will apply that can be presented to a user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions">
            <summary>
            All applicable actions computed for the action. Action set may be empty, which represents updates to document 
            contents rather than metadata. Document metadata will still not be updated unless <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction},System.Threading.CancellationToken)" /> 
            is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Same as calling <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction},System.Threading.CancellationToken)"/> with 
            <see cref="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions"/> as the argument
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction},System.Threading.CancellationToken)">
            <summary>
            Applies each <see cref="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction"/> in order and returns the final solution. 
            All actions must be contained in <see cref="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions" />
            </summary>
            <remarks>
            An empty action set is still allowed and will return a modified solution
            that will update the document properties as appropriate. This means we 
            can still support when <see cref="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions"/> is empty. It's desirable
            that consumers can call a rename API to produce a <see cref="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet"/> and
            immediately call <see cref="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.UpdateSolutionAsync(Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentAction},System.Threading.CancellationToken)"/> without
            having to inspect the returned <see cref="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.ApplicableActions"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameDocumentActionSet.GetDocument(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Attempts to find the document in the solution. Tries by documentId first, but 
            that's not always reliable between analysis and application of the rename actions
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.Renamer.RenameSymbolDocumentAction">
            <summary>
            Action that will rename a type to match the current document name. Works by finding a type matching the origanl name of the document (case insensitive) 
            and updating that type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.Renamer.RenameSymbolDocumentAction.GetMatchingTypeDeclarationAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Finds a matching type such that the display name of the type matches the name passed in, ignoring case. Case isn't used because
            documents with name "Foo.cs" and "foo.cs" should still have the same type name
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameSymbolDocumentAction.AnalysisResult.OriginalDocumentName">
            <summary>
            Name of the document that the action was produced for.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameSymbolDocumentAction.AnalysisResult.NewDocumentName">
            <summary>
            The new document name that will be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameSymbolDocumentAction.AnalysisResult.OriginalSymbolName">
            <summary>
            The original name of the symbol that will be changed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.Renamer.RenameSymbolDocumentAction.AnalysisResult.NewSymbolName">
            <summary>
            The new name for the symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.Renamer.SyncNamespaceDocumentAction">
            <summary>
            Action that will sync the namespace of the document to match the folders property 
            of that document, similar to if a user performed the "Sync Namespace" code refactoring.
            
            For example, if a document is moved from "Bat/Bar/Baz" folder structure to "Bat/Bar/Baz/Bat" and contains
            a namespace definition of Bat.Bar.Baz in the document, then it would update that definition to 
            Bat.Bar.Baz.Bat and update the solution to reflect these changes. Uses <see cref="T:Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameUtilities.ShouldRenameOnlyAffectDeclaringProject(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Renaming a private symbol typically confines the set of references and potential
            conflicts to that symbols declaring project. However, rename may cascade to
            non-public symbols which may then require other projects be considered.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameUtilities.TryGetRenamableSymbolAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a symbol in a document, returns the "right" symbol that should be renamed in
            the case the name binds to things like aliases _and_ the underlying type at once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameUtilities.FindDefinitionSymbolAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given a symbol, finds the symbol that actually defines the name that we're using.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService">
            <summary>
            Interface only for use by <see cref="T:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService"/>.  Includes language specific
            implementations on how to get an appropriate speculated semantic model given an older semantic model and a
            changed method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService.TryGetContainingMethodBodyForSpeculation(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node, returns the parent method-body-esque node that we can get a new speculative semantic model
            for.  Returns <see langword="null"/> if not in such a location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService.TryGetSpeculativeSemanticModelAsync(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Given a previous semantic model, and a method-eque node in the current tree for that same document, attempts
            to create a new speculative semantic model using the top level symbols of <paramref
            name="previousSemanticModel"/> but the new body level symbols produced for <paramref
            name="currentBodyNode"/>.
            <para>
            Note: it is critical that no top level changes have occurred between the syntax tree that <paramref
            name="previousSemanticModel"/> points at and the syntax tree that <paramref name="currentBodyNode"/> points
            at.  In other words, they must be <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/><c>(..., topLevel: true)</c>.  This
            function is undefined if they are not.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo.PreviousNonSpeculativeSemanticModel">
            <summary>
            The original <em>non-speculative</em> semantic model we retrieved for this document at some point.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo.CurrentSemanticModel">
            <summary>
            The current semantic model we retrieved <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> for the <see cref="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo.BodyNode"/>.  Could
            be speculative or non-speculative.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo.BodyNode">
            <summary>
            The current method body we retrieved the <see cref="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo.CurrentSemanticModel"/> for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo.TopLevelSemanticVersion">
            <summary>
            The top level version of the project when we retrieved <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.  As long as this is the
            same we can continue getting speculative models to use.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseWorkspaceServiceFactory.SemanticModelReuseWorkspaceService._semanticModelMap">
            <summary>
            A mapping from a document id to the last semantic model we produced for it, along with the top level
            semantic version that that semantic model corresponds to.  We can continue reusing the semantic model as
            long as no top level changes occur.
            <para>
            In general this dictionary will only contain a single key-value pair.  However, in the case of linked
            documents, there will be a key-value pair for each of the independent document links that a document
            has.
            </para>
            <para>
            A <see langword="null"/> value simply means we haven't cached any information for that particular id.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService">
            <summary>
            a service that provides a semantic model that will re-use last known compilation if
            semantic version hasn't changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Don't call this directly. use <see cref="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> (or an overload).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Attempts to return an speculative semantic model for <paramref name="document"/> if possible if <paramref
            name="position"/> is contained within a method body in the tree.  Specifically, this will attempt to get an
            existing cached semantic model for <paramref name="document"/>.  If it can find one, and the top-level semantic
            version for this project matches the cached version, and the position is within a method body, then it will 
            be returned, just with the previous corresponding method body swapped out with the current method body.
            <para/>
            If this is not possible, the regular semantic model for <paramref name="document"/> will be returned.
            <para/>
            When using this API, semantic model should only be used to ask questions about nodes inside of the member
            that contains the given <paramref name="position"/>.
            <para/>
            As a speculative semantic model may be returned, location based information provided by it may be innacurate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Attempts to return an speculative semantic model for <paramref name="document"/> if possible if <paramref
            name="span"/> is contained within a method body in the tree.  Specifically, this will attempt to get an
            existing cached semantic model <paramref name="document"/>.  If it can find one, and the top-level semantic
            version for this project matches the cached version, and the position is within a method body, then it will 
            be returned, just with the previous corresponding method body swapped out with the current method body.
            <para/>
            If this is not possible, the regular semantic model for <paramref name="document"/> will be returned.
            <para/>
            When using this API, semantic model should only be used to ask questions about nodes inside of the
            member that contains the given <paramref name="span"/>.
            <para/>
            As a speculative semantic model may be returned, location based information provided by it may be innacurate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.ReuseExistingSpeculativeModelAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Attempts to return an speculative semantic model for <paramref name="document"/> if possible if <paramref
            name="node"/> is contained within a method body in the tree.  Specifically, this will attempt to get an
            existing cached semantic model <paramref name="document"/>.  If it can find one, and the top-level semantic
            version for this project matches the cached version, and the position is within a method body, then it will 
            be returned, just with the previous corresponding method body swapped out with the current method body.
            <para/>
            If this is not possible, the regular semantic model for <paramref name="document"/> will be returned.
            <para/>
            When using this API, semantic model should only be used to ask questions about nodes inside of the
            member that contains the given <paramref name="node"/>.
            <para/>
            As a speculative semantic model may be returned, location based information provided by it may be innacurate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.FileLinePositionSpanExtensions.GetClampedTextSpan(Microsoft.CodeAnalysis.FileLinePositionSpan,Microsoft.CodeAnalysis.Text.SourceText)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Shared.Extensions.LinePositionSpanExtensions.GetClampedTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan,Microsoft.CodeAnalysis.Text.SourceText)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.FileLinePositionSpanExtensions.GetClampedSpan(Microsoft.CodeAnalysis.FileLinePositionSpan,Microsoft.CodeAnalysis.Text.SourceText)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Shared.Extensions.LinePositionSpanExtensions.GetClampedSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan,Microsoft.CodeAnalysis.Text.SourceText)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.LinePositionSpanExtensions.GetClampedTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> based off of the positions in <paramref name="span"/>, but
            which is guaranteed to fall entirely within the span of <paramref name="text"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.LinePositionSpanExtensions.GetClampedSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Returns a new <see cref="T:Microsoft.CodeAnalysis.Text.LinePositionSpan"/> based off of the positions in <paramref name="span"/>, but
            which is guaranteed to fall entirely within the span of <paramref name="text"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions.GetAllMethodSymbolsOfPartialParts(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns the methodSymbol and any partial parts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions.HasEventHandlerSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true for void returning methods with two parameters, where
            the first parameter is of <see cref="T:System.Object"/> type and the second
            parameter inherits from or equals <see cref="T:System.EventArgs"/> type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions.IsAsyncReturningVoidTask(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Tells if an async method returns a task-like type, awaiting for which produces <see langword="void"/> result
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions.GetOverridableMembers(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the set of members in the inheritance chain of <paramref name="containingType"/> that
            are overridable.  The members will be returned in furthest-base type to closest-base
            type order.  i.e. the overridable members of <see cref="T:System.Object"/> will be at the start
            of the list, and the members of the direct parent type of <paramref name="containingType"/> 
            will be at the end of the list.
            
            If a member has already been overridden (in <paramref name="containingType"/> or any base type) 
            it will not be included in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions.FindNamespaces(Microsoft.CodeAnalysis.INamespaceSymbol,System.String,System.Threading.CancellationToken)">
            <summary>
            Searches the namespace for namespaces with the provided name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsEditorBrowsable(Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.EditorBrowsableInfo,System.Boolean)">
            <summary>
            Checks a given symbol for browsability based on its declaration location, attributes explicitly limiting
            browsability, and whether showing of advanced members is enabled. The optional editorBrowsableInfo parameters
            may be used to specify the symbols of the constructors of the various browsability limiting attributes because
            finding these repeatedly over a large list of symbols can be slow. If these are not provided, they will be found
            in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.FilterToVisibleAndBrowsableSymbols``1(System.Collections.Immutable.ImmutableArray{``0},System.Boolean,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            First, remove symbols from the set if they are overridden by other symbols in the set.
            If a symbol is overridden only by symbols outside of the set, then it is not removed. 
            This is useful for filtering out symbols that cannot be accessed in a given context due
            to the existence of overriding members. Second, remove remaining symbols that are
            unsupported (e.g. pointer types in VB) or not editor browsable based on the EditorBrowsable
            attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.RequiresUnsafeModifier(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns <see langword="true"/> if the signature of this symbol requires the <see
            langword="unsafe"/> modifier.  For example a method that takes <c>List&lt;int*[]&gt;</c>
            is unsafe, as is <c>int* Goo { get; }</c>.  This will return <see langword="false"/> for
            symbols that cannot have the <see langword="unsafe"/> modifier on them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsInaccessibleLocal(Microsoft.CodeAnalysis.ISymbol,System.Int32)">
            <returns>
            Returns true if symbol is a local variable and its declaring syntax node is 
            after the current position, false otherwise (including for non-local symbols)
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAwaitableNonDynamic(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32)">
            <summary>
            If the <paramref name="symbol"/> is a method symbol, returns <see langword="true"/> if the method's return type is "awaitable", but not if it's <see langword="dynamic"/>.
            If the <paramref name="symbol"/> is a type symbol, returns <see langword="true"/> if that type is "awaitable".
            An "awaitable" is any type that exposes a GetAwaiter method which returns a valid "awaiter". This GetAwaiter method may be an instance method or an extension method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolWithSpecialDiscardName(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true for symbols whose name starts with an underscore and
            are optionally followed by an integer or other underscores, such as '_', '_1', '_2', '__', '___', etc.
            These are treated as special discard symbol names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsObsolete(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns <see langword="true"/>, if the symbol is marked with the <see cref="T:System.ObsoleteAttribute"/>.
            </summary>
            <param name="symbol"></param>
            <returns><see langword="true"/> if the symbol is marked with the <see cref="T:System.ObsoleteAttribute"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.RequiresUnsafeModifierVisitor">
            <summary>
            Visits types or members that have signatures (i.e. methods, fields, etc.) and determines
            if any of them reference a pointer type and should thus have the <see
            langword="unsafe"/> modifier on them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within name type 'within', with an optional
            qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessible(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within', with an qualifier of
            type "throughTypeOpt". Sets "failedThroughTypeCheck" to true if it failed the "through
            type" check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a INamedTypeSymbol
            or an IAssemblySymbol.  If 'symbol' is accessed off of an expression then
            'throughTypeOpt' is the type of that expression. This is needed to properly do protected
            access checks. Sets "failedThroughTypeCheck" to true if this protected check failed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.FindImplementationsForInterfaceMember(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Extensions.LineSpan">
            <summary>
            Like Span, except it has a start/end line instead of a start/end position.
            </summary>
            <param name="Start">Inclusive</param>
            <param name="End">Exclusive</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.LineSpan.#ctor(System.Int32,System.Int32)">
            <summary>
            Like Span, except it has a start/end line instead of a start/end position.
            </summary>
            <param name="Start">Inclusive</param>
            <param name="End">Exclusive</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.LineSpan.Start">
            <summary>Inclusive</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.LineSpan.End">
            <summary>Exclusive</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions.GetExtendedLanguageServices(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets extended host language services, which includes language services from <see cref="P:Microsoft.CodeAnalysis.Project.LanguageServices"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleExtensions.Lease(System.Runtime.InteropServices.SafeHandle)">
            <summary>
            Acquires a lease on a safe handle. The lease increments the reference count of the <see cref="T:System.Runtime.InteropServices.SafeHandle"/>
            to ensure the handle is not released prior to the lease being released.
            </summary>
            <remarks>
            This method is intended to be used in the initializer of a <c>using</c> statement. Failing to release the
            lease will permanently prevent the underlying <see cref="T:System.Runtime.InteropServices.SafeHandle"/> from being released by the garbage
            collector.
            </remarks>
            <param name="handle">The <see cref="T:System.Runtime.InteropServices.SafeHandle"/> to lease.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleLease"/>, which must be disposed to release the resource.</returns>
            <exception cref="T:System.ObjectDisposedException">If the lease could not be acquired.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleLease">
            <summary>
            Represents a lease of a <see cref="T:System.Runtime.InteropServices.SafeHandle"/>.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleExtensions.Lease(System.Runtime.InteropServices.SafeHandle)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleLease.Dispose">
            <summary>
            Releases the <see cref="T:System.Runtime.InteropServices.SafeHandle"/> lease. The behavior of this method is unspecified if called more than
            once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about the parent of a token.
            </summary>
            <param name="semanticModel">The SemanticModel object to get semantic information
            from.</param>
            <param name="token">The token to get semantic information from. This must be part of the
            syntax tree associated with the binding.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetType(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Fetches the ITypeSymbol that should be used if we were generating a parameter or local that would accept <paramref name="expression"/>. If
            expression is a type, that's returned; otherwise this will see if it's something like a method group and then choose an appropriate delegate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.s_charArrayPool">
            <summary>
            Note: there is a strong invariant that you only get arrays back from this that are exactly <see
            cref="F:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.CharArrayLength"/> long.  Putting arrays back into this of the wrong length will result in broken
            behavior.  Do not expose this pool outside of this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.CharArrayChunkTextReader.Position">
            <summary>
            Public so that the caller can assert that the new SourceText read all the way to the end of this successfully.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLeadingWhitespaceOfLineAtPosition(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Returns the leading whitespace of the line located at the specified position in the given snapshot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.TryOverlapsHiddenPosition(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Func{System.Int32,System.Threading.CancellationToken,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Same as OverlapsHiddenPosition but doesn't throw on cancellation.  Instead, returns false
            in that case.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.GenerateDelegateThroughMemberStatement(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Generates a call to a method *through* an existing field or property symbol.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.CreateGetHashCodeMethodStatements(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Boolean)">
            <summary>
            Generates an override of <see cref="M:System.Object.GetHashCode"/> similar to the one
            generated for anonymous types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.SimpleLocalDeclarationStatement(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            In VB it's more idiomatic to write things like <c>Dim t = TryCast(obj, SomeType)</c>
            instead of <c>Dim t As SomeType = TryCast(obj, SomeType)</c>, so we just elide the type
            from the decl.  For C# we don't want to do this though.  We want to always include the
            type and let the simplifier decide if it should be <c>var</c> or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.IsSpecialCaseBinaryExpression(Microsoft.CodeAnalysis.Operations.IBinaryOperation,Microsoft.CodeAnalysis.Operations.BinaryOperatorKind)">
            <summary>
            Returns true if the binaryExpression consists of an expression that can never be negative, 
            such as length or unsigned numeric types, being compared to zero with greater than, 
            less than, or equals relational operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CompilationExtensions.GetBestTypeByMetadataName(Microsoft.CodeAnalysis.Compilation,System.String)">
             <summary>
             Gets a type by its metadata name to use for code analysis within a <see cref="T:Microsoft.CodeAnalysis.Compilation"/>. This method
             attempts to find the "best" symbol to use for code analysis, which is the symbol matching the first of the
             following rules.
            
             <list type="number">
               <item><description>
                 If only one type with the given name is found within the compilation and its referenced assemblies, that
                 type is returned regardless of accessibility.
               </description></item>
               <item><description>
                 If the current <paramref name="compilation"/> defines the symbol, that symbol is returned.
               </description></item>
               <item><description>
                 If exactly one referenced assembly defines the symbol in a manner that makes it visible to the current
                 <paramref name="compilation"/>, that symbol is returned.
               </description></item>
               <item><description>
                 Otherwise, this method returns <see langword="null"/>.
               </description></item>
             </list>
             </summary>
             <param name="compilation">The <see cref="T:Microsoft.CodeAnalysis.Compilation"/> to consider for analysis.</param>
             <param name="fullyQualifiedMetadataName">The fully-qualified metadata type name to find.</param>
             <returns>The symbol to use for code analysis; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.CompilationExtensions.GetTopLevelStatementsMethod(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Gets implicit method, that wraps top-level statements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.GetEffectiveSeverity(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            Gets project-level effective severity of the given <paramref name="descriptor"/> accounting for severity configurations from both the following sources:
            1. Compilation options from ruleset file, if any, and command line options such as /nowarn, /warnaserror, etc.
            2. Analyzer config documents at the project root directory or in ancestor directories.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.GetEffectiveSeverity(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions)">
            <summary>
            Gets document-level effective severity of the given <paramref name="descriptor"/> accounting for severity configurations from both the following sources:
            1. Compilation options from ruleset file, if any, and command line options such as /nowarn, /warnaserror, etc.
            2. Analyzer config documents at the document root directory or in ancestor directories.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.GetEffectiveSeverity(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,System.Nullable{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider,Microsoft.CodeAnalysis.SyntaxTree}})">
            <summary>
            Gets the effective diagnostic severity for the diagnostic ID corresponding to the
            given <paramref name="descriptor"/> by looking up the severity settings in the options.
            If the provided options are specific to a particular tree, provide a non-null value
            for <paramref name="providerAndTree"/> to look up tree specific severity options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.TryGetSeverityFromBulkConfiguration(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptions,Microsoft.CodeAnalysis.ReportDiagnostic@)">
            <summary>
            Tries to get configured severity for the given <paramref name="descriptor"/>
            from bulk configuration analyzer config options, i.e.
                'dotnet_analyzer_diagnostic.category-%RuleCategory%.severity = %severity%'
                    or
                'dotnet_analyzer_diagnostic.severity = %severity%'
            Docs: https://docs.microsoft.com/visualstudio/code-quality/use-roslyn-analyzers?view=vs-2019#set-rule-severity-of-multiple-analyzer-rules-at-once-in-an-editorconfig-file for details
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ListExtensions.RemoveOrTransformAll``2(System.Collections.Generic.List{``0},System.Func{``0,``1,``0},``1)">
            <summary>
            Update a list in place, where a function has the ability to either transform or remove each item.
            </summary>
            <typeparam name="T">The type of items in the list.</typeparam>
            <typeparam name="TArg">The type of state argument passed to the transformation callback.</typeparam>
            <param name="list">The list to update.</param>
            <param name="transform">A function which transforms each element. The function returns the transformed list
            element, or <see langword="null"/> to remove the current item from the list.</param>
            <param name="arg">The state argument to pass to the transformation callback.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ListExtensions.TryRemoveFirst``2(System.Collections.Generic.IList{``0},System.Func{``0,``1,System.Boolean},``1,``0@)">
            <summary>
            Attempts to remove the first item selected by <paramref name="selector"/>.
            </summary>
            <returns>
            True if any item has been removed.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IAsyncEnumerableExtensions.MergeAsync``1(System.Collections.Immutable.ImmutableArray{System.Collections.Generic.IAsyncEnumerable{``0}},System.Threading.CancellationToken)">
            <summary>
            Takes an array of <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/>s and produces a single resultant <see
            cref="T:System.Collections.Generic.IAsyncEnumerable`1"/> with all their values merged together.  Absolutely no ordering guarantee is
            provided.  It will be expected that the individual values from distinct enumerables will be interleaved
            together.
            </summary>
            <remarks>This helper is useful when doign parallel processing of work where each job returns an <see
            cref="T:System.Collections.Generic.IAsyncEnumerable`1"/>, but one final stream is desired as the result.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IAsyncEnumerableExtensions.CompletesChannel``1(System.Threading.Tasks.Task,System.Threading.Channels.Channel{``0})">
            <summary>
            Runs after task completes in any fashion (success, cancellation, faulting) and ensures the channel writer is
            always completed.  If the task faults then the exception from that task will be used to complete the channel
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.IsChildNode``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if is a given token is a child token of a certain type of parent node.
            </summary>
            <typeparam name="TParent">The type of the parent node.</typeparam>
            <param name="node">The node that we are testing.</param>
            <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.IsFoundUnder``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if this node is found underneath the specified child in the given parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ReplaceNodesAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of nodes from the existing tree with the specified old nodes replaced with a newly computed nodes.
            </summary>
            <param name="root">The root of the tree that contains all the specified nodes.</param>
            <param name="nodes">The nodes from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement node for
            the argument nodes. The first argument is one of the original specified nodes. The second argument is
            the same node possibly rewritten with replaced descendants.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ReplaceTokensAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxToken}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of tokens from the existing tree with the specified old tokens replaced with a newly computed tokens.
            </summary>
            <param name="root">The root of the tree that contains all the specified tokens.</param>
            <param name="tokens">The tokens from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement token for
            the argument tokens. The first argument is one of the originally specified tokens. The second argument is
            the same token possibly rewritten with replaced trivia.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.s_findSkippedTokenForward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindSkippedTokenForward(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.s_findSkippedTokenBackward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindSkippedTokenBackward(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.WithoutLeadingTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token with the leading trivia removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.WithoutTrailingTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a new token with the trailing trivia removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindNode(Microsoft.CodeAnalysis.SyntaxNode,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,System.Boolean)">
            <summary>
            Finds the node within the given <paramref name="root"/> corresponding to the given <paramref name="span"/>.
            If the <paramref name="span"/> is <see langword="null"/>, then returns the given <paramref name="root"/> node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ValueAncestorsAndSelf(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.GetTouchingWordAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns the identifier, keyword, contextual keyword or preprocessor keyword touching this
            position, or a token of Kind = None if the caret is not touching either.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindNode(Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Finds the node in the given <paramref name="syntaxTree"/> corresponding to the given <paramref name="span"/>.
            If the <paramref name="span"/> is <see langword="null"/>, then returns the root node of the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespacePosition(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line, or null if 
            the line is empty or contains only whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespaceOffset(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line as an offset
            from the start of the line, or null if the line is empty or contains only
            whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.IsEmptyOrWhitespace(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Determines whether the specified line is empty or contains whitespace only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.ToNormalizedSpans(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            merge provided spans to each distinct group of spans in ascending order
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.IsAround(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns true if the span encompasses the specified node or token and is contained within its trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.IsAround(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns true if the span encompasses a span between the specified nodes or tokens
            and is contained within trivia around them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions.GetAllTypes(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Lazily returns all nested types contained (recursively) within this namespace or type.
            In case of a type, it is included itself as the first result.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.NameFormat">
            <summary>
            Standard format for displaying to the user.
            </summary>
            <remarks>
            No return type.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.SignatureFormat">
            <summary>
            Contains enough information to determine whether two symbols have the same signature.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.LeftToken">
            <summary>
            The token to the left of <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.Position"/>. This token may be touching the position.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.TargetToken">
            <summary>
            The first token to the left of <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.Position"/> that we're not touching. Equal to <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.LeftToken"/>
            if we aren't touching <see cref="P:Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext.LeftToken" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``1(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyMethodBodySemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within a method
            body then the document/semantic-model will be forked after each edit so that further
            edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyMethodBodySemanticEditsAsync``1(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within a method
            body then the document/semantic-model will be forked after each edit so that further
            edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplySemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Helper function for fix-all fixes where individual fixes may affect the viability
            of another.  For example, consider the following code:
            
                if ((double)x == (double)y)
                
            In this code either cast can be removed, but at least one cast must remain.  Even
            though an analyzer marks both, a fixer must not remove both.  One way to accomplish
            this would be to have the fixer do a semantic check after each application.  However
            This is extremely expensive, especially for hte common cases where one fix does
            not affect each other.
            
            To address that, this helper groups fixes at certain boundary points.  i.e. at 
            statement boundaries.  If there is only one fix within the boundary, it does not
            do any semantic verification.  However, if there are multiple fixes in a boundary
            it will call into <paramref name="canReplace"/> to validate if the subsequent fix
            can be made or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this text document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithAdditionalDocumentText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this additional document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this analyzer config document updated to have the text specified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener.DiagnosticAsyncToken">
            <summary>
            Stores the source information for an <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken"/> value.  Helpful when 
            tracking down tokens which aren't properly disposed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener.DiagnosticAsyncToken.#ctor(Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener,System.String,System.Object,System.String,System.Int32)">
            <summary>
            Stores the source information for an <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken"/> value.  Helpful when 
            tracking down tokens which aren't properly disposed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider">
            <summary>
            use <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider" /> in product code to get
            <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener" /> and use
            <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider" /> in test to get waiter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.s_enabled">
            <summary>
            indicate whether asynchronous listener is enabled or not.
            it is tri-state since we want to retrieve this value, if never explicitly set, from environment variable
            and then cache it.
            we read value from environment variable (RoslynWaiterEnabled) because we want team, that doesn't have
            access to Roslyn code (InternalVisibleTo), can use this listener/waiter framework as well. 
            those team can enable this without using <see cref="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.Enable(System.Boolean)" /> API
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider._enableDiagnosticTokens">
            <summary>
            indicate whether <see cref="P:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener.TrackActiveTokens"/> is enabled or not
            it is tri-state since we want to retrieve this value, if never explicitly set, from environment variable
            and then cache it.
            we read value from environment variable (RoslynWaiterDiagnosticTokenEnabled) because we want team, that doesn't have
            access to Roslyn code (InternalVisibleTo), can use this listener/waiter framework as well. 
            those team can enable this without using <see cref="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.EnableDiagnosticTokens(System.Boolean)" /> API
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.s_enableDiagnosticTokens">
            <summary>
            Provides a default value for <see cref="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider._enableDiagnosticTokens"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.EnableDiagnosticTokens(System.Boolean)">
            <summary>
            Enable or disable TrackActiveTokens for test
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.GetWaiter(System.String)">
            <summary>
            Get Waiters for listeners for test
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.WaitAllAsync(Microsoft.CodeAnalysis.Workspace,System.String[],System.Action,System.Nullable{System.TimeSpan})">
            <summary>
            Wait for all of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationWaiter"/> instances to finish their
            work.
            </summary>
            <remarks>
            This is a very handy method for debugging hangs in the unit test.  Set a break point in the 
            loop, dig into the waiters and see all of the active <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken"/> values 
            representing the remaining work.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.GetTokens">
            <summary>
            Get all saved DiagnosticAsyncToken to investigate tests failure easier
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> for the given featureName
            
            We have this abstraction so that we can have isolated listener/waiter in unit tests
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider.GetListener(System.String)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> for given feature.
            same provider will return a singleton listener for same feature
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationWaiter.ExpeditedWaitAsync">
            <summary>
            Returns a task which completes when all asynchronous operations currently tracked by this waiter are
            completed. Asynchronous operations are expedited when possible, meaning artificial delays placed before
            asynchronous operations are shortened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowAwaitableInternal(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Returns an awaitable for the specified task that will never throw, even if the source task
            faults or is canceled.
            </summary>
            <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
            <param name="captureContext">if set to <c>true</c> the continuation will be scheduled on the caller's context; <c>false</c> to always execute the continuation on the threadpool.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaitable">
            <summary>
            An awaitable that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaitable._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaitable._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaitable.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaitable" /> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <c>true</c> [capture context].</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions.NoThrowTaskAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Creates a task that will complete after a time delay, but can be expedited if an operation is waiting for
            the task to complete.
            </summary>
            <param name="delay">The time to wait before completing the returned task, or <c>TimeSpan.FromMilliseconds(-1)</c> to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe while waiting for the task to complete.</param>
            <returns><see langword="true"/> if the delay compeleted normally; otherwise, <see langword="false"/> if the delay completed due to a request to expedite the delay.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="delay"/> represents a negative time interval other than <c>TimeSpan.FromMilliseconds(-1)</c>.</para>
            <para>-or-</para>
            <para>The <paramref name="delay"/> argument's <see cref="P:System.TimeSpan.TotalMilliseconds"/> property is greater than <see cref="F:System.Int32.MaxValue"/>.</para>
            </exception>
            <exception cref="T:System.OperationCanceledException">The delay has been canceled.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowAwaitableInternal(System.Threading.Tasks.ValueTask,System.Boolean)">
            <summary>
            Returns an awaitable for the specified task that will never throw, even if the source task
            faults or is canceled.
            </summary>
            <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
            <param name="captureContext">if set to <see langword="true"/> the continuation will be scheduled on the caller's context; <see langword="false"/> to always execute the continuation on the threadpool.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowAwaitableInternal``1(System.Threading.Tasks.ValueTask{``0},System.Boolean)">
             <summary>
             Returns an awaitable for the specified task that will never throw, even if the source task
             faults or is canceled.
             </summary>
             <remarks>
             The awaitable returned by this method does not provide access to the result of a successfully-completed
             <see cref="T:System.Threading.Tasks.ValueTask`1"/>. To await without throwing and use the resulting value, the following
             pattern may be used:
            
             <code>
             var methodValueTask = MethodAsync().Preserve();
             await methodValueTask.NoThrowAwaitableInternal(true);
             if (methodValueTask.IsCompletedSuccessfully)
             {
               var result = methodValueTask.Result;
             }
             else
             {
               var exception = methodValueTask.AsTask().Exception.InnerException;
             }
             </code>
             </remarks>
             <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
             <param name="captureContext">if set to <see langword="true"/> the continuation will be scheduled on the caller's context; <see langword="false"/> to always execute the continuation on the threadpool.</param>
             <returns>An awaitable.</returns>
             <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable">
            <summary>
            An awaitable that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable.#ctor(System.Threading.Tasks.ValueTask,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter.#ctor(System.Threading.Tasks.ValueTask,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <see langword="true"/> [capture context].</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable`1">
            <summary>
            An awaitable that wraps a <see cref="T:System.Threading.Tasks.ValueTask`1"/> and never throws an exception when waited on.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable`1._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable`1._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable`1.#ctor(System.Threading.Tasks.ValueTask{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable`1" /> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaitable`1.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns>The awaiter.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1._task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1._captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.#ctor(System.Threading.Tasks.ValueTask{`0},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <see langword="true"/> [capture context].</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution
            without capturing the ExecutionContext.
            </summary>
            <param name="continuation">The action.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions.NoThrowValueTaskAwaiter`1.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary><![CDATA[
            1) n  = Number of items in the filter
            
            2) p = Probability of false positives, (a double between 0 and 1).
            
            3) m = Number of bits in the filter
            
            4) k = Number of hash functions
            
            m = ceil((n * log(p)) / log(1.0 / (pow(2.0, log(2.0)))))
            
            k = round(log(2.0) * m / n)
            ]]></summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.ComputeHash(System.String,System.Int32,System.Boolean)">
            <summary>
            Modification of the murmurhash2 algorithm.  Code is simpler because it operates over
            strings instead of byte arrays.  Because each string character is two bytes, it is known
            that the input will be an even number of bytes (though not necessarily a multiple of 4).
            
            This is needed over the normal 'string.GetHashCode()' because we need to be able to generate
            'k' different well distributed hashes for any given string s.  Also, we want to be able to
            generate these hashes without allocating any memory.  My ideal solution would be to use an
            MD5 hash.  However, there appears to be no way to do MD5 in .NET where you can:
            
            a) feed it individual values instead of a byte[]
            
            b) have the hash computed into a byte[] you provide instead of a newly allocated one
            
            Generating 'k' pieces of garbage on each insert and lookup seems very wasteful.  So,
            instead, we use murmur hash since it provides well distributed values, allows for a
            seed, and allocates no memory.
            
            Murmur hash is public domain.  Actual code is included below as reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.BloomFilterHash">
            <summary>
            Provides mechanism to efficiently obtain bloom filter hash for a value. Backed by a single element cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.BloomFilterHash.GetOrCreateHashArray(System.String,System.Boolean,System.Int32)">
             <summary>
             Although calculating this hash isn't terribly expensive, it does involve multiple
             (usually around 13) hashings of the string (the actual count is <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter._hashFunctionCount"/>).
             The typical usage pattern of bloom filters is that some operation (eg: find references)
             requires asking a multitude of bloom filters whether a particular value is likely contained.
             The vast majority of those bloom filters will end up hashing that string to the same values, so
             we put those values into a simple cache and see if it can be used before calculating.
             Local testing has put the hit rate of this at around 99%.
            
             Note that it's possible for this method to return an array from the cache longer than hashFunctionCount,
             but if so, it's guaranteed that the values returned in the first hashFunctionCount entries are
             the same as if the cache hadn't been used.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment">
            <summary>
            A documentation comment derived from either source text or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.HadXmlParseError">
            <summary>
            True if an error occurred when parsing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.FullXmlFragment">
            <summary>
            The full XML text of this tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ExampleText">
            <summary>
            The text in the &lt;example&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.SummaryText">
            <summary>
            The text in the &lt;summary&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ReturnsText">
            <summary>
            The text in the &lt;returns&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ValueText">
            <summary>
            The text in the &lt;value&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.RemarksText">
            <summary>
            The text in the &lt;remarks&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ParameterNames">
            <summary>
            The names of items in &lt;param&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.TypeParameterNames">
            <summary>
            The names of items in &lt;typeparam&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ExceptionTypes">
            <summary>
            The types of items in &lt;exception&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CompletionListCref">
            <summary>
            The item named in the &lt;completionlist&gt; tag's cref attribute.
            Null if the tag or cref attribute didn't exist.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.s_NewLineAsStringArray">
            <summary>
            Used for <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CommentBuilder.TrimEachLine(System.String)"/> method, to prevent new allocation of string
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.s_cacheLastXmlFragmentParse">
            <summary>
            Cache of the most recently parsed fragment and the resulting DocumentationComment
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.FromXmlFragment(System.String)">
            <summary>
            Parses and constructs a <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment" /> from the given fragment of XML.
            </summary>
            <param name="xml">The fragment of XML to parse.</param>
            <returns>A DocumentationComment instance.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CommentBuilder">
            <summary>
            Helper class for parsing XML doc comments. Encapsulates the state required during parsing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CommentBuilder.Parse(System.String)">
            <summary>
            Parse and construct a <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment" /> from the given fragment of XML.
            </summary>
            <param name="xml">The fragment of XML to parse.</param>
            <returns>A DocumentationComment instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetParameterText(System.String)">
            <summary>
            Returns the text for a given parameter, or null if no documentation was given for the parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetTypeParameterText(System.String)">
            <summary>
            Returns the text for a given type parameter, or null if no documentation was given for the type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetExceptionTexts(System.String)">
            <summary>
            Returns the texts for a given exception, or an empty <see cref="T:System.Collections.Immutable.ImmutableArray"/> if no documentation was given for the exception.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.Empty">
            <summary>
            An empty comment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.GetSpecialEditorBrowsableAttributeConstructor(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Finds the constructor which takes exactly one argument, which must be of type EditorBrowsableState.
            It does not require that the EditorBrowsableAttribute and EditorBrowsableState types be those
            shipped by Microsoft, but it does demand the types found follow the expected pattern. If at any
            point that pattern appears to be violated, return null to indicate that an appropriate constructor
            could not be found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.GetSpecialTypeLibAttributeConstructorsWorker(Microsoft.CodeAnalysis.Compilation,System.String,System.String)">
            <summary>
            The TypeLib*Attribute classes that accept TypeLib*Flags with FHidden as an option all have two constructors,
            one accepting a TypeLib*Flags and the other a short. This methods gets those two constructor symbols for any
            of these attribute classes. It does not require that the either of these types be those shipped by Microsoft,
            but it does demand the types found follow the expected pattern. If at any point that pattern appears to be
            violated, return an empty enumerable to indicate that no appropriate constructors were found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ExtensionOrderer.TestAccessor.CheckForCycles``2(System.Collections.Generic.IEnumerable{System.Lazy{``0,``1}})">
            <summary>
            Helper for checking whether cycles exist in the extension ordering.
            Throws <see cref="T:System.ArgumentException"/> if a cycle is detected.
            </summary>
            <exception cref="T:System.ArgumentException">A cycle was detected in the extension ordering.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTrackerExtensions.AddSingleItemAsync(Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTracker,System.Threading.CancellationToken)">
            <summary>
            Returns an <see cref="T:System.IAsyncDisposable"/> that will call <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTrackerExtensions.ItemCompletedAsync(Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTracker,System.Threading.CancellationToken)"/> on
            <paramref name="progressTracker"/> when it is disposed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.IWorkspaceThreadingService">
             <summary>
             An optional interface which allows an environment to customize the behavior for synchronous methods that need to
             block on the result of an asynchronous invocation. An implementation of this is provided in the MEF catalog when
             applicable.
             </summary>
             <remarks>
             <para>For Visual Studio, Microsoft.VisualStudio.Threading provides the JoinableTaskFactory.Run method, which is
             the expected way to invoke an asynchronous method from a synchronous entry point and block on its completion.
             Other environments may choose to use this or any other strategy, or omit an implementation of this interface to
             allow callers to simply use <see cref="M:System.Threading.Tasks.Task.Wait"/>.</para>
            
             <para>New code is expected to use fully-asynchronous programming where possible. In cases where external APIs
             restrict ability to be asynchronous, this service allows Roslyn to adhere to environmental policies related to
             joining asynchronous work.</para>
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.StreamingProgressTracker">
            <summary>
            Utility class that can be used to track the progress of an operation in a threadsafe manner.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.StreamingProgressTracker.#ctor(System.Func{System.Int32,System.Int32,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask})">
            <summary>
            Utility class that can be used to track the progress of an operation in a threadsafe manner.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser">
            <summary>
            An XML parser that is designed to parse small fragments of XML such as those that appear in documentation comments.
            PERF: We try to re-use the same underlying <see cref="T:System.Xml.XmlReader"/> to reduce the allocation costs of multiple parses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser.ParseFragment``1(System.String,System.Action{System.Xml.XmlReader,``0},``0)">
            <summary>
            Parse the given XML fragment. The given callback is executed until either the end of the fragment
            is reached or an exception occurs.
            </summary>
            <typeparam name="TArg">Type of an additional argument passed to the <paramref name="callback"/> delegate.</typeparam>
            <param name="xmlFragment">The fragment to parse.</param>
            <param name="callback">Action to execute while there is still more to read.</param>
            <param name="arg">Additional argument passed to the callback.</param>
            <remarks>
            It is important that the <paramref name="callback"/> action advances the <see cref="T:System.Xml.XmlReader"/>,
            otherwise parsing will never complete.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser.Reader">
            <summary>
            A text reader over a synthesized XML stream consisting of a single root element followed by a potentially
            infinite stream of fragments. Each time "SetText" is called the stream is rewound to the element immediately
            following the synthetic root node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser.Reader._text">
            <summary>
            Current text to validate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EnumValueUtilities.GetNextEnumValue(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determines, using heuristics, what the next likely value is in this enum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8">
            <summary>
            Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
            Given an expression node from a syntax tree and a new expression from a different syntax tree,
            it replaces the expression with the new expression to create a speculated syntax tree.
            It uses the original tree's semantic model to create a speculative semantic model and verifies that
            the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.#ctor(`0,`0,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
            <summary>
            Creates a semantic analyzer for speculative syntax replacement.
            </summary>
            <param name="expression">Original expression to be replaced.</param>
            <param name="newExpression">New expression to replace the original expression.</param>
            <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="skipVerificationForReplacedNode">
            True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
            This could be the case when custom verifications are required to be done by the caller or
            semantics of the replaced expression are different from the original expression.
            </param>
            <param name="failOnOverloadResolutionFailuresInOriginalCode">
            True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression">
            <summary>
            Original expression to be replaced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfOriginalExpression">
            <summary>
            First ancestor of <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> which is either a statement, attribute, constructor initializer,
            field initializer, default parameter initializer or type syntax node.
            It serves as the root node for all semantic analysis for this syntax replacement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalSemanticModel">
            <summary>
            Semantic model for the syntax tree corresponding to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacedExpression">
            <summary>
            Node which replaces the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/>.
            Note that this node is a cloned version of <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8._newExpressionForReplace"/> node, which has been re-parented
            under the node to be speculated, i.e. <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfReplacedExpression"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfReplacedExpression">
            <summary>
            Node created by replacing <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> under <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfOriginalExpression"/> node.
            This node is used as the argument to the GetSpeculativeSemanticModel API and serves as the root node for all
            semantic analysis of the speculated tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SpeculativeSemanticModel">
            <summary>
            Speculative semantic model used for analyzing the semantics of the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacementChangesSemantics">
            <summary>
            Determines whether performing the given syntax replacement will change the semantics of any parenting expressions
            by performing a bottom up walk from the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfOriginalExpression"/>
            in the original tree and simultaneously walking bottom up from <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacedExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SemanticRootOfReplacedExpression"/>
            in the speculated syntax tree and performing appropriate semantic comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.SymbolsForOriginalAndReplacedNodesAreCompatible">
            <summary>
            Checks whether the semantic symbols for the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.OriginalExpression"/> and <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacedExpression"/> are non-null and compatible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.ReplacementBreaksSystemObjectMethodResolution(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if removing the cast could cause the semantics of System.Object method call to change.
            E.g. Dim b = CStr(1).GetType() is necessary, but the GetType method symbol info resolves to the same with or without the cast.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8.IsSymbolSystemObjectInstanceMethod(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is a non-overridable, non static method on System.Object (e.g. GetType)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AliasSymbolCache.TryGetAliasSymbol(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.IAliasSymbol@)">
            <summary>
            Returns <see langword="true"/> if items were already cached for this <paramref name="semanticModel"/> and
            <paramref name="namespaceId"/>, <see langword="false"/> otherwise.  Callers should use this value to
            determine if they should call <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.AliasSymbolCache.AddAliasSymbols(Microsoft.CodeAnalysis.SemanticModel,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IAliasSymbol})"/> or not.  A result of <see langword="true"/> does
            *not* mean that <paramref name="aliasSymbol"/> is non-<see langword="null"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.AppendPartialLeadingTriviaText(Microsoft.CodeAnalysis.SyntaxToken,System.Text.StringBuilder,System.Int32)">
            <summary>
            If the token1 is expected to be part of the leading trivia of the token2 then the trivia
            before the token1FullSpanEnd, which the fullspan end of the token1 should be ignored
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            this will create a span that includes its trailing trivia of its previous token and leading trivia of its next token
            for example, for code such as "class A { int ...", if given tokens are "A" and "{", this will return span [] of "class[ A { ]int ..."
            which included trailing trivia of "class" which is previous token of "A", and leading trivia of "int" which is next token of "{"
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.InterceptsLocationData">
            <param name="ContentHash">Content hash of the original document the containing the invocation to be intercepted.
            (See <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetContentHash"/>)</param>
            <param name="Position">The position in the file of the invocation that was intercepted.  This is the absolute
            start of the name token being invoked (e.g. <c>this.$$Goo(x, y, z)</c>) (see <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.FullSpan"/>).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.InterceptsLocationData.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte},System.Int32)">
            <param name="ContentHash">Content hash of the original document the containing the invocation to be intercepted.
            (See <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetContentHash"/>)</param>
            <param name="Position">The position in the file of the invocation that was intercepted.  This is the absolute
            start of the name token being invoked (e.g. <c>this.$$Goo(x, y, z)</c>) (see <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.FullSpan"/>).</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.InterceptsLocationData.ContentHash">
            <summary>Content hash of the original document the containing the invocation to be intercepted.
            (See <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetContentHash"/>)</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.InterceptsLocationData.Position">
            <summary>The position in the file of the invocation that was intercepted.  This is the absolute
            start of the name token being invoked (e.g. <c>this.$$Goo(x, y, z)</c>) (see <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.FullSpan"/>).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalExpression">
            <summary>
            The original expression that is being replaced by <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.ReplacedExpression"/>.  This will be in the
            <see cref="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTree"/> that <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalSemanticModel"/> points at.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.ReplacedExpression">
            <summary>
            The new node that <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalExpression"/>n was replaced with.  This will be in the <see
            cref="P:Microsoft.CodeAnalysis.SemanticModel.SyntaxTree"/> that <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.SpeculativeSemanticModel"/> points at.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalSemanticModel">
            <summary>
            The original semantic model that <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalExpression"/> was contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.SpeculativeSemanticModel">
            <summary>
            A forked semantic model off of <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalSemanticModel"/>.  In that model <see
            cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalExpression"/> will have been replaced with <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.ReplacedExpression"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.PathMetadataUtilities.TryBuildNamespaceFromFolders(System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts,System.String)">
            <summary>
            Given a set of folders from build the namespace that would match
            the folder structure. If a document is located in { "Bat" , "Bar", "Baz" } then the namespace could be 
            "Bat.Bar.Baz". If a rootNamespace is provided, it is prepended to the generated namespace.
            
            Returns null if the folders contain parts that are invalid identifiers for a namespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions.SingleReaderOptions">
            <summary>
            Used when the consumeItems routine will only pull items on a single thread (never concurrently). produceItems
            can be called concurrently on many threads.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions.SingleReaderWriterOptions">
            <summary>
            Used when the consumeItems routine will only pull items on a single thread (never concurrently). produceItems
            can be called on a single thread as well (never concurrently).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions.SingleWriter">
            <inheritdoc cref="P:System.Threading.Channels.ChannelOptions.SingleWriter"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions.SingleReader">
            <inheritdoc cref="P:System.Threading.Channels.ChannelOptions.SingleReader"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunAsync``1(Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions,System.Func{System.Action{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Immutable.ImmutableArray{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},``0,System.Threading.CancellationToken)">
            <summary>
            Version of <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunChannelAsync``2(Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions,System.Func{System.Action{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Threading.Channels.ChannelReader{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},``0,System.Threading.CancellationToken)"/> when caller the prefers the results being pre-packaged into arrays to process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunAsync``1(Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions,System.Func{System.Action{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IAsyncEnumerable{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},``0,System.Threading.CancellationToken)">
            <summary>
            Version of <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunChannelAsync``2(Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions,System.Func{System.Action{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Threading.Channels.ChannelReader{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},``0,System.Threading.CancellationToken)"/> when the caller prefers working with a stream of results.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IAsyncEnumerable{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IEnumerable&lt;TSource&gt; -> Task</code>.  Callback receives IAsyncEnumerable items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IAsyncEnumerable{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IAsyncEnumerable&lt;TSource&gt; -> Task</code>.  Callback receives IAsyncEnumerable items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Immutable.ImmutableArray{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IEnumerable&lt;TSource&gt; -> Task</code>.  Callback receives ImmutableArray of items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Immutable.ImmutableArray{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IAsyncEnumerable&lt;TSource&gt; -> Task</code>.  Callback receives ImmutableArray of items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IAsyncEnumerable{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IEnumerable&lt;TSource&gt; -> Task&lt;TResult&gt;</code>  Callback receives an IAsyncEnumerable of items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``3(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Collections.Generic.IAsyncEnumerable{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task{``2}},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IAsyncEnumerable&lt;TSource&gt; -> Task&lt;TResult&gt;</code>.  Callback receives an IAsyncEnumerable of items.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IEnumerable&lt;TSource&gt; -> Task&lt;ImmutableArray&lt;TResult&gt;&gt;</code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunParallelAsync``2(System.Collections.Generic.IAsyncEnumerable{``0},System.Func{``0,System.Action{`0},``1,System.Threading.CancellationToken,System.Threading.Tasks.Task},``1,System.Threading.CancellationToken)">
            <summary>
            <code>IAsyncEnumerable&lt;TSource&gt; -> Task&lt;ImmutableArray&lt;TResult&gt;&gt;</code>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumer`1.RunChannelAsync``2(Microsoft.CodeAnalysis.Shared.Utilities.ProducerConsumerOptions,System.Func{System.Action{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Func{System.Threading.Channels.ChannelReader{`0},``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},``0,System.Threading.CancellationToken)">
            <summary>
            Helper utility for the pattern of a pair of a production routine and consumption routine using a channel to
            coordinate data transfer.  The provided <paramref name="options"/> are used to create a <see
            cref="T:System.Threading.Channels.Channel`1"/>, which will then then manage the rules and behaviors around the routines. Importantly, the
            channel handles backpressure, ensuring that if the consumption routine cannot keep up, that the production
            routine will be throttled.
            <para>
            <paramref name="produceItems"/> is the routine called to actually produce the items.  It will be passed an
            action that can be used to write items to the channel.  Note: the channel itself will have rules depending on if
            that writing can happen concurrently multiple write threads or just a single writer.  See <see
            cref="P:System.Threading.Channels.ChannelOptions.SingleWriter"/> for control of this when creating the channel.
            </para>
            <paramref name="consumeItems"/> is the routine called to consume the items.  Similarly, reading can have just a
            single reader or multiple readers, depending on the value passed into <see cref="P:System.Threading.Channels.ChannelOptions.SingleReader"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities.Convert(System.Int64,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Helper as VB's CType doesn't work without arithmetic overflow.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1">
            <summary>
            Helper class to allow one to do simple regular expressions over a sequence of objects (as
            opposed to a sequence of characters).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Repeat``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m*)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.OneOrMore``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m+)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Choice``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1|m_2|...|m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Sequence``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1 ... m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Single``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Matcher that matches an element if the provide predicate returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker.AddWordParts(System.String,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{Microsoft.CodeAnalysis.Text.TextSpan}@)">
            <summary>
            Breaks an identifier string into constituent parts.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer">
            <summary>
            Provides a way to test two symbols for equivalence.  While there are ways to ask for
            different sorts of equivalence, the following must hold for two symbols to be considered
            equivalent.
            <list type="number">
            <item>The kinds of the two symbols must match.</item>
            <item>The names of the two symbols must match.</item>
            <item>The arity of the two symbols must match.</item>
            <item>If the symbols are methods or parameterized properties, then the signatures of the two
            symbols must match.</item>
            <item>Both symbols must be definitions or must be instantiations.  If they are instantiations,
            then they must be instantiated in the same manner.</item>
            <item>The containing symbols of the two symbols must be equivalent.</item>
            <item>Nullability of symbols is not involved in the comparison.</item>
            </list>
            Note: equivalence does not concern itself with whole symbols.  Two types are considered
            equivalent if the above hold, even if one type has different members than the other.  Note:
            type parameters, and signature parameters are not considered 'children' when comparing
            symbols.
            
            Options are provided to tweak the above slightly.  For example, by default, symbols are
            equivalent only if they come from the same assembly or different assemblies of the same simple name.
            However, one can ask if two symbols are equivalent even if their assemblies differ.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence and populates <paramref name="equivalentTypesWithDifferingAssemblies"/>
            with equivalent non-nested named type key-value pairs that are contained in different assemblies.
            These equivalent named type key-value pairs represent possibly equivalent forwarded types, but this API doesn't perform any type forwarding equivalence checks. 
            </summary>
            <remarks>This API is only supported for <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.IgnoreAssembliesInstance"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.EquivalenceVisitor.HandleNamedTypesWorker(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Worker for comparing two named types for equivalence. Note: The two
            types must have the same TypeKind.
            </summary>
            <param name="x">The first type to compare</param>
            <param name="y">The second type to compare</param>
            <param name="equivalentTypesWithDifferingAssemblies">
            Map of equivalent non-nested types to be populated, such that each key-value pair of named types are equivalent but reside in different assemblies.
            This map is populated only if we are ignoring assemblies for symbol equivalence comparison, i.e. <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer._assemblyComparer"/> is true.
            </param>
            <returns>True if the two types are equivalent.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Transforms baseName into a name that does not conflict with any name in 'reservedNames'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Ensures that any 'names' is unique and does not collide with any other name.  Names that
            are marked as IsFixed can not be touched.  This does mean that if there are two names
            that are the same, and both are fixed that you will end up with non-unique names at the
            end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniquenessInPlace(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.String},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Updates the names in <paramref name="names"/> to be unique.  A name at a particular
            index <c>i</c> will not be touched if <c>isFixed[i]</c> is <see langword="true"/>. All
            other names will not collide with any other in <paramref name="names"/> and will all
            return <see langword="true"/> for <c>canUse(name)</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArrayExtensions.AsRef``1(Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{``0}@)">
             <summary>
             Gets a mutable reference to a <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/> stored in a <c>using</c> variable.
             </summary>
             <remarks>
             <para>This supporting method allows <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/>, a non-copyable <see langword="struct"/>
             implementing <see cref="T:System.IDisposable"/>, to be used with <c>using</c> statements while still allowing them to
             be passed by reference in calls. The following two calls are equivalent:</para>
            
             <code>
             using var array = TemporaryArray&lt;T&gt;.Empty;
            
             // Using the 'Unsafe.AsRef' method
             Method(ref Unsafe.AsRef(in array));
            
             // Using this helper method
             Method(ref array.AsRef());
             </code>
            
             <para> Do not move or rename this method without updating the corresponding
             <see href="https://github.com/dotnet/roslyn-analyzers/blob/30180a51af8c4711e51d98df7345f14d083efb63/src/Roslyn.Diagnostics.Analyzers/Core/TemporaryArrayAsRefAnalyzer.cs">RS0049</see>
             analyzer.</para>
             </remarks>
             <typeparam name="T">The type of element stored in the temporary array.</typeparam>
             <param name="array">A read-only reference to a temporary array which is part of a <c>using</c> statement.</param>
             <returns>A mutable reference to the temporary array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1">
            <summary>
            Provides temporary storage for a collection of elements. This type is optimized for handling of small
            collections, particularly for cases where the collection will eventually be discarded or used to produce an
            <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            </summary>
            <remarks>
            This type stores small collections on the stack, with the ability to transition to dynamic storage if/when
            larger number of elements are added.
            </remarks>
            <typeparam name="T">The type of elements stored in the collection.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.InlineCapacity">
            <summary>
            The number of elements the temporary can store inline. Storing more than this many elements requires the
            array transition to dynamic storage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0">
            <summary>
            The first inline element.
            </summary>
            <remarks>
            This field is only used when <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is <see langword="null"/>. In other words, this type
            stores elements inline <em>or</em> stores them in <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/>, but does not use both approaches
            at the same time.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item1">
            <summary>
            The second inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item2">
            <summary>
            The third inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item3">
            <summary>
            The fourth inline element.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._item0"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._count">
            <summary>
            The number of inline elements held in the array. This value is only used when <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is
            <see langword="null"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder">
            <summary>
            A builder used for dynamic storage of collections that may exceed the limit for inline elements.
            </summary>
            <remarks>
            This field is initialized to non-<see langword="null"/> the first time the <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/>
            needs to store more than four elements. From that point, <see cref="F:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1._builder"/> is used instead of inline
            elements, even if items are removed to make the result smaller than four elements.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ToOneOrManyAndClear">
            <summary>
            Create an <see cref="T:Roslyn.Utilities.OneOrMany`1"/> with the elements currently held in the temporary array, and clear the
            array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ToImmutableAndClear">
            <summary>
            Create an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with the elements currently held in the temporary array, and clear
            the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.MoveInlineToBuilder">
            <summary>
            Transitions the current <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1"/> from inline storage to dynamic storage storage. An
            <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/> instance is taken from the shared pool, and all elements currently in inline
            storage are added to it. After this point, dynamic storage will be used instead of inline storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1.ThrowIndexOutOfRangeException">
            <summary>
            Throws <see cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <remarks>
            This helper improves the ability of the JIT to inline callers.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1">
            <summary>
            Implementation of an <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1"/> backed by a contiguous array of values.  This is a more memory
            efficient way to store an interval tree than the traditional binary tree approach.  This should be used when the 
            values of the interval tree are known up front and will not change after the tree is created.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1._array">
            <summary>
            The nodes of this interval tree flatted into a single array.  The root is as index 0.  The left child of any
            node at index <c>i</c> is at <c>2*i + 1</c> and the right child is at <c>2*i + 2</c>. If a left/right child
            index is beyond the length of this array, that is equivalent to that node not having such a child.
            </summary>
            <remarks>
            The binary tree we represent here is a *complete* binary tree (not to be confused with a *perfect* binary tree).
            A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled,
            and all nodes in the last level are as far left as possible. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1.Algorithms">
            <summary>
            Provides access to lots of common algorithms on this interval tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1.CreateFromUnsorted``1(``0@,Microsoft.CodeAnalysis.Collections.SegmentedList{`0})">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1"/> from an unsorted list of <paramref name="values"/>.  This will
            incur a delegate allocation to sort the values.  If callers can avoid that allocation by pre-sorting the values,
            they should do so and call <see cref="M:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1.CreateFromSorted``1(``0@,Microsoft.CodeAnalysis.Collections.SegmentedList{`0})"/> instead.
            </summary>
            <remarks>
            <paramref name="values"/> will be sorted in place.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1.CreateFromSorted``1(``0@,Microsoft.CodeAnalysis.Collections.SegmentedList{`0})">
            <summary>
            Creates an interval tree from a sorted list of values.  This is more efficient than creating from an unsorted
            list as building doesn't need to figure out where the nodes need to go n-log(n) and doesn't have to rebalance
            anything (again, another n-log(n) operation).  Rebalancing is particularly expensive as it involves tons of
            pointer chasing operations, which is both slow, and which impacts the GC which has to track all those writes.
            </summary>
            <remarks>
            The values must be sorted such that given any two elements 'a' and 'b' in the list, if 'a' comes before 'b' in
            the list, then it's "start position" (as determined by the introspector) must be less than or equal to 'b's
            start position.  This is a requirement for the algorithm to work correctly.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1.FlatArrayIntervalTreeWitness">
            <summary>
            Wrapper type to allow the IntervalTreeHelpers type to work with this type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTester`2">
            <summary>
            Generic interface used to pass in the particular interval testing operation to performed on an interval tree. For
            example checking if an interval 'contains', 'intersects', or 'overlaps' with a requested span.  Will be erased at 
            runtime as it will always be passed through as a generic parameter that is a struct.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1">
            <summary>
            Base interface all interval trees need to implement to get full functionality.  Callers are not expected to use
            these methods directly.  Instead, they are the low level building blocks that the higher level extension methods are
            built upon. Consumers of an interval tree should use <c>.Algorithms</c> on the instance to get access to a wealth of
            fast operations through the <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeAlgorithms`2"/> type.
            </summary>
            <remarks>
            Iterating an interval tree will return the intervals in sorted order based on the start point of the interval.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1.FillWithIntervalsThatMatch``2(System.Int32,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{`0}@,``0@,``1@,System.Boolean)">
            <summary>
            Adds all intervals within the tree within the given start/length pair that match the given <paramref
            name="intervalTester"/> predicate.  Results are added to the <paramref name="builder"/> array.  The <paramref
            name="stopAfterFirst"/> indicates if the search should stop after the first interval is found.  Results will be
            returned in a sorted order based on the start point of the interval.
            </summary>
            <returns>The number of matching intervals found by the method.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1.Any``2(System.Int32,System.Int32,``0@,``1@)">
            <summary>
            Practically equivalent to <see cref="M:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1.FillWithIntervalsThatMatch``2(System.Int32,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{`0}@,``0@,``1@,System.Boolean)"/> with a check that at least one item was
            found.  However, separated out as a separate method as implementations can often be more efficient just
            answering this question, versus the more complex "fill with intervals" question above.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeAlgorithms`2">
            <summary>
            Helpers for working with <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1"/> instances.  Can be retrieved by calling <c>.Extensions</c>
            on an interval tree instance.  This is exposed as a struct instead of extension methods as the type inference
            involved here is too complex for C# to handle (specifically using a <c>TIntervalTree</c> type), which would make
            ergonomics extremely painful as the callsites would have to pass three type arguments along explicitly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeAlgorithms`2.#ctor(`1)">
            <summary>
            Helpers for working with <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1"/> instances.  Can be retrieved by calling <c>.Extensions</c>
            on an interval tree instance.  This is exposed as a struct instead of extension methods as the type inference
            involved here is too complex for C# to handle (specifically using a <c>TIntervalTree</c> type), which would make
            ergonomics extremely painful as the callsites would have to pass three type arguments along explicitly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTreeWitness`3">
            <summary>
            Witness interface that allows transparent access to information about a specific <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1"/>
            implementation without needing to know the specifics of that implementation.  This allows <see
            cref="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeHelpers`4"/> to operate transparently over any
            implementation.  IntervalTreeHelpers constrains its TIntervalTreeWitness type to be a struct to ensure this can be
            entirely reified and erased by the runtime.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeHelpers`4">
            <summary>
            Utility helpers used to allow code sharing for the different implementations of <see cref="T:Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeHelpers`4.Enumerator.AlwaysThrowIntrospector">
            <summary>
            An introspector that always throws.  Used when we need to call an api that takes this, but we know will never
            call into it due to other arguments we pass along.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeHelpers`4.Enumerator._nodeEnumerator">
            <summary>
            Because we're passing the full span of all ints, we know that we'll never call into the introspector.  Since
            all intervals will always be in that span.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeHelpers`4.NodeEnumerator`1">
            <summary>
            Struct based enumerator, so we can iterate an interval tree without allocating.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.MutableIntervalTree`1">
            <summary>
            An interval tree represents an ordered tree data structure to store intervals of the form [start, end).  It allows
            you to efficiently find all intervals that intersect or overlap a provided interval.
            </summary>
            <remarks>
            Ths is the root type for all interval trees that store their data in a binary tree format.  This format is good for
            when mutation of the tree is expected, and a client wants to perform tests before and after such mutation.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Collections.MutableIntervalTree`1.Algorithms">
            <summary>
            Provides access to lots of common algorithms on this interval tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.MutableIntervalTree`1.BinaryIntervalTreeWitness">
            <summary>
            Wrapper type to allow the IntervalTreeHelpers type to work with this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.SimpleMutableIntervalTree`2.AddIntervalInPlace(`0)">
            <summary>
            Warning.  Mutates the tree in place.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that is
            empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified span.
            </summary>
            <param name="span">TextSpan contained by the span set.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified list of spans.
            </summary>
            <param name="spans">The spans to be added.</param>
            <remarks>
            <para>The list of spans will be sorted and normalized (overlapping and adjoining spans will be combined).</para>
            <para>This constructor runs in O(N log N) time, where N = spans.Count.</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="spans"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Union(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the union of two span sets.
            </summary>
            <param name="left">
            The first span set.
            </param>
            <param name="right">
            The second span set.
            </param>
            <returns>
            The new span set that corresponds to the union of <paramref name="left"/> and <paramref name="right"/>.
            </returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException">Either <paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Overlap(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the overlap of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the overlap of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Intersection(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the intersection of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the intersection of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Difference(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the difference between two sets. The difference is defined as everything in the first span set that is not in the second span set.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the difference between <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>
            Empty spans in the second set do not affect the first set at all. This method returns empty spans in the first set that are not contained by any set in
            the second set.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Equality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are the same. 
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Inequality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are not the same.
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are not equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set overlaps with another span set.
            </summary>
            <param name="set">The span set to test.</param>
            <returns><c>true</c> if the span sets overlap, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set overlaps with another span.
            </summary>
            <param name="span">The span to test.</param>
            <returns><c>true</c> if this span set overlaps with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set intersects with another span set.
            </summary>
            <param name="set">Set to test.</param>
            <returns><c>true</c> if the span sets intersect, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set intersects with another span.
            </summary>
            <returns><c>true</c> if this span set intersects with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.GetHashCode">
            <summary>
            Gets a unique hash code for the span set.
            </summary>
            <returns>A 32-bit hash code associated with the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Equals(System.Object)">
            <summary>
            Determines whether this span set is the same as another object.
            </summary>
            <param name="obj">The object to test.</param>
            <returns><c>true</c> if the two objects are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.ToString">
            <summary>
            Provides a string representation of the set.
            </summary>
            <returns>The string representation of the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OrderedSpanList)">
            <summary>
            Private constructor for use when the span list is already normalized.
            </summary>
            <param name="normalizedSpans">An already normalized span list.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SimplificationOptions">
            <summary>
            Contains the options that needs to be drilled down to the Simplification Engine
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferAliasToQualification">
            <summary>
            This option tells the simplification engine if the Qualified Name should be replaced by Alias
            if the user had initially not used the Alias
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferOmittingModuleNamesInQualification">
            <summary>
            This option influences the name reduction of members of a module in VB. If set to true, the 
            name reducer will e.g. reduce Namespace.Module.Member to Namespace.Member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferImplicitTypeInference">
            <summary>
            This option says that if we should simplify the Generic Name which has the type argument inferred
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferImplicitTypeInLocalDeclaration">
            <summary>
            This option says if we should simplify the Explicit Type in Local Declarations
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.AllowSimplificationToGenericType">
            <summary>
            This option says if we should simplify to NonGeneric Name rather than GenericName
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.AllowSimplificationToBaseType">
            <summary>
            This option says if we should simplify from Derived types to Base types in Static Member Accesses
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyMemberAccessWithThisOrMe">
            <summary>
            This option says if we should simplify away the <see langword="this"/> or <see langword="Me"/> in member access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyFieldAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in field access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyPropertyAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in property access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyMethodAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in method access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyEventAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in event access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferIntrinsicPredefinedTypeKeywordInDeclaration">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Declarations
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferIntrinsicPredefinedTypeKeywordInMemberAccess">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Member Access Expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.Simplifier">
            <summary>
            Expands and Reduces subtrees.
            
            Expansion:
                 1) Makes inferred names explicit (on anonymous types and tuples).
                 2) Replaces names with fully qualified dotted names.
                 3) Adds parentheses around expressions
                 4) Adds explicit casts/conversions where implicit conversions exist
                 5) Adds escaping to identifiers
                 6) Rewrites extension method invocations with explicit calls on the class containing the extension method.
                 
            Reduction:
                1) Shortens dotted names to their minimally qualified form
                2) Removes unnecessary parentheses
                3) Removes unnecessary casts/conversions
                4) Removes unnecessary escaping
                5) Rewrites explicit calls to extension methods to use dot notation
                6) Removes unnecessary tuple element names and anonymous type member names
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation">
            <summary>
            The annotation the reducer uses to identify sub trees to be reduced.
            The Expand operations add this annotation to nodes so that the Reduce operations later find them.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.Simplifier.SpecialTypeAnnotation">
            <summary>
            This is the annotation used by the simplifier and expander to identify Predefined type and preserving
            them from over simplification
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.Simplifier.AddImportsAnnotation">
            <summary>
            The annotation <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.CleanupDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions,System.Threading.CancellationToken)"/> used to identify sub trees to look for symbol annotations on.
            It will then add import directives for these symbol annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ExpandAsync``1(``0,Microsoft.CodeAnalysis.Document,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand``1(``0,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand``1(``0,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Host.SolutionServices,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ExpandAsync(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Document,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Host.SolutionServices,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce all sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the document. The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the subtrees identified with the specified <paramref name="annotation"/>.
            The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the specified span.
            The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the specified spans.
            The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.AliasAnnotation">
            <summary>
            This annotation will be used by the expansion/reduction to annotate expanded syntax nodes to store the information that an 
            alias was used before expansion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.DoNotAllowVarAnnotation">
            <summary>
            When applied to a SyntaxNode, prevents the simplifier from converting a type to 'var'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Simplification.SimplifierOptions.CommonDefaults">
            <summary>
            Language agnostic defaults.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SymbolAnnotation">
            <summary>
            An annotation that holds onto information about a type or namespace symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifiers.AbstractMemberAccessExpressionSimplifier`3.ShouldSimplifyThisMemberAccessExpression(`1,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Simplification.SimplifierOptions,`2@,Microsoft.CodeAnalysis.CodeStyle.NotificationOption2@,System.Threading.CancellationToken)">
            <summary>
            Checks a member access expression <c>expr.Name</c> and, if it is of the form <c>this.Name</c> or
            <c>Me.Name</c> determines if it is safe to replace with just <c>Name</c> alone.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.VisibleFilesAndOpenFilesWithPreviouslyReportedDiagnostics">
            <summary>
            Analyzers are computed for visible documents
            and open documents which had errors/warnings in the prior solution snapshot.
            We want to analyze such non-visible, open documents to ensure that these
            prior reported errors/warnings get cleared out from the error list if they are
            no longer valid in the latest solution snapshot, hence ensuring error list has
            no stale entries.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.OpenFiles">
            <summary>
            Analyzers are executed for all open documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.FullSolution">
            <summary>
            Analyzers are executed for all documents in the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.None">
            <summary>
            Analyzers are disabled for all documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.CompilerDiagnosticsScope.None">
            <summary>
            Compiler warnings and errors are disabled for all documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.CompilerDiagnosticsScope.VisibleFilesAndOpenFilesWithPreviouslyReportedDiagnostics">
            <summary>
            Compiler warnings and errors are computed for visible documents
            and open documents which had errors/warnings in the prior solution snapshot.
            We want to analyze such non-visible, open documents to ensure that these
            prior reported errors/warnings get cleared out from the error list if they are
            no longer valid in the latest solution snapshot, hence ensuring error list has
            no stale entries.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.CompilerDiagnosticsScope.OpenFiles">
            <summary>
            Compiler warnings and errors are computed for all open documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.CompilerDiagnosticsScope.FullSolution">
            <summary>
            Compiler warnings and errors are computed for all documents in the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneration.IRemoteSourceGenerationService.GetSourceGeneratedDocumentInfoAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.ProjectId,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Given a particular project in the remote solution snapshot, return information about all the generated documents
            in that project.  The information includes the <see cref="T:Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity"/> identity
            information about the document, as well as its text <see cref="T:Microsoft.CodeAnalysis.Checksum"/>.  The local workspace can then
            compare that to the prior generated documents it has to see if it can reuse those directly, or if it needs to
            remove any documents no longer around, add any new documents, or change the contents of any existing documents.
            </summary>
            <param name="withFrozenSourceGeneratedDocuments">Controls if the caller wants frozen source generator documents
            included in the result, or if only the most underlying generated documents (produced by the real compiler <see
            cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/> should be included.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneration.IRemoteSourceGenerationService.GetContentsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Given a particular set of generated document ids, returns the fully generated content for those documents.
            Should only be called by the host for documents it does not know about, or documents whose checksum contents are
            different than the last time the document was queried.
            </summary>
            <param name="withFrozenSourceGeneratedDocuments">Controls if the caller wants frozen source generator documents
            included in the result, or if only the most underlying generated documents (produced by the real compiler <see
            cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/> should be included.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneration.IRemoteSourceGenerationService.HasGeneratorsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Checksum},System.String,System.Threading.CancellationToken)">
            <summary>
            Whether or not the specified analyzer references have source generators or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneration.IRemoteSourceGenerationService.GetSourceGeneratorIdentitiesAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.ProjectId,System.String,System.Threading.CancellationToken)">
            <summary>
            Returns the identities for all source generators found in the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> with <see
            cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.FullPath"/> equal to <paramref name="analyzerReferenceFullPath"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneration.IRemoteSourceGenerationService.HasAnalyzersOrSourceGeneratorsAsync(Microsoft.CodeAnalysis.Checksum,Microsoft.CodeAnalysis.ProjectId,System.String,System.Threading.CancellationToken)">
            <summary>
            Returns whether or not the the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.FullPath"/>
            equal to <paramref name="analyzerReferenceFullPath"/> has any analyzers or source generators.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneration.SourceGeneratedDocumentContentIdentity">
            <summary>
            Information that uniquely identifies the content of a source-generated document and ensures the remote and local
            hosts are in agreement on them.
            </summary>
            <param name="OriginalSourceTextContentHash">Checksum originally produced from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetChecksum"/> on
            the server side.  This may technically not be the same checksum that is produced on the client side once the
            SourceText is hydrated there.  See comments on <see
            cref="M:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.GetOriginalSourceTextContentHash"/> for more details on when this happens.</param>
            <param name="EncodingName">Result of <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Encoding"/>'s <see cref="P:System.Text.Encoding.WebName"/>.</param>
            <param name="ChecksumAlgorithm">Result of <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.ChecksumAlgorithm"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneration.SourceGeneratedDocumentContentIdentity.#ctor(Microsoft.CodeAnalysis.Checksum,System.String,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Information that uniquely identifies the content of a source-generated document and ensures the remote and local
            hosts are in agreement on them.
            </summary>
            <param name="OriginalSourceTextContentHash">Checksum originally produced from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetChecksum"/> on
            the server side.  This may technically not be the same checksum that is produced on the client side once the
            SourceText is hydrated there.  See comments on <see
            cref="M:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.GetOriginalSourceTextContentHash"/> for more details on when this happens.</param>
            <param name="EncodingName">Result of <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Encoding"/>'s <see cref="P:System.Text.Encoding.WebName"/>.</param>
            <param name="ChecksumAlgorithm">Result of <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.ChecksumAlgorithm"/>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SourceGeneration.SourceGeneratedDocumentContentIdentity.OriginalSourceTextContentHash">
            <summary>Checksum originally produced from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetChecksum"/> on
            the server side.  This may technically not be the same checksum that is produced on the client side once the
            SourceText is hydrated there.  See comments on <see
            cref="M:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.GetOriginalSourceTextContentHash"/> for more details on when this happens.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SourceGeneration.SourceGeneratedDocumentContentIdentity.EncodingName">
            <summary>Result of <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.Encoding"/>'s <see cref="P:System.Text.Encoding.WebName"/>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SourceGeneration.SourceGeneratedDocumentContentIdentity.ChecksumAlgorithm">
            <summary>Result of <see cref="P:Microsoft.CodeAnalysis.Text.SourceText.ChecksumAlgorithm"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceGeneratorTelemetry.SourceGeneratorTelemetryCollectorWorkspaceService._generatorTelemetryKeys">
            <summary>
            Cache of the <see cref="T:Microsoft.CodeAnalysis.SourceGeneratorTelemetry.SourceGeneratorTelemetryCollectorWorkspaceService.GeneratorTelemetryKey"/> for a generator to avoid repeatedly reading version information from disk;
            this is a ConditionalWeakTable so having telemetry for older runs doesn't keep the generator itself alive.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService.#ctor(Microsoft.CodeAnalysis.Host.IPersistentStorageConfiguration)">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService.TryOpenDatabaseAsync(Microsoft.CodeAnalysis.Storage.SolutionKey,System.String,System.String,Microsoft.CodeAnalysis.Host.IPersistentStorageFaultInjector,System.Threading.CancellationToken)">
            <summary>
            Can throw.  If it does, the caller (<see cref="M:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService.CreatePersistentStorageAsync(Microsoft.CodeAnalysis.Storage.SolutionKey,System.String,Microsoft.CodeAnalysis.Host.IPersistentStorageFaultInjector,System.Threading.CancellationToken)"/>) will attempt
            to delete the database and retry opening one more time.  If that fails again, the <see
            cref="T:Microsoft.CodeAnalysis.Host.NoOpPersistentStorage"/> instance will be used.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.LegacyPersistentStorageService">
            <summary>
            Obsolete.  Roslyn no longer supports a mechanism to perform arbitrary persistence of data.  If such functionality
            is needed, consumers are responsible for providing it themselves with whatever semantics are needed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.DocumentKey">
            <summary>
            Handle that can be used with <see cref="T:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage"/> to read data for a
            <see cref="T:Microsoft.CodeAnalysis.Document"/> without needing to have the entire <see cref="T:Microsoft.CodeAnalysis.Document"/> snapshot available.
            This is useful for cases where acquiring an entire snapshot might be expensive (for example, during 
            solution load), but querying the data is still desired.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Storage.DocumentKey.#ctor(Microsoft.CodeAnalysis.Storage.ProjectKey,Microsoft.CodeAnalysis.DocumentId,System.String,System.String)">
            <summary>
            Handle that can be used with <see cref="T:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage"/> to read data for a
            <see cref="T:Microsoft.CodeAnalysis.Document"/> without needing to have the entire <see cref="T:Microsoft.CodeAnalysis.Document"/> snapshot available.
            This is useful for cases where acquiring an entire snapshot might be expensive (for example, during 
            solution load), but querying the data is still desired.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.ProjectKey">
            <summary>
            Handle that can be used with <see cref="T:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage"/> to read data for a
            <see cref="T:Microsoft.CodeAnalysis.Project"/> without needing to have the entire <see cref="T:Microsoft.CodeAnalysis.Project"/> snapshot available.
            This is useful for cases where acquiring an entire snapshot might be expensive (for example, during 
            solution load), but querying the data is still desired.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Storage.ProjectKey.#ctor(Microsoft.CodeAnalysis.Storage.SolutionKey,Microsoft.CodeAnalysis.ProjectId,System.String,System.String,Microsoft.CodeAnalysis.Checksum)">
            <summary>
            Handle that can be used with <see cref="T:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage"/> to read data for a
            <see cref="T:Microsoft.CodeAnalysis.Project"/> without needing to have the entire <see cref="T:Microsoft.CodeAnalysis.Project"/> snapshot available.
            This is useful for cases where acquiring an entire snapshot might be expensive (for example, during 
            solution load), but querying the data is still desired.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.SolutionKey">
            <summary>
            Handle that can be used with <see cref="T:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage"/> to read data for a
            <see cref="T:Microsoft.CodeAnalysis.Solution"/> without needing to have the entire <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot available.
            This is useful for cases where acquiring an entire snapshot might be expensive (for example, during 
            solution load), but querying the data is still desired.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Storage.SolutionKey.#ctor(Microsoft.CodeAnalysis.SolutionId,System.String)">
            <summary>
            Handle that can be used with <see cref="T:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage"/> to read data for a
            <see cref="T:Microsoft.CodeAnalysis.Solution"/> without needing to have the entire <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot available.
            This is useful for cases where acquiring an entire snapshot might be expensive (for example, during 
            solution load), but querying the data is still desired.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.Interop.NativeMethods.sqlite3_bind_text(Microsoft.CodeAnalysis.SQLite.Interop.SafeSqliteStatementHandle,System.Int32,System.ReadOnlySpan{System.Byte})">
            <summary>
            <paramref name="val"><see cref="P:System.Text.Encoding.UTF8"/> encoded bytes of a text value.  Span
            should not be NUL-terminated.</paramref>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.Database.Main">
            <summary>
            The database that is stored on disk and actually persists data across VS sessions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.Database.WriteCache">
            <summary>
            An in-memory database that caches values before being transferred to <see
            cref="F:Microsoft.CodeAnalysis.SQLite.v2.Database.Main"/>.  Does not persist across VS sessions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.DatabaseExtensions.GetName(Microsoft.CodeAnalysis.SQLite.v2.Database)">
             <summary>
             Name of the different dbs.
             
             1. "main" is the default that sqlite uses.  This just allows us to be explicit that we
             want this db.
            
             2. "writecache" is the name for the in-memory write-cache db.  Writes will be staged
             there and will be periodically flushed to the real on-disk db to help with perf.
            
             Perf measurements show this as significantly better than all other design options. It's
             also one of the simplest in terms of the design.
            
             The design options in order of performance (slowest to fastest) are:
            
             1. send writes directly to the main db. this is incredibly slow (since each write incurs
             the full IO overhead of a transaction). It is the absolute simplest in terms of
             implementation though.
            
             2. send writes to a temporary on-disk db (with synchronous=off and journal_mode=memory),
             then flush those to the main db.  This is also quite slow due to their still needing to
             be disk IO with each write.  Implementation is fairly simple, with writes just going to
             the temp db and reads going to both.
            
             3. Buffer writes in (.net) memory and flush them to disk.  This is much faster than '1'
             or '2' but requires a lot of manual book-keeping and extra complexity. For example, any
             reads go to the db.  So that means that reads have to ensure that any writes to the same
             rows have been persisted so they can observe them.
            
             4. send writes to an sqlite in-memory cache DB.  This is extremely fast for sqlite as
             there is no actual IO that is performed.  It is also easy in terms of bookkeeping as
             both DBs have the same schema and are easy to move data between. '4' is faster than all
             of the above. Complexity is minimized as reading can be done just by examining both DBs
             in the same way. It's not as simple as '1' but it's much simpler than '3'.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.ResettableSqlStatement">
             <summary>
             Simple wrapper struct for a <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/> that helps ensure that the statement is always has it's
             bindings cleared (<see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.ClearBindings"/>) and is <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Reset"/> after it is
             used.
             <para/>
             See https://sqlite.org/c3ref/stmt.html:
             The life-cycle of a prepared statement object usually goes like this:
                1) Create the prepared statement object using sqlite3_prepare_v2().
                2) Bind values to parameters using the sqlite3_bind_* () interfaces.
                3) Run the SQL by calling sqlite3_step() one or more times.
                4) Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
                5) Destroy the object using sqlite3_finalize().
            
             This type helps ensure that '4' happens properly by clients executing statement.
             Note that destroying/finalizing a statement is not the responsibility of a client
             as it will happen to all prepared statemnets when the <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/> is
             <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Close_OnlyForUseBySqlConnection"/>d.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.ResettableSqlStatement.#ctor(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement)">
             <summary>
             Simple wrapper struct for a <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/> that helps ensure that the statement is always has it's
             bindings cleared (<see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.ClearBindings"/>) and is <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Reset"/> after it is
             used.
             <para/>
             See https://sqlite.org/c3ref/stmt.html:
             The life-cycle of a prepared statement object usually goes like this:
                1) Create the prepared statement object using sqlite3_prepare_v2().
                2) Bind values to parameters using the sqlite3_bind_* () interfaces.
                3) Run the SQL by calling sqlite3_step() one or more times.
                4) Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
                5) Destroy the object using sqlite3_finalize().
            
             This type helps ensure that '4' happens properly by clients executing statement.
             Note that destroying/finalizing a statement is not the responsibility of a client
             as it will happen to all prepared statemnets when the <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/> is
             <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Close_OnlyForUseBySqlConnection"/>d.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection">
            <summary>
            Encapsulates a connection to a sqlite database.  On construction an attempt will be made
            to open the DB if it exists, or create it if it does not.
            
            Connections are considered relatively heavyweight and are pooled (see <see
            cref="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.GetPooledConnection(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection@)"/>).  Connections can be used by different
            threads, but only as long as they are used by one thread at a time.  They are not safe for concurrent use by several
            threads.
            
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/>s can be created through the user of <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.GetResettableStatement(System.String)"/>.
            These statements are cached for the lifetime of the connection and are only finalized
            (i.e. destroyed) when the connection is closed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection._handle">
            <summary>
            The raw handle to the underlying DB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection._queryToStatement">
            <summary>
            Our cache of prepared statements for given sql strings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.IsInTransaction">
            <summary>
            Whether or not we're in a transaction.  We currently don't supported nested transactions.
            If we want that, we can achieve it through sqlite "save points".  However, that's adds a 
            lot of complexity that is nice to avoid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.RunInTransaction``1(System.Action{``0},``0,System.Boolean)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.RunInTransaction``2(System.Func{``0,``1},``0,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.RunInTransaction``2(System.Func{``0,``1},``0,System.Boolean)">
            <param name="throwOnSqlException">If a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlException"/> that happens during excution of <paramref
            name="action"/> should bubble out of this method or not.  If <see langword="false"/>, then the exception
            will be returned in the result value instead</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement">
            <summary>
            Represents a prepared sqlite statement.  <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/>s can be 
            <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Step(System.Boolean)"/>ed (i.e. executed).  Executing a statement can result in 
            either <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.DONE"/> if the command completed and produced no
            value, or <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.ROW"/> if it evaluated out to a sql row that can
            then be queried.
            <para>
            If a statement is parameterized then parameters can be provided by the 
            BindXXX overloads.  Bind is 1-based (to match sqlite).</para>
            <para>
            When done executing a statement, the statement should be <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Reset"/>.
            The easiest way to ensure this is to just use a 'using' statement along with
            a <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.ResettableSqlStatement"/>.  By resetting the statement, it can
            then be used in the future with new bound parameters.</para>
            <para>
            Finalization/destruction of the underlying raw sqlite statement is handled
            by <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.Close_OnlyForUseBySQLiteConnectionPool"/>.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.#ctor(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection,Microsoft.CodeAnalysis.SQLite.Interop.SafeSqliteStatementHandle)">
            <summary>
            Represents a prepared sqlite statement.  <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement"/>s can be 
            <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Step(System.Boolean)"/>ed (i.e. executed).  Executing a statement can result in 
            either <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.DONE"/> if the command completed and produced no
            value, or <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.ROW"/> if it evaluated out to a sql row that can
            then be queried.
            <para>
            If a statement is parameterized then parameters can be provided by the 
            BindXXX overloads.  Bind is 1-based (to match sqlite).</para>
            <para>
            When done executing a statement, the statement should be <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement.Reset"/>.
            The easiest way to ensure this is to just use a 'using' statement along with
            a <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.ResettableSqlStatement"/>.  By resetting the statement, it can
            then be used in the future with new bound parameters.</para>
            <para>
            Finalization/destruction of the underlying raw sqlite statement is handled
            by <see cref="M:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection.Close_OnlyForUseBySQLiteConnectionPool"/>.</para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage">
            <summary>
            Implementation of an <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> backed by SQLite.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.GetPooledConnection(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection@)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection"/> from the connection pool, or creates one if none are available.
            </summary>
            <remarks>
            Database connections have a large amount of overhead, and should be returned to the pool when they are no
            longer in use. In particular, make sure to avoid letting a connection lease cross an <see langword="await"/>
            boundary, as it will prevent code in the asynchronous operation from using the existing connection.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.GetPooledConnection(System.Boolean,Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection@)">
            <summary>
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.GetPooledConnection(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection@)"/>
            Only use this overload if it is safe to bypass the normal scheduler check.  Only startup code (which runs
            before any reads/writes/flushes happen) should use this.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2">
            <summary>
            Abstracts out access to specific tables in the DB.  This allows us to share overall
            logic around cancellation/pooling/error-handling/etc, while still hitting different
            db tables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2.TryGetDatabaseKey(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection,`0,System.Boolean)">
            <summary>
            Gets the internal sqlite db-id (effectively the row-id for the doc or proj table, or just the string-id
            for the solution table) for the provided caller key.  This db-id will be looked up and returned if a
            mapping already exists for it in the db.  Otherwise, a guaranteed unique id will be created for it and
            stored in the db for the future.  This allows all associated data to be cheaply associated with the 
            simple ID, avoiding lots of db bloat if we used the full <paramref name="key"/> in numerous places.
            </summary>
            <param name="allowWrite">Whether or not the caller owns the write lock and thus is ok with the DB id
            being generated and stored for this component key when it currently does not exist.  If <see
            langword="false"/> then failing to find the key will result in <see langword="false"/> being returned.
            </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.DatabaseOwnership">
            <summary>
            Lock file that ensures only one database is made per process per solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage._faultInjector">
            <summary>
            For testing purposes.  Allows us to test what happens when we fail to acquire the db lock file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Scheduler">
             <summary>
             Use a <see cref="T:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair"/> to simulate a reader-writer lock.
             Read operations are performed on the <see cref="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentScheduler"/>
             and writes are performed on the <see cref="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveScheduler"/>.
            
             We use this as a condition of using the in-memory shared-cache sqlite DB.  This DB
             doesn't busy-wait when attempts are made to lock the tables in it, which can lead to
             deadlocks.  Specifically, consider two threads doing the following:
            
             Thread A starts a transaction that starts as a reader, and later attempts to perform a
             write. Thread B is a writer (either started that way, or started as a reader and
             promoted to a writer first). B holds a RESERVED lock, waiting for readers to clear so it
             can start writing. A holds a SHARED lock (it's a reader) and tries to acquire RESERVED
             lock (so it can start writing).  The only way to make progress in this situation is for
             one of the transactions to roll back. No amount of waiting will help, so when SQLite
             detects this situation, it doesn't honor the busy timeout.
            
             To prevent this scenario, we control our access to the db explicitly with operations that
             can concurrently read, and operations that exclusively write.
            
             All code that reads or writes from the db should go through this.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.TryGetDatabaseOwnership(System.String)">
            <summary>
            Returns null in the case where an IO exception prevented us from being able to acquire
            the db lock file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage._documentIdToPrimaryKeyMap">
            <summary>
            Mapping from the workspace's ID for a document, to the ID we use in the DB for the document.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.TryGetDocumentPrimaryKey(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection,Microsoft.CodeAnalysis.Storage.DocumentKey,System.Boolean)">
            <summary>
            Given a document, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the DocumentData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.DocumentAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.DocumentDataTableName"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.DocumentAccessor.#ctor(Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage)">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.DocumentDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage._flushQueue">
            <summary>
            A queue to batch up flush requests and ensure that we don't issue then more often than every <see
            cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.FlushAllDelayMS"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.FlushAllDelayMS">
            <summary>
            Amount of time to wait between flushing writes to disk.  500ms means we can flush
            writes to disk two times a second.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.MaxPooledByteArrayLength">
            <summary>
            We use a pool to cache reads/writes that are less than 4k.  Testing with Roslyn,
            99% of all writes (48.5k out of 49.5k) are less than that size.  So this helps
            ensure that we can pool as much as possible, without caching excessively large 
            arrays (for example, Roslyn does write out nearly 50 chunks that are larger than
            100k each).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.MaxPooledByteArrays">
            <summary>
            The max amount of byte[]s we cache.  This caps our cache at 4MB while allowing
            us to massively speed up writing (by batching writes).  Because we can write to
            disk two times a second.  That means a total of 8MB/s that can be written to disk
            using only our cache.  Given that Roslyn itself only writes about 50MB to disk
            after several minutes of analysis, this amount of bandwidth is more than sufficient.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage._projectIdToPrimaryKeyMap">
            <summary>
            Mapping from the workspace's ID for a project, to the ID we use in the DB for the project.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.TryGetProjectPrimaryKey(Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection,Microsoft.CodeAnalysis.Storage.ProjectKey,System.Boolean)">
            <summary>
            Given a project, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the ProjectData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.ProjectAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2"/> responsible for storing and
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.ProjectDataTableName"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.ProjectAccessor.#ctor(Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage)">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2"/> responsible for storing and
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.ProjectDataTableName"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.SolutionAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.SolutionDataTableName"/>.  Note that with the Solution 
            table there is no need for key->id translation.  i.e. the key acts as the ID itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.SolutionAccessor.#ctor(Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage)">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage.Accessor`2"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.SolutionDataTableName"/>.  Note that with the Solution 
            table there is no need for key->id translation.  i.e. the key acts as the ID itself.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.StringInfoTableName">
             <summary>
             Inside the DB we have a table dedicated to storing strings that also provides a unique
             integral ID per string.  This allows us to store data keyed in a much more efficient
             manner as we can use those IDs instead of duplicating strings all over the place.  For
             example, there may be many pieces of data associated with a file.  We don't want to
             key off the file path in all these places as that would cause a large amount of bloat.
            
             Because the string table can map from arbitrary strings to unique IDs, it can also be
             used to create IDs for compound objects.  For example, given the IDs for the FilePath
             and Name of a Project, we can get an ID that represents the project itself by just
             creating a compound key of those two IDs.  This ID can then be used in other compound
             situations.  For example, a Document's ID is creating by compounding its Project's
             ID, along with the IDs for the Document's FilePath and Name.
            
             The format of the table is:
            
              StringInfo
              --------------------------------------------------------------------
              | StringDataId (int, primary key, auto increment) | Data (varchar) |
              --------------------------------------------------------------------
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.SolutionDataTableName">
             <summary>
             Inside the DB we have a table for data corresponding to the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.  The
             data is just a blob that is keyed by a string Id.  Data with this ID can be retrieved
             or overwritten.
            
             The format of the table is:
            
              <code>
              SolutionData
              ----------------------------------------------------
              | DataNameId (int) | Checksum (blob) | Data (blob) |
              ----------------------------------------------------
              | Primary Key      |
              --------------------
              </code>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.ProjectDataTableName">
             <summary>
             Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Project"/>. The data is
             keyed off of the path of the project and its name.  That way different TFMs will have different keys.
            
             The format of the table is:
            
              <code>
              ProjectData
              ------------------------------------------------------------------------------------------------
              | ProjectPathId (int) | ProjectNameId (int) | DataNameId (int) | Checksum (blob) | Data (blob) |
              ------------------------------------------------------------------------------------------------
              | Primary Key                                                  |
              ----------------------------------------------------------------
              </code>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants.DocumentDataTableName">
             <summary>
             Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Document"/>. The data is
             keyed off the project information, and the folder and name of the document itself.  This allows the majority
             of the key to be shared (project path/name, and folder name) with other documents, and only having the doc
             name portion be distinct.  Different TFM flavors will also share everything but the project name.
            
             The format of the table is:
            
              <code>
              DocumentData
              ------------------------------------------------------------------------------------------------------------------------------------------------
              | ProjectPathId (int) | ProjectNameId (int) | DocumentFolderId (int) | DocumentNameId (int) | DataNameId (int) | Checksum (blob) | Data (blob) |
              ------------------------------------------------------------------------------------------------------------------------------------------------
              | Primary Key                                                                                                    |
              ------------------------------------------------------------------------------------------------------------------
              </code>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService.FindPackagesWithTypeAsync(System.String,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Searches for packages that contain a type with the provided name and arity.
            Note: Implementations are free to return the results they feel best for the
            given data.  Specifically, they can do exact or fuzzy matching on the name.
            They can use or ignore the arity depending on their capabilities. 
            
            Implementations should return results in order from best to worst (from their
            perspective).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService.FindPackagesWithAssemblyAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Searches for packages that contain an assembly with the provided name.
            Note: Implementations are free to return the results they feel best for the
            given data.  Specifically, they can do exact or fuzzy matching on the name.
            
            Implementations should return results in order from best to worst (from their
            perspective).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService.FindReferenceAssembliesWithTypeAsync(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Searches for reference assemblies that contain a type with the provided name and arity.
            Note: Implementations are free to return the results they feel best for the
            given data.  Specifically, they can do exact or fuzzy matching on the name.
            They can use or ignore the arity depending on their capabilities. 
            
            Implementations should return results in order from best to worst (from their
            perspective).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchUpdateEngine">
            <summary>
            Service that allows you to query the SymbolSearch database and which keeps 
            the database up to date.  
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TaskList.IRemoteTaskListService">
            <summary>
            Interface to allow host (VS) to inform the OOP service to start incrementally analyzing and
            reporting results back to the host.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TaskList.ITaskListService">
            <summary>
            Determines locations of 'todo' comments within a particular file.  The specific 'todo' comment forms (e.g.
            '<c>TODO</c>', '<c>UNDONE</c>', etc.) are provided through <see cref="T:Microsoft.CodeAnalysis.TaskList.TaskListItemDescriptor"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TaskList.TaskListItem">
            <summary>
            Serialization type used to pass information to/from OOP and VS.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TaskList.TaskListItem.#ctor(Microsoft.CodeAnalysis.TaskList.TaskListItemPriority,System.String,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.FileLinePositionSpan,Microsoft.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Serialization type used to pass information to/from OOP and VS.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TaskList.TaskListItemDescriptor">
            <summary>
            Description of a TODO comment type to find in a user's comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TaskList.TaskListItemDescriptor.#ctor(System.String,Microsoft.CodeAnalysis.TaskList.TaskListItemPriority)">
            <summary>
            Description of a TODO comment type to find in a user's comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.ITelemetryLog.Log(Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage)">
            <summary>
            Adds a telemetry event with values obtained from context message <paramref name="logMessage"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.ITelemetryLog.LogBlockTime(Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage,System.Int32)">
            <summary>
            Adds an execution time telemetry event representing <paramref name="logMessage"/>
            only if  block duration meets or exceeds <paramref name="minThresholdMs"/> milliseconds.
            </summary>
            <param name="logMessage">Event data to be sent</param>
            <param name="minThresholdMs">Optional parameter used to determine whether to send the telemetry event (in milliseconds)</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.ITelemetryLogProvider.GetLog(Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            Returns an <see cref="T:Microsoft.CodeAnalysis.Telemetry.ITelemetryLog"/> for logging telemetry.
            </summary>
            <param name="functionId">FunctionId representing the telemetry operation</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.ITelemetryLogProvider.GetAggregatingLog(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Double[])">
            <summary>
            Returns an aggregating <see cref="T:Microsoft.CodeAnalysis.Telemetry.ITelemetryLog"/> for logging telemetry.
            </summary>
            <param name="functionId">FunctionId representing the telemetry operation</param>
            <param name="bucketBoundaries">Optional values indicating bucket boundaries in milliseconds. If not specified, 
            all aggregating events created will use a default configuration</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.ITelemetryLogProvider.Flush">
            <summary>
            Flushes all telemetry logs
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService">
            <summary>
            Provides access to the telemetry service to workspace services.
            Abstract away the actual implementation of the telemetry service (e.g. Microsoft.VisualStudio.Telemetry).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService.HasActiveSession">
            <summary>
            True if a telemetry session has started.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService.IsUserMicrosoftInternal">
            <summary>
            True if the active session belongs to a Microsoft internal user.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService.SerializeCurrentSessionSettings">
            <summary>
            Serialized the current telemetry settings. Returns <see langword="null"/> if session hasn't started.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService.RegisterUnexpectedExceptionLogger(System.Diagnostics.TraceSource)">
            <summary>
            Adds a <see cref="T:System.Diagnostics.TraceSource"/> used to log unexpected exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService.UnregisterUnexpectedExceptionLogger(System.Diagnostics.TraceSource)">
            <summary>
            Removes a <see cref="T:System.Diagnostics.TraceSource"/> used to log unexpected exceptions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Telemetry.TelemetryFeatureName">
            <summary>
            Feature name used in telemetry.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging">
            <summary>
            Provides access to posting telemetry events or adding information
            to aggregated telemetry events. Posts pending telemetry at 30
            minute intervals.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage)">
            <summary>
            Posts a telemetry event representing the <paramref name="functionId"/> operation with context message <paramref name="logMessage"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging.LogBlockTime(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage,System.Int32)">
            <summary>
            Posts a telemetry event representing the <paramref name="functionId"/> operation 
            only if the block duration meets or exceeds <paramref name="minThresholdMs"/> milliseconds.
            This event will contain properties from <paramref name="logMessage"/> and the actual execution time.
            </summary>
            <param name="logMessage">Properties to be set on the telemetry event</param>
            <param name="minThresholdMs">Optional parameter used to determine whether to send the telemetry event</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging.LogAggregated(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Telemetry.TelemetryLoggingInterpolatedStringHandler,System.Int32)">
            <summary>
            Adds information to an aggregated telemetry event representing the <paramref name="functionId"/> operation 
            with the specified name and value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging.LogBlockTimeAggregated(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Telemetry.TelemetryLoggingInterpolatedStringHandler,System.Int32)">
            <summary>
            Adds block execution time to an aggregated telemetry event representing the <paramref name="functionId"/> operation 
            with metric <paramref name="metricName"/> only if the block duration meets or exceeds <paramref name="minThresholdMs"/> milliseconds.
            </summary>
            <param name="minThresholdMs">Optional parameter used to determine whether to send the telemetry event</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging.GetLog(Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            Returns non-aggregating telemetry log.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Telemetry.TelemetryLogging.GetAggregatingLog(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Double[])">
            <summary>
            Returns aggregating telemetry log.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService.SingleFileThreshold">
            <summary>
            The maximum size in bytes of a single storage unit in a memory mapped file which is shared with other storage
            units.
            </summary>
            <remarks>
            <para>The value of 256k reduced the number of files dumped to separate memory mapped files by 60% compared to
            the next lower power-of-2 size for Roslyn.sln itself.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MultiFileBlockSize">
            <summary>
            The size in bytes of a memory mapped file created to store multiple temporary objects.
            </summary>
            <remarks>
            <para>This value (8mb) creates roughly 35 memory mapped files (around 300MB) to store the contents of all of
            Roslyn.sln a snapshot. This keeps the data safe, so that we can drop it from memory when not needed, but
            reconstitute the contents we originally had in the snapshot in case the original files change on disk.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._gate">
            <summary>
            The synchronization object for accessing the memory mapped file related fields (indicated in the remarks
            of each field).
            </summary>
            <remarks>
            <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
            available in source control history. The use of exclusive locks was not causing any measurable
            performance overhead even on 28-thread machines at the time this was written.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileReference">
            <summary>
            The most recent memory mapped file for creating multiple storage units. It will be used via bump-pointer
            allocation until space is no longer available in it.  Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._gate"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._name">
            <summary>The name of the current memory mapped file for multiple storage units. Access should be synchronized on
            <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._gate"/></summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileSize">
            <summary>The total size of the current memory mapped file for multiple storage units. Access should be
            synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._gate"/></summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._offset">
            <summary>
            The offset into the current memory mapped file where the next storage unit can be held. Access should be
            synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._gate"/>.
            </summary>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService._fileReference"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageService.CreateTemporaryStorage(System.Int64)">
            <summary>
            Allocate shared storage of a specified size.
            </summary>
            <remarks>
            <para>"Small" requests are fulfilled from oversized memory mapped files which support several individual
            storage units. Larger requests are allocated in their own memory mapped files.</para>
            </remarks>
            <param name="size">The size of the shared storage block to allocate.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo"/> describing the allocated block.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo">
            <summary>
            Our own abstraction on top of memory map file so that we can have shared views over mmf files. 
            Otherwise, each view has minimum size of 64K due to requirement forced by windows.
            
            most of our view will have short lifetime, but there are cases where view might live a bit longer such as
            metadata dll shadow copy. shared view will help those cases.
            </summary>
            <remarks>
            <para>This class and its nested types have familiar APIs and predictable behavior when used in other code, but
            are non-trivial to work on.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.#ctor(System.IO.MemoryMappedFiles.MemoryMappedFile,System.String,System.Int64,System.Int64)">
            <summary>
            Our own abstraction on top of memory map file so that we can have shared views over mmf files. 
            Otherwise, each view has minimum size of 64K due to requirement forced by windows.
            
            most of our view will have short lifetime, but there are cases where view might live a bit longer such as
            metadata dll shadow copy. shared view will help those cases.
            </summary>
            <remarks>
            <para>This class and its nested types have familiar APIs and predictable behavior when used in other code, but
            are non-trivial to work on.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.MemoryMappedFile">
            <summary>
            The memory mapped file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo._weakReadAccessor">
             <summary>
             A weak reference to a read-only view for the memory mapped file.
             </summary>
             <remarks>
             <para>This holds a weak counted reference to current <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor"/>, which allows
             additional accessors for the same address space to be obtained up until the point when no external code is
             using it. When the memory is no longer being used by any <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.MemoryMappedViewUnmanagedMemoryStream"/>
             objects, the view of the memory mapped file is unmapped, making the process address space it previously
             claimed available for other purposes. If/when it is needed again, a new view is created.</para>
            
             <para>This view is read-only, so it is only used by <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.CreateReadableStream"/>.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.Name">
            <summary>
            The name of the memory mapped file. Non null on systems that support named memory mapped files, null
            otherwise..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.Offset">
            <summary>
            The offset into the memory mapped file of the region described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.Size">
            <summary>
            The size of the region of the memory mapped file described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageService.MemoryMappedInfo.RunWithCompactingGCFallback``2(System.Func{``0,``1},``0)">
            <summary>
            Run a function which may fail with an <see cref="T:System.IO.IOException"/> if not enough memory is available to satisfy
            the request. In this case, a full compacting GC pass is forced and the function is attempted again.
            </summary>
            <remarks>
            <para><see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> and <see
            cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> will use a native memory map,
            which can't trigger a GC. In this case, we'd otherwise crash with OOM, so we don't care about creating a UI
            delay with a full forced compacting GC. If it crashes the second try, it means we're legitimately out of
            resources.</para>
            </remarks>
            <typeparam name="TArg">The type of argument to pass to the callback.</typeparam>
            <typeparam name="T">The type returned by the function.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument">The argument to pass to the function.</param>
            <returns>The value returned by <paramref name="function"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceCacheService">
            <summary>
            Workspace service for cache implementations.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Host.IWorkspaceCacheService.CacheFlushRequested">
            <summary>
            May be raised by a Workspace host when available memory is getting low in order to request
            that caches be flushed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.DocumentPropertiesService">
            <summary>
            Extensible document properties specified via a document service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DocumentPropertiesService.DiagnosticsLspClientName">
            <summary>
            The LSP client name that should get the diagnostics produced by this document; any other source
            will not show these diagnostics.  For example, razor uses this to exclude diagnostics from the error list
            so that they can handle the final display.
            If null, the diagnostics do not have this special handling.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDocumentExcerptService">
            <summary>
            excerpt some part of <see cref="T:Microsoft.CodeAnalysis.Document"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDocumentExcerptService.TryExcerptAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Host.ExcerptMode,Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Threading.CancellationToken)">
            <summary>
            return <see cref="T:Microsoft.CodeAnalysis.Host.ExcerptResult"/> of given <see cref="T:Microsoft.CodeAnalysis.Document"/> and <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>
            
            the result might not be an exact copy of the given source or contains more then given span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ExcerptMode">
            <summary>
            this mode shows intention not actual behavior. it is up to implementation how to interpret the intention.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ExcerptResult">
            <summary>
            Result of excerpt
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ExcerptResult.#ctor(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Result of excerpt
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Content">
            <summary>
            excerpt content
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.MappedSpan">
            <summary>
            span on <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Content"/> that given <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Span"/> got mapped to
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.ClassifiedSpans">
            <summary>
            classification information on the <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Content"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Document">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Document"/> this excerpt is from
            
            should be same document in <see cref="M:Microsoft.CodeAnalysis.Host.IDocumentExcerptService.TryExcerptAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Host.ExcerptMode,Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Threading.CancellationToken)" />
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Span">
            <summary>
            span on <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Document"/> this excerpt is from
            
            should be same text span in <see cref="M:Microsoft.CodeAnalysis.Host.IDocumentExcerptService.TryExcerptAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Host.ExcerptMode,Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Threading.CancellationToken)" />
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDocumentOperationService">
            <summary>
            TODO: Merge into <see cref="T:Microsoft.CodeAnalysis.Host.DocumentPropertiesService"/>.
            Used by Razor via IVT.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.CanApplyChange">
            <summary>
            document version of <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.SupportDiagnostics">
            <summary>
            indicates whether this document supports diagnostics or not
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDocumentService">
            <summary>
            Empty interface just to mark document services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider.GetService``1">
            <summary>
            Gets a document specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISpanMappingService">
             <summary>
             Map spans in a document to other spans even in other document
            
             this will be used by various features if provided to convert span in one document to other spans.
             
             for example, it is used to show spans users expect in a razor file rather than spans in 
             auto generated file that is implementation detail or navigate to the right place rather 
             than the generated file and etc.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.ISpanMappingService.SupportsMappingImportDirectives">
            <summary>
            Whether this span mapping service can handle mapping import directives added to a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ISpanMappingService.MapSpansAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Map spans in the document to more appropriate locations
            
            in current design, this can NOT map a span to a span that is not backed by a file.
            for example, roslyn supports someone to have a document that is not backed by a file. and current design doesn't allow
            such document to be returned from this API
            for example, span on razor secondary buffer document in roslyn solution mapped to a span on razor cshtml file is possible but
            a span on razor cshtml file to a span on secondary buffer document is not possible since secondary buffer document is not backed by a file
            </summary>
            <param name="document">Document given spans belong to</param>
            <param name="spans">Spans in the document</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Return mapped span. order of result should be same as the given span</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.MappedSpanResult">
            <summary>
            Result of span mapping
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.MappedSpanResult.FilePath">
            <summary>
            Path to mapped file
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.MappedSpanResult.LinePositionSpan">
            <summary>
            LinePosition representation of the Span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.MappedSpanResult.Span">
            <summary>
            Mapped span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.EventListenerMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.EventListenerMetadata.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            MEF metadata class used to find exports declared for a specific <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.EventListenerTracker`1">
            <summary>
            helper type to track whether <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> has been initialized.
            
            currently, this helper only supports services whose lifetime is same as Host (ex, VS)
            </summary>
            <typeparam name="TService">TService for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener`1"/></typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.EventListenerTracker`1.#ctor(System.Collections.Generic.IEnumerable{System.Lazy{Microsoft.CodeAnalysis.Host.IEventListener,Microsoft.CodeAnalysis.Host.EventListenerMetadata}},System.String)">
            <summary>
            helper type to track whether <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> has been initialized.
            
            currently, this helper only supports services whose lifetime is same as Host (ex, VS)
            </summary>
            <typeparam name="TService">TService for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener`1"/></typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.EventListenerTracker`1._eventListenerInitialized">
            <summary>
            Workspace kind this event listener is initialized for
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ExportEventListenerAttribute.#ctor(System.String,System.String[])">
            <summary>
            MEF export attribute for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/>
            </summary>
            <param name="service">
            one of values from <see cref="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners"/> indicating which service this event listener is for
            </param>
            <param name="workspaceKinds">indicate which workspace kind this event listener is for</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IEventListener">
            <summary>
            provide a way for features to lazily subscribe to a service event for particular workspace
            
            see <see cref="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners"/> for supported services
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IEventListenerStoppable">
            <summary>
            provide a way for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> to mark it as stoppable
            
            for example, if the service <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> is used for is a disposable
            service, the service can call Stop when the service go away
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IEventListener`1">
            <summary>
            provide a way for features to lazily subscribe to a service event for particular workspace
            
            see <see cref="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners"/> for supported services
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceEventListenerService">
            <summary>
            Ensure <see cref="M:Microsoft.CodeAnalysis.Host.IEventListener`1.StartListening(Microsoft.CodeAnalysis.Workspace,`0)"/> is called for the workspace
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners">
            <summary>
            list of well known <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> types
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostLanguageServices">
            <summary>
            Per-language services provided by the host environment.
            </summary>
            <remarks>
            <para>Language services which implement <see cref="T:System.IDisposable"/> are considered ownable, in which case the
            owner is responsible for disposing of owned instances when they are no longer in use. The ownership rules are
            described in detail for <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>. Instances of <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> have
            the same ownership rules as <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/>, and instances of
            <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> have the same ownership rules as
            <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/>.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.WorkspaceServices">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> that originated this language service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.Language">
            <summary>
            The name of the language
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.LanguageServices">
            <summary>
            Immutable snapshot of the host services.  Preferable to use instead of this <see
            cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> when possible.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetService``1">
            <summary>
            Gets a language specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetRequiredService``1">
            <summary>
            Gets a language specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns throws <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.CompilationFactory">
            <summary>
            A factory for creating compilations instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostServices">
            <summary>
            Services provided by the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new workspace service. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices">
             <summary>
             Per workspace services provided by the host environment.
             </summary>
             <remarks>
             <para>Workspace services which implement <see cref="T:System.IDisposable"/> are considered ownable, in which case the
             owner is responsible for disposing of owned instances when they are no longer in use. When
             <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> or <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> instances are provided directly to the
             <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>, the owner of the instances is the type or container (e.g. a MEF export
             provider) which created the instances. For the specific case of ownable workspace services created by a factory
             (i.e. instances returned by <see cref="M:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory.CreateService(Microsoft.CodeAnalysis.Host.HostWorkspaceServices)"/>), the <see cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace"/>
             is considered the owner of the resulting instance and is expected to be disposed during the call to
             <see cref="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Dispose"/>.</para>
            
             <para><strong>Summary of lifetime rules</strong></para>
            
             <list type="bullet">
             <item><description>
               <strong><see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instance constructed externally (e.g. MEF):</strong> Owned by the
               external source, and will not be automatically disposed when <see cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace"/> is disposed.
             </description></item>
             <item><description>
               <strong><see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> instance constructed externally (e.g. MEF):</strong> Owned by
               the external source, and will not be automatically disposed when <see cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace"/> is disposed.
             </description></item>
             <item><description>
               <strong><see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instance constructed by <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> within
               the context of <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>:</strong> Owned by <see cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace"/>, and
               <strong>will</strong> be automatically disposed when <see cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace"/> is disposed.
             </description></item>
             </list>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.HostServices">
            <summary>
            The host services this workspace services originated from.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace">
            <summary>
            The workspace corresponding to this workspace services instantiation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetService``1">
            <summary>
            Gets a workspace specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetRequiredService``1">
            <summary>
            Gets a workspace specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method throws <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">The host does not provide the service.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.PersistentStorage">
            <summary>
            Obsolete.  Roslyn no longer supports a mechanism to perform arbitrary persistence of data.  If such functionality
            is needed, consumers are responsible for providing it themselves with whatever semantics are needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.TemporaryStorage">
            <summary>
            Obsolete.  Roslyn no longer supports a mechanism to store arbitrary data in-memory.  If such functionality
            is needed, consumers are responsible for providing it themselves with whatever semantics are needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.TextFactory">
            <summary>
            A factory that constructs <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.SupportedLanguages">
            <summary>
            A list of language names for supported language services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.IsSupported(System.String)">
            <summary>
            Returns true if the language is supported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetLanguageServices(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> for the language name.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the language isn't supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.FindLanguageServices``1(Microsoft.CodeAnalysis.Host.HostWorkspaceServices.MetadataFilter)">
            <summary>
            Finds all language services of the corresponding type across all supported languages that match the filter criteria.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IFallbackAnalyzerConfigOptionsProvider">
            <summary>
            Allows the host to provide fallback editorconfig options for a language loaded into the workspace.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ILanguageService">
            <summary>
            Empty interface just to mark language services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceService">
            <summary>
            Empty interface just to mark workspace services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.LanguageServices">
            <summary>
            Per language services provided by the host environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.LanguageServices.Language">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.Language"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.LanguageServices.GetService``1">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetService``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.LanguageServices.GetRequiredService``1">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetRequiredService``1"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportDynamicFileInfoProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> implementation for MEF
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportDynamicFileInfoProviderAttribute.Extensions">
            <summary>
            file extensions this <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> can handle such as cshtml
            
            match will be done by <see cref="P:System.StringComparer.OrdinalIgnoreCase"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; <see cref="F:Microsoft.CodeAnalysis.LanguageNames.CSharp"/>, etc.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>, etc.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; <see cref="F:Microsoft.CodeAnalysis.LanguageNames.CSharp"/>, etc.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>, etc.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Language">
            <summary>
            The language that the service is target for. Specify a value from <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>, or other language name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Layer">
            <summary>
            The layer that the service is specified for. Specify a value from <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.WorkspaceKinds">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/>s that the service is specified for.
            If non-empty the service is only exported for the listed workspace kinds and <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Layer"/> is not applied,
            unless <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Layer"/> is <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Test"/> in which case the export overrides all other exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; <see cref="F:Microsoft.CodeAnalysis.LanguageNames.CSharp"/>, etc.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>, etc.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; <see cref="F:Microsoft.CodeAnalysis.LanguageNames.CSharp"/>, etc.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>, etc.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Language">
            <summary>
            The language that the service is target for. Specify a value from <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>, or other language name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Layer">
            <summary>
            The layer that the service is specified for. Specify a value from <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.WorkspaceKinds">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/>s that the service is specified for.
            If non-empty the service is only exported for the listed workspace kinds and <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Layer"/> is not applied,
            unless <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Layer"/> is <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Test"/> in which case the export overrides all other exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="serviceType">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default" />, etc.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.#ctor(System.Type,System.String)">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="serviceType">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default" />, etc.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.Layer">
            <summary>
            The layer that the service is specified for. Specify a value from <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.WorkspaceKinds">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/>s that the service is specified for.
            If non-empty the service is only exported for the listed workspace kinds and <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.Layer"/> is not applied,
            unless <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.Layer"/> is <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Test"/> in which case the export overrides all other exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="serviceType">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer or workspace kind that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default" />, <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.MiscellaneousFiles" />etc.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.#ctor(System.Type,System.String)">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <remarks>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </remarks>
            <param name="serviceType">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer or workspace kind that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default" />, <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.MiscellaneousFiles" />etc.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.Layer">
            <summary>
            The layer that the service is specified for. Specify a value from <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.WorkspaceKinds">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/>s that the service is specified for.
            If non-empty the service is only exported for the listed workspace kinds and <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.Layer"/> is not applied,
            unless <see cref="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.Layer"/> is <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Test"/> in which case the export overrides all other exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory">
            <summary>
            A factory that creates instances of a specific <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/>.
            
            Implement a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> when you want to provide <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> instances that use other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory.CreateLanguageService(Microsoft.CodeAnalysis.Host.HostLanguageServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> instance.
            </summary>
            <param name="languageServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> that can be used to access other services.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory">
            <summary>
            A factory that creates instances of a specific <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/>.
            
            Implement a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> when you want to provide <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instances that use other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory.CreateService(Microsoft.CodeAnalysis.Host.HostWorkspaceServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instance.
            Returns <c>null</c> if the service is not applicable to the given workspace.
            </summary>
            <param name="workspaceServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> that can be used to access other services.</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.s_creationHook">
            <summary>
            This delegate allows test code to override the behavior of <see cref="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.Create(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/>.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.TestAccessor.HookServiceCreation(Microsoft.CodeAnalysis.Host.Mef.MefHostServices.CreationHook)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.TestAccessor.HookServiceCreation(Microsoft.CodeAnalysis.Host.Mef.MefHostServices.CreationHook)">
            <summary>
            Injects replacement behavior for the <see cref="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.Create(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/> method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer">
            <summary>
            The layer of an exported service.  
            
            If there are multiple definitions of a service, the <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/> is used to determine which is used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Test">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Editor"/>, <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop"/> and <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Host">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Editor"/>, <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop"/> and <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Editor">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop" /> and <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default">
            <summary>
            The base service layer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.FileExtensionsMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific file extensions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Language property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Languages property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            MEF metadata class used to find exports declared for a specific language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> exports.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> exports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.LayeredServiceUtilities.s_orderedProductLayers">
            <summary>
            Layers in the priority order. <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Host"/> services override <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Editor"/> services, etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> exports.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.AbstractAnalyzerAssemblyLoaderProvider">
            <summary>
            Abstract implementation of an analyzer assembly loader that can be used by VS/VSCode to provide a <see
            cref="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader"/> with an appropriate path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver">
            <summary>
            Provides a way to map from an assembly name to the actual path of the .NET Framework 
            assembly with that name in the context of a specified project.  For example, if the 
            assembly name is "System.Data" then a project targeting .NET 2.0 would resolve this
            to a different path than a project targeting .NET 4.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver.ResolveAssemblyPath(Microsoft.CodeAnalysis.ProjectId,System.String,System.String)">
            <summary>
            Returns null if the assembly name could not be resolved.
            </summary>
            <param name="fullyQualifiedName">An optional type name for a type that must
            exist in the assembly.</param>
            <param name="projectId">The project context to search within.</param>
            <param name="assemblyName">The name of the assembly to try to resolve.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.MetadataReferenceCache">
            <summary>
            A cache for metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.MetadataReferenceCache.#ctor(System.Func{System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            A cache for metadata references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.MetadataReferenceCache.ReferenceSet">
            <summary>
            A collection of references to the same underlying metadata, each with different properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.MetadataReferenceCache.ReferenceSet.#ctor(Microsoft.CodeAnalysis.Host.MetadataReferenceCache)">
            <summary>
            A collection of references to the same underlying metadata, each with different properties.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.SolutionKey">
            <summary>
            The solution this is a storage instance for.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ChecksumMatchesAsync(System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            <see langword="true"/> if the data we have for the solution with the given <paramref name="name"/> has the
            provided <paramref name="checksum"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ChecksumMatchesAsync(Microsoft.CodeAnalysis.Project,System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            <see langword="true"/> if the data we have for the given <paramref name="project"/> with the given <paramref
            name="name"/> has the provided <paramref name="checksum"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ChecksumMatchesAsync(Microsoft.CodeAnalysis.Document,System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            <see langword="true"/> if the data we have for the given <paramref name="document"/> with the given <paramref
            name="name"/> has the provided <paramref name="checksum"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadStreamAsync(System.String,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the solution with the given <paramref name="name"/>.  If <paramref name="checksum"/>
            is provided, the persisted checksum must match it.  If there is no such stream with that name, or the
            checksums do not match, then <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="project"/> with the given <paramref name="name"/>.  If <paramref name="checksum"/>
            is provided, the persisted checksum must match it.  If there is no such stream with that name, or the
            checksums do not match, then <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="document"/> with the given <paramref name="name"/>.  If <paramref name="checksum"/>
            is provided, the persisted checksum must match it.  If there is no such stream with that name, or the
            checksums do not match, then <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(System.String,System.IO.Stream,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the solution with the given <paramref name="name"/>.  An optional <paramref
            name="checksum"/> can be provided to store along with the data.  This can be used along with ReadStreamAsync
            with future reads to ensure the data is only read back if it matches that checksum.
            <para>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.IO.Stream,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="project"/> with the given <paramref name="name"/>.  An optional
            <paramref name="checksum"/> can be provided to store along with the data.  This can be used along with
            ReadStreamAsync with future reads to ensure the data is only read back if it matches that checksum.
            <para>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.IO.Stream,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="document"/> with the given <paramref name="name"/>.  An optional
            <paramref name="checksum"/> can be provided to store along with the data.  This can be used along with
            ReadStreamAsync with future reads to ensure the data is only read back if it matches that checksum.
            <para>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Storage.ProjectKey,System.String,System.IO.Stream,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Storage.DocumentKey,System.String,System.IO.Stream,System.Nullable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IPersistentStorage">
            <remarks>
            Instances of <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> support both synchronous and asynchronous disposal.  Asynchronous
            disposal should always be preferred as the implementation of synchronous disposal may end up blocking the caller
            on async work.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IPersistentStorage.WriteStreamAsync(System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Returns <see langword="true"/> if the data was successfully persisted to the storage subsystem.  Subsequent
            calls to read the same keys should succeed if called within the same session.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IPersistentStorageConfiguration">
            <summary>
            Configuration of the <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorageService"/> intended to be used to override behavior in tests.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.IPersistentStorageConfiguration.ThrowOnFailure">
            <summary>
            Indicates that the client expects the DB to succeed at all work and that it should not ever gracefully fall over.
            Should not be set in normal host environments, where it is completely reasonable for things to fail
            (for example, if a client asks for a key that hasn't been stored yet).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.DefaultPersistentStorageConfiguration.s_invalidPathChars">
            <summary>
            Used to ensure that the path components we generate do not contain any characters that might be invalid in a
            path.  For example, Base64 encoding will use <c>/</c> which is something that we definitely do not want
            errantly added to a path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IPersistentStorageService">
            <summary>
            Obsolete.  Roslyn no longer supports a mechanism to perform arbitrary persistence of data.  If such functionality
            is needed, consumers are responsible for providing it themselves with whatever semantics are needed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.SolutionServices">
            <summary>
            Per solution services provided by the host environment.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.SolutionServices._services">
            <remarks>
            Note: do not expose publicly.  <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> exposes a <see
            cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace"/> which we want to avoid doing from our immutable snapshots.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.SolutionServices.GetService``1">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetService``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.SolutionServices.GetRequiredService``1">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetRequiredService``1"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.SolutionServices.SupportedLanguages">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.SupportedLanguages"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.SolutionServices.IsSupported(System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.IsSupported(System.String)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.SolutionServices.GetLanguageServices(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Host.LanguageServices"/> for the language name.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the language isn't supported.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo">
            <summary>
            provides info on the given file
            
            this will be used to provide dynamic content such as generated content from cshtml to workspace
            we acquire this from <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> exposed from external components such as razor for cshtml
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.DynamicFileInfo.#ctor(System.String,Microsoft.CodeAnalysis.SourceCodeKind,Microsoft.CodeAnalysis.TextLoader,System.Boolean,Microsoft.CodeAnalysis.Host.IDocumentServiceProvider)">
            <summary>
            provides info on the given file
            
            this will be used to provide dynamic content such as generated content from cshtml to workspace
            we acquire this from <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> exposed from external components such as razor for cshtml
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.FilePath">
            <summary>
            The path to the generated file. in future, we will use this to get right options from editorconfig
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.SourceCodeKind">
            <summary>
            return <see cref="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.SourceCodeKind"/> for this file
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.TextLoader">
            <summary>
            return <see cref="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.TextLoader"/> to load content for the dynamic file
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.DesignTimeOnly">
            <summary>
            True if the source code contained in the document is only used in design-time (e.g. for completion),
            but is not passed to the compiler when the containing project is built, e.g. a Razor view.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.DocumentServiceProvider">
            <summary>
            return <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> for the content it provided
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider">
            <summary>
            Provider for the <see cref="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo"/>
            
            implementer of this service should be pure free-thread meaning it can't switch to UI thread underneath.
            otherwise, we can get into dead lock if we wait for the dynamic file info from UI thread
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.GetDynamicFileInfoAsync(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            return <see cref="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo"/> for the context given
            </summary>
            <param name="projectId"><see cref="T:Microsoft.CodeAnalysis.ProjectId"/> this file belongs to</param>
            <param name="projectFilePath">full path to project file (ex, csproj)</param>
            <param name="filePath">full path to non source file (ex, cshtml)</param>
            <returns>null if this provider can't handle the given file</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.RemoveDynamicFileInfoAsync(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            let provider know certain file has been removed
            </summary>
            <param name="projectId"><see cref="T:Microsoft.CodeAnalysis.ProjectId"/> this file belongs to</param>
            <param name="projectFilePath">full path to project file (ex, csproj)</param>
            <param name="filePath">full path to non source file (ex, cshtml)</param>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.Updated">
            <summary>
            indicate content of a file has updated. the event argument "string" should be same as "filepath" given to <see cref="M:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.GetDynamicFileInfoAsync(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService">
            <summary>
            Provides workspace status
            
            this is an work in-progress interface, subject to be changed as we work on prototype.
            
            it can completely removed at the end or new APIs can added and removed as prototype going on
            no one except one in the prototype group should use this interface.
            
            tracking issue - https://github.com/dotnet/roslyn/issues/34415
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.StatusChanged">
            <summary>
            Indicate that status has changed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.WaitUntilFullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Wait until workspace is fully loaded
            
            unfortunately, some hosts, such as VS, use services (ex, IVsOperationProgressStatusService) that require UI thread to let project system to proceed to next stages.
            what that means is that this method should only be used with either await or JTF.Run, it should be never used with Task.Wait otherwise, it can
            deadlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.IsFullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Indicates whether workspace is fully loaded
            <para>
            Unfortunately, some hosts, such as VS, use services (ex, IVsOperationProgressStatusService) that require UI
            thread to let project system to proceed to next stages. what that means is that this method should only be
            used with either await or JTF.Run, it should be never used with Task.Wait otherwise, it can deadlock.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService">
            <summary>
            Factory service for creating syntax trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService.OptionsDifferOnlyByPreprocessorDirectives(Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Returns true if the two options differ only by preprocessor directives; this allows for us to reuse trees
            if they don't have preprocessor directives in them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITaskSchedulerProvider">
            <summary>
            A factory that creates either sequential or parallel task schedulers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceAsynchronousOperationListenerProvider">
            <summary>
            Workspace service that provides <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal">
            <summary>
            API to allow a client to write data to memory-mapped-file storage.  That data can be read back in within the same
            process using a handle returned from the writing call.  The data can optionally be read back in from a different
            process, using the information contained with the handle's <code>Identifier</code> (see <see
            cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageIdentifier"/>), but only on systems that support named memory mapped files.  Currently, this
            is any .net on Windows and mono on unix systems.  This is not supported on .net core on unix systems (tracked here
            https://github.com/dotnet/runtime/issues/30878).  This is not a problem in practice as cross process sharing is only
            needed by the VS host, which is windows only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal.WriteToTemporaryStorage(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Write the provided <paramref name="stream"/> to a new memory-mapped-file.  Returns a handle to the data that can
            be used to identify the data across processes allowing it to be read back in in any process.
            </summary>
            <remarks>
            This type is primarily used to allow dumping metadata to disk.  This then allowing them to be read in by mapping
            their data into types like <see cref="T:Microsoft.CodeAnalysis.AssemblyMetadata"/>.  It also allows them to be read in by our server
            process, without having to transmit the data over the wire.
            <para/> Note: The stream provided must support <see cref="P:System.IO.Stream.Length"/>.  The stream will also be reset to
            <see cref="P:System.IO.Stream.Position"/> <code>0</code> within this method.  The caller does not need to reset the stream
            itself.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal.WriteToTemporaryStorage(Microsoft.CodeAnalysis.Text.SourceText,System.Threading.CancellationToken)">
            <summary>
            Write the provided <paramref name="text"/> to a new memory-mapped-file.  Returns a handle to the data that can
            be used to identify the data across processes allowing it to be read back in in any process.
            </summary>
            <remarks>
            This type is primarily used to allow dumping source texts to disk.  This then allowing them to be read in by
            mapping their data into types like <see cref="T:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText"/>.  It also allows them
            to be read in by our server process, without having to transmit the data over the wire.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal.WriteToTemporaryStorageAsync(Microsoft.CodeAnalysis.Text.SourceText,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal.WriteToTemporaryStorage(Microsoft.CodeAnalysis.Text.SourceText,System.Threading.CancellationToken)"/>"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageStreamHandle">
            <summary>
            Represents a handle to data stored to temporary storage (generally a memory mapped file).  As long as this handle is
            alive, the data should remain in storage and can be readable from any process using the information provided in <see
            cref="P:Microsoft.CodeAnalysis.Host.ITemporaryStorageStreamHandle.Identifier"/>.  Use <see cref="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal.WriteToTemporaryStorage(System.IO.Stream,System.Threading.CancellationToken)"/> to write the data to temporary storage and get a handle to it.  Use <see
            cref="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageStreamHandle.ReadFromTemporaryStorage"/> to read the data back in any process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageStreamHandle.ReadFromTemporaryStorage">
            <summary>
            Reads the data indicated to by this handle into a stream.  This stream can be created in a different process
            than the one that wrote the data originally.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.LegacyTemporaryStorageService">
            <summary>
            Legacy implementation of obsolete public API <see cref="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageService"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageIdentifier">
            <summary>
            Identifier for a stream of data placed in a segment of a memory mapped file. Can be used to identify that segment
            across processes (where supported), allowing for efficient sharing of data.
            </summary>
            <param name="Name">The name of the segment in the temporary storage.  <see langword="null"/> on platforms that don't
            support cross process sharing of named memory mapped files.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageIdentifier.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            Identifier for a stream of data placed in a segment of a memory mapped file. Can be used to identify that segment
            across processes (where supported), allowing for efficient sharing of data.
            </summary>
            <param name="Name">The name of the segment in the temporary storage.  <see langword="null"/> on platforms that don't
            support cross process sharing of named memory mapped files.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageIdentifier.Name">
            <summary>The name of the segment in the temporary storage.  <see langword="null"/> on platforms that don't
            support cross process sharing of named memory mapped files.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITextFactoryService">
            <summary>
            A factory for creating <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instances.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITextFactoryService.CreateText(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a stream.
            </summary>
            <param name="stream">The stream to read the text from. Must be readable and seekable. The text is read from the start of the stream.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be the system encoding.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="checksumAlgorithm">Algorithm to calculate content checksum.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITextFactoryService.CreateText(System.IO.TextReader,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a reader with given <paramref name="encoding"/>.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader"/> to read the text from.</param>
            <param name="encoding">Specifies an encoding for the <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>SourceText. 
            it could be null. but if null is given, it won't be able to calculate checksum</param>
            <param name="checksumAlgorithm">Algorithm to calculate content checksum.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISolutionAnalyzerSetterWorkspaceService">
            <summary>
            Available in workspaces that accept changes in solution level analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions">
            <summary>
            Options that affect behavior of workspace core APIs (<see cref="T:Microsoft.CodeAnalysis.Solution"/>, <see cref="T:Microsoft.CodeAnalysis.Project"/>, <see
            cref="T:Microsoft.CodeAnalysis.Document"/>, <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>, etc.) to which it would be impractical to flow these options
            explicitly. The options are instead provided by <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceConfigurationService"/>. The remote instance of
            this service is initialized based on the in-proc values (which themselves are loaded from global options) when we
            establish connection from devenv to ServiceHub process. If another process connects to our ServiceHub process before
            that the remote instance provides a predefined set of options <see cref="F:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions.RemoteDefault"/> that can later be updated
            when devenv connects to the ServiceHub process.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions.#ctor(Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference,System.Boolean)">
            <summary>
            Options that affect behavior of workspace core APIs (<see cref="T:Microsoft.CodeAnalysis.Solution"/>, <see cref="T:Microsoft.CodeAnalysis.Project"/>, <see
            cref="T:Microsoft.CodeAnalysis.Document"/>, <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>, etc.) to which it would be impractical to flow these options
            explicitly. The options are instead provided by <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceConfigurationService"/>. The remote instance of
            this service is initialized based on the in-proc values (which themselves are loaded from global options) when we
            establish connection from devenv to ServiceHub process. If another process connects to our ServiceHub process before
            that the remote instance provides a predefined set of options <see cref="F:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions.RemoteDefault"/> that can later be updated
            when devenv connects to the ServiceHub process.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions.RemoteDefault">
            <summary>
            These values are such that the correctness of remote services is not affected if these options are changed from defaults
            to non-defaults while the services have already been executing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference.Automatic">
            <summary>
            Source generators should re-run after any change to a project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference.Balanced">
            <summary>
            Source generators should re-run only when certain changes happen.  The set of things is host dependent, but
            generally should be things like "builds" or "file saves".  Larger events (not just text changes) which indicate
            that it's a more reasonable time to run generators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServicesExtensions.GetExtendedLanguageServices(Microsoft.CodeAnalysis.Host.HostWorkspaceServices,System.String)">
            <summary>
            Gets extended host language services, which includes language services from <see cref="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetLanguageServices(System.String)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DeferredDocumentationProvider">
            <summary>
            The documentation provider used to lookup xml docs for any metadata reference we pass out.  They'll
            all get the same xml doc comment provider (as different references to the same compilation don't
            see the xml docs any differently).  This provider does root a Compilation around.  However, this should
            not be an issue in practice as the compilation we are rooting is a clone of the acutal compilation of
            project, and not the compilation itself.  This clone doesn't share any symbols/semantics with the main
            compilation, and it can dump syntax trees whenever necessary.  What is does store is the compact
            decl-table which is safe and cheap to hold onto long term.  When some downstream consumer of this
            metadata-reference then needs to get xml-doc comments, it will resolve a doc-comment-id against this
            decl-only-compilation.  Resolution is very cheap, only causing the necessary symbols referenced directly
            in the ID to be created.  As downstream consumers are only likely to resolve a small handful of these 
            symbols in practice, this should not be expensive to hold onto.  Importantly, semantic models and 
            complex method binding/caching should never really happen with this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DeferredDocumentationProvider.#ctor(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            The documentation provider used to lookup xml docs for any metadata reference we pass out.  They'll
            all get the same xml doc comment provider (as different references to the same compilation don't
            see the xml docs any differently).  This provider does root a Compilation around.  However, this should
            not be an issue in practice as the compilation we are rooting is a clone of the acutal compilation of
            project, and not the compilation itself.  This clone doesn't share any symbols/semantics with the main
            compilation, and it can dump syntax trees whenever necessary.  What is does store is the compact
            decl-table which is safe and cheap to hold onto long term.  When some downstream consumer of this
            metadata-reference then needs to get xml-doc comments, it will resolve a doc-comment-id against this
            decl-only-compilation.  Resolution is very cheap, only causing the necessary symbols referenced directly
            in the ID to be created.  As downstream consumers are only likely to resolve a small handful of these 
            symbols in practice, this should not be expensive to hold onto.  Importantly, semantic models and 
            complex method binding/caching should never really happen with this compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlDocumentationProvider">
            <summary>
            A class used to provide XML documentation to the compiler for members from metadata from an XML document source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlDocumentationProvider.GetSourceStream(System.Threading.CancellationToken)">
            <summary>
            Gets the source stream for the XML document.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlDocumentationProvider.CreateFromBytes(System.Byte[])">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/> from bytes representing XML documentation data.
            </summary>
            <param name="xmlDocCommentBytes">The XML document bytes.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlDocumentationProvider.CreateFromFile(System.String)">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/> from an XML documentation file.
            </summary>
            <param name="xmlDocCommentFilePath">The path to the XML file.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlDocumentationProvider.NullXmlDocumentationProvider">
            <summary>
            A trivial XmlDocumentationProvider which never returns documentation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Utilities.SegmentedListPool.ComputeList``2(System.Action{``1,Microsoft.CodeAnalysis.Collections.SegmentedList{``0}},``1,``0)">
            <summary>
            Computes a list of results based on a provided <paramref name="addItems"/> callback.  The callback is passed
            a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> to add results to, and additional args to assist the process.  If no items
            are added to the list, then the <see cref="M:System.Array.Empty``1"/> singleton will be returned.  Otherwise the 
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> instance will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Utilities.WorkspacePathUtilities.TypeNameMatchesDocumentName(Microsoft.CodeAnalysis.Document,System.String)">
            <summary>
            Returns true if a type name matches a document name. We use
            case insensitive matching to determine this match so that files
            "a.cs" and "A.cs" both match a class called "A" 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Utilities.WorkspacePathUtilities.TypeNameMatchesDocumentName(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts)">
            <summary>
            Standard way to get the display name from a SyntaxNode. If the display
            name is null, returns false. Otherwise uses <see cref="M:Microsoft.CodeAnalysis.Utilities.WorkspacePathUtilities.TypeNameMatchesDocumentName(Microsoft.CodeAnalysis.Document,System.String)"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Utilities.WorkspacePathUtilities.GetTypeNameFromDocumentName(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets a type name based on a document name. Returns null
            if the document has no name or the document has invalid characters in the name
            such that <see cref="M:System.IO.Path.GetFileNameWithoutExtension(System.String)"/> would throw.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Utilities.ParameterName.NameBasedOnArgument">
            <summary>
            The name the underlying naming system came up with based on the argument itself.
            This might be a name like "_value".  We pass this along because it can help
            later parts of the GenerateConstructor process when doing things like field hookup.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Utilities.ParameterName.BestNameForParameter">
            <summary>
            The name we think should actually be used for this parameter.  This will include
            stripping the name of things like underscores.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AdhocWorkspace">
            <summary>
            A workspace that allows full manipulation of projects and documents,
            but does not persist changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.#ctor(Microsoft.CodeAnalysis.Host.HostServices,System.String)">
            <summary>
            A workspace that allows full manipulation of projects and documents,
            but does not persist changes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AdhocWorkspace.CanOpenDocuments">
            <summary>
            Returns true, signifiying that you can call the open and close document APIs to add the document into the open document list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.ClearSolution">
            <summary>
            Clears all projects and documents from the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddSolution(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Adds an entire solution to the workspace, replacing any existing solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddProject(System.String,System.String)">
            <summary>
            Adds a project to the workspace. All previous projects remain intact.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Adds a project to the workspace. All previous projects remain intact.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddProjects(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Adds multiple projects to the workspace at once. All existing projects remain intact.
            </summary>
            <param name="projectInfos"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddDocument(Microsoft.CodeAnalysis.ProjectId,System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Adds a document to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddDocument(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Adds a document to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.OpenDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Puts the specified document into the open state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.CloseDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Puts the specified document into the closed state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.OpenAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Puts the specified additional document into the open state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.CloseAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Puts the specified additional document into the closed state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.OpenAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Puts the specified analyzer config document into the open state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.CloseAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Puts the specified analyzer config document into the closed state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized from a compilers command line arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CommandLineProject.CreateProjectInfo(System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/> structure initialized with data from a compiler command line.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IDocumentTrackingService">
            <summary>
            Retrieves information about what documents are currently active or visible in the host workspace.  Note: this
            information is fundamentally racy (it can change directly after it is requested), and on different threads than the
            thread that asks for it.  As such, this information <em>must</em> only be used to provide a hint towards how a
            feature should go about its work, it must not impact the final results that a feature produces.  For example, a
            feature is allowed to use this information to decide what order to process documents in, to try to get more relevant
            results to a client more quickly.  However, it is not allowed to use this information to decide what results to
            return altogether.  Hosts are free to implement this service to do nothing at all, always returning empty/default
            values for the members within.  As per the above, this should never affect correctness, but it may impede a
            feature's ability to provide results in as timely a manner as possible for a client.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingService.TryGetActiveDocument">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> of the active document. May be null if there is no active document, the
            active document is not in the workspace, or if this functionality is not supported by a particular host.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingService.GetVisibleDocuments">
            <summary>
            Get a read only collection of the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of all the visible documents in the workspace.  May
            be empty if there are no visible documents, or if this functionality is not supported by a particular host.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.IDocumentTrackingService.ActiveDocumentChanged">
            <summary>
            Fired when the active document changes.  A host is not required to support this event, even if it implements
            <see cref="M:Microsoft.CodeAnalysis.IDocumentTrackingService.TryGetActiveDocument"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingServiceExtensions.GetActiveDocument(Microsoft.CodeAnalysis.IDocumentTrackingService,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Gets the active <see cref="T:Microsoft.CodeAnalysis.Document"/> the user is currently working in. May be null if
            there is no active document or the active document is not in this <paramref name="solution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTrackingServiceExtensions.GetVisibleDocuments(Microsoft.CodeAnalysis.IDocumentTrackingService,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Get a read only collection of all the unique visible documents in the workspace that are
            contained within <paramref name="solution"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ISupportedChangesService">
            <summary>
            Can be acquired from <see cref="P:Microsoft.CodeAnalysis.Solution.Services"/>, with <see cref="M:Microsoft.CodeAnalysis.Host.SolutionServices.GetService``1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISupportedChangesService.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISupportedChangesService.CanApplyCompilationOptionChange(Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Project)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyCompilationOptionChange(Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Project)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ISupportedChangesService.CanApplyParseOptionChange(Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.Project)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyParseOptionChange(Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.Project)"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectSystem.FileWatchedReferenceFactory`1._fileReferenceChangeContext">
            <summary>
            A file change context used to watch metadata references. This is lazy to avoid creating this immediately during
            our LSP process startup, when we don't yet know the LSP client's capabilities.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectSystem.FileWatchedReferenceFactory`1._referenceFileWatchingTokens">
            <summary>
            File watching tokens from <see cref="F:Microsoft.CodeAnalysis.ProjectSystem.FileWatchedReferenceFactory`1._fileReferenceChangeContext"/> that are watching metadata references. These
            are only created once we are actually applying a batch because we don't determine until the batch is applied if
            the file reference will actually be a file reference or it'll be a converted project reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectSystem.FileWatchedReferenceFactory`1._previousDisposalLocations">
            <summary>
            Stores the caller for a previous disposal of a reference produced by this class, to track down a double-dispose
            issue.
            </summary>
            <remarks>
            This can be removed once https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1843611 is fixed.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectSystem.FileWatchedReferenceFactory`1.StartWatchingReference(System.String)">
            <summary>
            Starts watching a particular <typeparamref name="TReference"/> for changes to the file. If this is already being
            watched , the reference count will be incremented. This is *not* safe to attempt to call multiple times for the
            same project and reference (e.g. in applying workspace updates)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectSystem.FileWatchedReferenceFactory`1.StopWatchingReference(System.String,`0,System.String,System.Int32)">
            <summary>
            Decrements the reference count for the given <typeparamref name="TReference"/>. When the reference count reaches
            0, the file watcher will be stopped. This is *not* safe to attempt to call multiple times for the same project
            and reference (e.g. in applying workspace updates)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectSystem.WatchedDirectory">
            <summary>
            Gives a hint to the <see cref="T:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext"/> that we should watch a top-level directory for all changes in addition
            to any files called by <see cref="M:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext.EnqueueWatchingFile(System.String)"/>.
            </summary>
            <remarks>
            This is largely intended as an optimization; consumers should still call <see cref="M:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext.EnqueueWatchingFile(System.String)" />
            for files they want to watch. This allows the caller to give a hint that it is expected that most of the files being
            watched is under this directory, and so it's more efficient just to watch _all_ of the changes in that directory
            rather than creating and tracking a bunch of file watcher state for each file separately. A good example would be
            just creating a single directory watch on the root of a project for source file changes: rather than creating a file watcher
            for each individual file, we can just watch the entire directory and that's it.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectSystem.WatchedDirectory.ExtensionFilter">
            <summary>
            If non-null, only watch the directory for changes to a specific extension. String always starts with a period.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext">
            <summary>
            A context that is watching one or more files.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext.FileChanged">
            <summary>
            Raised when a file has been changed. This may be a file watched explicitly by <see cref="M:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext.EnqueueWatchingFile(System.String)"/> or it could be any
            file in the directory if the <see cref="T:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext"/> was watching a directory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectSystem.IFileChangeContext.EnqueueWatchingFile(System.String)">
            <summary>
            Starts watching a file but doesn't wait for the file watcher to be registered with the operating system. Good if you know
            you'll need a file watched (eventually) but it's not worth blocking yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectSystem.NoOpWatchedFile">
            <summary>
            When a FileChangeWatcher already has a watch on a directory, a request to watch a specific file is a no-op. In that case, we return this token,
            which when disposed also does nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AdditionalDocument">
            <summary>
            Represents an additional file passed down to analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerConfigData">
            <summary>
            Aggregate analyzer config options for a specific path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerConfigData.TreeOptions">
            <summary>
            These options do not fall back.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Checksum">
            <summary>
            Checksum of data can be used later to see whether two data are same or not
            without actually comparing data itself
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Checksum.#ctor(System.Int64,System.Int64)">
            <summary>
            Checksum of data can be used later to see whether two data are same or not
            without actually comparing data itself
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Checksum.HashSize">
            <summary>
            The intended size of the <see cref="T:Microsoft.CodeAnalysis.Checksum"/> structure. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Checksum.Null">
            <summary>
            Represents a default/null/invalid Checksum, equivalent to <c>default(Checksum)</c>.  This values contains
            all zeros which is considered infinitesimally unlikely to ever happen from hashing data (including when
            hashing null/empty/zero data inputs).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Checksum.From(System.Byte[])">
            <summary>
            Create Checksum from given byte array. if byte array is bigger than <see cref="F:Microsoft.CodeAnalysis.Checksum.HashSize"/>, it will be
            truncated to the size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Checksum.From(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Create Checksum from given byte array. if byte array is bigger than <see cref="F:Microsoft.CodeAnalysis.Checksum.HashSize"/>, it will be
            truncated to the size.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CompilationOutputInfo">
            <summary>
            Paths of files produced by the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilationOutputInfo.AssemblyPath">
            <summary>
            Full path to the assembly or module produced by the compilation, or <see langword="null"/> if unknown.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ConstantTextAndVersionSource">
            <summary>
            This value source keeps a strong reference to a value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ConstantTextAndVersionSource.#ctor(Microsoft.CodeAnalysis.TextAndVersion)">
            <summary>
            This value source keeps a strong reference to a value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ConstantTextAndVersionSource.TextLoader">
            <summary>
            Not built from a text loader.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DefaultTextDocumentServiceProvider">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> for regular C#/VB files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Document">
            <summary>
            Represents a source code document that is part of a project.
            It provides access to the source text, parsed syntax tree and the corresponding semantic model.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Document._model">
            <summary>
            A cached reference to the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Document._nullableDisabledModel">
            <summary>
            A cached reference to the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Document._syntaxTreeResultTask">
            <summary>
            A cached task that can be returned once the tree has already been created. This is only set if <see cref="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree"/> returns true,
            so the inner value can be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SourceCodeKind">
            <summary>
            The kind of source code this document contains.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.HasInfoChanged(Microsoft.CodeAnalysis.TextDocument)">
            <summary>
            True if the info of the document change (name, folders, file path; not the content)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree@)">
            <summary>
            Get the current syntax tree for the document if the text is already loaded and the tree is already parsed.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)"/> to fetch the tree, which will parse the tree
            if it's not already parsed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Get the current syntax tree version for the document if the text is already loaded and the tree is already parsed.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxVersionAsync(System.Threading.CancellationToken)"/> to fetch the version, which will load the tree
            if it's not already available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetTopLevelChangeTextVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Gets the version of the document's top level signature if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the syntax tree. This is generally the newer of the text version and the project's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree">
             <summary>
             <see langword="true"/> if this Document supports providing data through the
             <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)"/> methods.
            
             If <see langword="false"/> then these methods will return <see langword="null"/> instead.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel">
             <summary>
             <see langword="true"/> if this Document supports providing data through the
             <see cref="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)"/> method.
            
             If <see langword="false"/> then that method will return <see langword="null"/> instead.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" /> for this document asynchronously.
            </summary>
            <returns>
            The returned syntax tree can be <see langword="null"/> if the <see cref="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree"/> returns <see
            langword="false"/>. This function may cause computation to occur the first time it is called, but will return
            a cached result every subsequent time.  <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>'s can hold onto their roots lazily. So calls 
            to <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(System.Threading.CancellationToken)"/> or <see cref="M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)"/> may end up causing computation
            to occur at that point.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxRoot(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root node of the current syntax tree if the syntax tree has already been parsed and the tree is still cached.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)"/> to fetch the root node, which will parse
            the document if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
            <returns>
            The returned <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> will be <see langword="null"/> if <see
            cref="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree"/> returns <see langword="false"/>.  This function will return
            the same value if called multiple times.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootSynchronously(System.Threading.CancellationToken)">
            <summary>
            Only for features that absolutely must run synchronously (probably because they're
            on the UI thread).  Right now, the only feature this is for is Outlining as VS will
            block on that feature from the UI thread when a document is opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSemanticModel(Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Gets the current semantic model for this document if the model is already computed and still cached.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)"/>, which will compute the semantic model
            if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetNullableDisabledSemanticModel(Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Gets the current nullable disabled semantic model for this document if the model is already computed and still cached.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)"/>, which will compute the semantic model
            if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(Microsoft.CodeAnalysis.SemanticModelOptions,System.Threading.CancellationToken)">
            <summary>
            Gets the nullable disabled semantic model for this document asynchronously.
            </summary>
            <returns>
            The returned <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> may be <see langword="null"/> if <see
            cref="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel"/> returns <see langword="false"/>. This function will
            return the same value if called multiple times.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the semantic model for this document asynchronously.
            </summary>
            <returns>
            The returned <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> may be <see langword="null"/> if <see
            cref="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel"/> returns <see langword="false"/>. This function will
            return the same value if called multiple times.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSemanticModelHelperAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic model for this document asynchronously.
            </summary>
            <returns>
            The returned <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> may be <see langword="null"/> if <see
            cref="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel"/> returns <see langword="false"/>. This function will
            return the same value if called multiple times.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithSourceCodeKind(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new instance of this document updated to have the source code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithSyntaxRoot(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new instance of this document updated to have a syntax tree rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithName(System.String)">
            <summary>
            Creates a new instance of this document updated to have the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFolders(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new instance of this document updated to have the specified folders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFilePath(System.String)">
            <summary>
            Creates a new instance of this document updated to have the specified file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Get the text changes between this document and a prior version of the same document.
            The changes, when applied to the text of the old document, will produce the text of the current document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetLinkedDocumentIds">
            <summary>
            Gets the list of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s that are linked to this
            <see cref="T:Microsoft.CodeAnalysis.Document" />. <see cref="T:Microsoft.CodeAnalysis.Document"/>s are considered to be linked if they
            share the same <see cref="P:Microsoft.CodeAnalysis.TextDocument.FilePath" />. This <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> is excluded from the
            result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFrozenPartialSemantics(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Document.WithFrozenPartialSemantics(System.Boolean,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFrozenPartialSemantics(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a branched version of this document that has its semantic model frozen in whatever state it is available
            at the time, assuming a background process is constructing the semantics asynchronously. Repeated calls to this
            method may return documents with increasingly more complete semantics.
            <para/>
            Use this method to gain access to potentially incomplete semantics quickly.
            <para/> Note: this will give back a solution where this <see cref="T:Microsoft.CodeAnalysis.Document"/>'s project will not run generators
            when getting its compilation.  However, all other projects will still run generators when their compilations are
            requested.
            </summary>
            <param name="forceFreeze">If <see langword="true"/> then a forked document will be returned no matter what. This
            should be used when the caller wants to ensure that further forks of that document will remain frozen and will
            not run generators/skeletons. For example, if it is about to transform the document many times, and is fine with
            the original semantic information they started with.  If <see langword="false"/> then this same document may be
            returned if the compilation for its <see cref="T:Microsoft.CodeAnalysis.Project"/> was already produced.  In this case, generators and
            skeletons will already have been run, so returning the same instance will be fast when getting semantics.
            However, this does mean that future forks of this instance will continue running generators/skeletons.  This
            should be used for most clients that intend to just query for semantic information and do not intend to make any
            further changes.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetOptionsAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the options that should be applied to this document. This consists of global options from <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>,
            merged with any settings the user has specified at the document levels.
            </summary>
            <remarks>
            This method is async because this may require reading other files. In files that are already open, this is expected to be cheap and complete synchronously.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentId">
            <summary>
            An identifier that can be used to retrieve the same <see cref="T:Microsoft.CodeAnalysis.Document"/> across versions of the
            workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentId.CreateNewId(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> instance.
            </summary>
            <param name="projectId">The project id this document id is relative to.</param>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentInfo">
            <summary>
            A class that represents all the arguments necessary to create a new document instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Id">
            <summary>
            The Id of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Folders">
            <summary>
            The names of the logical nested folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.SourceCodeKind">
            <summary>
            The kind of the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.FilePath">
            <summary>
            The file path of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.IsGenerated">
            <summary>
            True if the document is a side effect of the build.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.TextLoader">
            <summary>
            A loader that can retrieve the document text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentServiceProvider">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> associated with this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentInfo.#ctor(Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.Host.IDocumentServiceProvider)">
            <summary>
            Create a new instance of a <see cref="T:Microsoft.CodeAnalysis.DocumentInfo"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentInfo.Create(Microsoft.CodeAnalysis.DocumentId,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.SourceCodeKind,Microsoft.CodeAnalysis.TextLoader,System.String,System.Boolean)">
            <summary>
            Creates info.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes">
            <summary>
            type that contains information regarding this document itself but
            no tree information such as document info
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.#ctor(Microsoft.CodeAnalysis.DocumentId,System.String,System.Collections.Generic.IReadOnlyList{System.String},Microsoft.CodeAnalysis.SourceCodeKind,System.String,System.Boolean,System.Boolean)">
            <summary>
            type that contains information regarding this document itself but
            no tree information such as document info
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.Id">
            <summary>
            The Id of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.Folders">
            <summary>
            The names of the logical nested folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.SourceCodeKind">
            <summary>
            The kind of the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.FilePath">
            <summary>
            The file path of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.IsGenerated">
            <summary>
            True if the document is a side effect of the build.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.DesignTimeOnly">
            <summary>
            True if the source code contained in the document is only used in design-time (e.g. for completion),
            but is not passed to the compiler when the containing project is built, e.g. a Razor view
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentState.LinkedFileReuseTreeAndVersionSource">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ITreeAndVersionSource"/> when we're linked to another file (a 'sibling') and will attempt to reuse
            that sibling's tree as our own. Note: we won't know if we can actually use the contents of that sibling file
            until we actually go and realize it, as it may contains constructs (like pp-directives) that prevent use.  In
            that case, we'll fall back to a normal incremental parse between our original <paramref
            name="originalTreeSource"/> and the latest <em>text</em> contents of our sibling's file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentState.LinkedFileReuseTreeAndVersionSource.#ctor(Microsoft.CodeAnalysis.ITreeAndVersionSource,Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.TreeAndVersion})">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.ITreeAndVersionSource"/> when we're linked to another file (a 'sibling') and will attempt to reuse
            that sibling's tree as our own. Note: we won't know if we can actually use the contents of that sibling file
            until we actually go and realize it, as it may contains constructs (like pp-directives) that prevent use.  In
            that case, we'll fall back to a normal incremental parse between our original <paramref
            name="originalTreeSource"/> and the latest <em>text</em> contents of our sibling's file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentState.UpdateTextAndTreeContents(Microsoft.CodeAnalysis.ITextAndVersionSource,Microsoft.CodeAnalysis.ITreeAndVersionSource,System.Boolean)">
            <summary>
            Returns a new instance of this document state that points to <paramref name="siblingTextSource"/> as the
            text contents of the document, and which will produce a syntax tree that reuses from <paramref
            name="siblingTextSource"/> if possible, or which will incrementally parse the current tree to bring it up to
            date with <paramref name="siblingTextSource"/> otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentState.TreeTextSource">
            <summary>
            A source for <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> constructed from an syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentState.TreeTextSource.#ctor(Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.Text.SourceText},Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            A source for <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> constructed from an syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentState.TreeTextSource.TextLoader">
            <summary>
            Not created from a text loader.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.Path">
            <summary>
            Absolute path of the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding">
            <summary>
            Specifies an encoding to be used if the actual encoding of the file 
            can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If <c>null</c> auto-detect heuristics are used to determine the encoding. 
            Note that if the stream starts with Byte Order Mark the value of <see cref="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding"/> is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a content loader for specified file.
            </summary>
            <param name="path">An absolute file path.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is not an absolute path.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.MaxFileLength">
            <summary>
            We have this limit on file size to reduce a chance of OOM when user adds massive files to the solution (often by accident).
            The threshold is 100MB which came from some internal data on big files and some discussion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.CreateText(System.IO.Stream,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">Stream.</param>
            <param name="workspace">Obsolete. Null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.CreateText(System.IO.Stream,Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionSynchronously(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTextDifferencingService.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Computes the text changes between two documents.
            </summary>
            <param name="oldDocument">The old version of the document.</param>
            <param name="newDocument">The new version of the document.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An array of changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTextDifferencingService.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.TextDifferenceTypes,System.Threading.CancellationToken)">
            <summary>
            Computes the text changes between two documents.
            </summary>
            <param name="oldDocument">The old version of the document.</param>
            <param name="newDocument">The new version of the document.</param>
            <param name="preferredDifferenceType">The type of differencing to perform. Not supported by all text differencing services.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An array of changes.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LoadTextOptions">
            <summary>
            Options used to load <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PreservationMode">
            <summary>
            The mode in which value is preserved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PreservationMode.PreserveValue">
            <summary>
            The value is guaranteed to have the same contents across multiple accesses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PreservationMode.PreserveIdentity">
            <summary>
            The value is guaranteed to the same instance across multiple accesses.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Project">
            <summary>
            Represents a project that is part of a <see cref="P:Microsoft.CodeAnalysis.Project.Solution"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Solution">
            <summary>
            The solution this project is part of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Id">
            <summary>
            The ID of the project. Multiple <see cref="T:Microsoft.CodeAnalysis.Project"/> instances may share the same ID. However, only
            one project may have this ID in any given solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.OutputFilePath">
            <summary>
            The path to the output file, or null if it is not known.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.OutputRefFilePath">
            <summary>
            The path to the reference assembly output file, or null if it is not known.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.CompilationOutputInfo">
            <summary>
            Compilation output file paths.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.DefaultNamespace">
            <summary>
            The default namespace of the project ("" if not defined, which means global namespace),
            or null if it is unknown or not applicable. 
            </summary>
            <remarks>
            Right now VB doesn't have the concept of "default namespace". But we conjure one in workspace 
            by assigning the value of the project's root namespace to it. So various feature can choose to 
            use it for their own purpose.
            In the future, we might consider officially exposing "default namespace" for VB project 
            (e.g. through a "defaultnamespace" msbuild property)
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.SupportsCompilation">
            <summary>
            <see langword="true"/> if this <see cref="T:Microsoft.CodeAnalysis.Project"/> supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> method.
            
            If <see langword="false"/> then <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> method will return <see langword="null"/> instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.LanguageServices">
            <summary>
            The language services from the host environment associated with this project's language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Services">
            <summary>
            Immutable snapshot of language services from the host environment associated with this project's language.
            Use this over <see cref="P:Microsoft.CodeAnalysis.Project.LanguageServices"/> when possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Language">
            <summary>
            The language associated with the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AssemblyName">
            <summary>
            The name of the assembly this project represents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Name">
            <summary>
            The name of the project. This may be different than the assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.MetadataReferences">
            <summary>
            The list of all other metadata sources (assemblies) that this project references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.ProjectReferences">
            <summary>
            The list of all other projects within the same solution that this project references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AllProjectReferences">
            <summary>
            The list of all other projects that this project references, including projects that 
            are not part of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerReferences">
            <summary>
            The list of all the diagnostic analyzer references for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerOptions">
            <summary>
            The options used by analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.HostAnalyzerOptions">
            <summary>
            The options used by analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.CompilationOptions">
            <summary>
            The options used when building the compilation for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.ParseOptions">
            <summary>
            The options used when parsing documents for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.IsSubmission">
            <summary>
            Returns true if this is a submission project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.HasDocuments">
            <summary>
            True if the project has any documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.DocumentIds">
            <summary>
            All the document IDs associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AdditionalDocumentIds">
            <summary>
            All the additional document IDs associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerConfigDocumentIds">
            <summary>
            All the additional document IDs associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Documents">
            <summary>
            All the regular documents associated with this project. Documents produced from source generators are returned by
            <see cref="M:Microsoft.CodeAnalysis.Project.GetSourceGeneratedDocumentsAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AdditionalDocuments">
            <summary>
            All the additional documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerConfigDocuments">
            <summary>
            All the <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>s associated with this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains a document with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains an additional document with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains an <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get the documentId in this project with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get the document in this project with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the additional document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the analyzer config document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocumentAsync(Microsoft.CodeAnalysis.DocumentId,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets a document or a source generated document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetTextDocumentAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Gets a document, additional document, analyzer config document or a source generated document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetSourceGeneratedDocumentsAsync(System.Threading.CancellationToken)">
            <summary>
            Gets all source generated documents in this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.TryGetSourceGeneratedDocumentForAlreadyGeneratedId(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.SourceGeneratedDocumentState"/> for a source generated document that has already been generated and observed.
            </summary>
            <remarks>
            This is only safe to call if you already have seen the SyntaxTree or equivalent that indicates the document state has already been
            generated. This method exists to implement <see cref="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)"/> and is best avoided unless you're doing something
            similarly tricky like that.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)">
            <summary>
            Tries to get the cached <see cref="T:Microsoft.CodeAnalysis.Compilation"/> for this project if it has already been created and is still cached. In almost all
            cases you should call <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> which will either return the cached <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            or create a new one otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> for this project asynchronously.
            </summary>
            <returns>
            Returns the produced <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, or <see langword="null"/> if <see
            cref="P:Microsoft.CodeAnalysis.Project.SupportsCompilation"/> returns <see langword="false"/>. This function will
            return the same value if called multiple times.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.HasSuccessfullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Determines if the compilation returned by <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> and all its referenced compilation are from fully loaded projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetChanges(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets an object that lists the added, changed and removed documents between this project and the specified project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Version">
            <summary>
            The project version. This equates to the version of the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetLatestDocumentVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The version of the most recently modified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The most recent version of the project, its documents and all dependent projects and documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The semantic version of this project including the semantics of referenced projects.
            This version changes whenever the consumable declarations of this project and/or projects it depends on change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetSemanticVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The semantic version of this project not including the semantics of referenced projects.
            This version changes only when the consumable declarations of this project change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentChecksumAsync(System.Threading.CancellationToken)">
            <summary>
            Calculates a checksum that contains a project's checksum along with a checksum for each of the project's 
            transitive dependencies.
            </summary>
            <remarks>
            This checksum calculation can be used for cases where a feature needs to know if the semantics in this project
            changed.  For example, for diagnostics or caching computed semantic data. The goal is to ensure that changes to
            <list type="bullet">
               <item>Files inside the current project</item>
               <item>Project properties of the current project</item>
               <item>Visible files in referenced projects</item>
               <item>Project properties in referenced projects</item>
            </list>
            are reflected in the metadata we keep so that comparing solutions accurately tells us when we need to recompute
            semantic work.   
            
            <para>This method of checking for changes has a few important properties that differentiate it from other methods of determining project version.
            <list type="bullet">
               <item>Changes to methods inside the current project will be reflected to compute updated diagnostics.
                   <see cref="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)"/> does not change as it only returns top level changes.</item>
               <item>Reloading a project without making any changes will re-use cached diagnostics.
                   <see cref="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)"/> changes as the project is removed, then added resulting in a version change.</item>
            </list>   
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAssemblyName(System.String)">
            <summary>
            Creates a new instance of this project updated to have the new assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithDefaultNamespace(System.String)">
            <summary>
            Creates a new instance of this project updated to have the new default namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithCompilationOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Creates a new instance of this project updated to have the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithParseOptions(Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Creates a new instance of this project updated to have the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddProjectReference(Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Creates a new instance of this project updated to include the specified project reference
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddProjectReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Creates a new instance of this project updated to include the specified project references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithProjectReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Creates a new instance of this project updated to replace existing project references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddMetadataReference(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new instance of this project updated to include the specified metadata reference
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddMetadataReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new instance of this project updated to include the specified metadata references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveMetadataReference(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithMetadataReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new instance of this project updated to replace existing metadata reference
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Creates a new instance of this project updated to include the specified analyzer reference 
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new instance of this project updated to include the specified analyzer references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new instance of this project updated to replace existing analyzer references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAttributes(Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes)">
            <summary>
            Creates a new instance of this project updated to replace existing analyzer references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAdditionalDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new additional document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAdditionalDocument(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new additional document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerConfigDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new analyzer config document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new instance of this project updated to no longer include the specified documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified additional document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAdditionalDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new instance of this project updated to no longer include the specified additional documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified analyzer config document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAnalyzerConfigDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance that no longer includes the specified <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetFallbackAnalyzerOptions">
            <summary>
            Retrieves fallback analyzer options for this project's language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetAddedDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of added documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of the <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetAddedAdditionalDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of added dditional documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetAddedAnalyzerConfigDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of added analyzer config documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetChangedDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of documents with any changes (textual and non-textual)
            in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetChangedDocuments(System.Boolean)">
            <summary>
            Get changed documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            When <paramref name="onlyGetDocumentsWithTextChanges"/> is true, only get documents with text changes (we only check text source, not actual content);
            otherwise get documents with any changes i.e. <see cref="T:Microsoft.CodeAnalysis.ParseOptions"/>, <see cref="T:Microsoft.CodeAnalysis.SourceCodeKind"/> and file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetChangedAdditionalDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of additional documents with any changes (textual and non-textual)
            in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetChangedAnalyzerConfigDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of analyzer config documents with any changes (textual and non-textual)
            in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.NewProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetRemovedDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of removed documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.OldProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetRemovedAdditionalDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of removed additional documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.OldProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetRemovedAnalyzerConfigDocuments">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of removed analyzer config documents in the order they appear in <see cref="P:Microsoft.CodeAnalysis.Project.DocumentIds"/> of <see cref="P:Microsoft.CodeAnalysis.ProjectChanges.OldProject"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectCone">
            <summary>
            Represents a 'cone' of projects that is being sync'ed between the local and remote hosts.  A project cone starts
            with a <see cref="F:Microsoft.CodeAnalysis.ProjectCone.RootProjectId"/>, and contains both it and all dependent projects within <see cref="F:Microsoft.CodeAnalysis.ProjectCone.ProjectIds"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectDependencyGraph">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> models the dependencies between projects in a solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap">
             <summary>
             The map of projects to dependencies. This field is always fully initialized. Projects which do not reference
             any other projects do not have a key in this map (i.e. they are omitted, as opposed to including them with
             an empty value).
            
             <list type="bullet">
             <item><description>This field is always fully initialized</description></item>
             <item><description>Projects which do not reference any other projects do not have a key in this map (i.e.
             they are omitted, as opposed to including them with an empty value)</description></item>
             <item><description>The keys and values in this map are always contained in
             <see cref="P:Microsoft.CodeAnalysis.ProjectDependencyGraph.ProjectIds"/></description></item>
             </list>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap">
            <summary>
            The lazily-initialized map of projects to projects which reference them. This field is either null, or
            fully-computed. Projects which are not referenced by any other project do not have a key in this map (i.e.
            they are omitted, as opposed to including them with an empty value).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectDependencyGraph.Empty">
            <remarks>
              Intentionally created with a null reverseReferencesMap. Doing so indicates _lazyReverseReferencesMap
               shouldn't be calculated until reverse reference information is requested. Once this information
               has been calculated, forks of this PDG will calculate their new reverse references in a non-lazy fashion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatThisProjectDirectlyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that this project directly depends on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatDirectlyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly depend on this project.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.TryGetProjectsThatThisProjectTransitivelyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively this project depends on, if it has already been
            cached.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatThisProjectTransitivelyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively this project depends on
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatTransitivelyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively depend on this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetTopologicallySortedProjects(System.Threading.CancellationToken)">
            <summary>
            Returns all the projects for the solution in a topologically sorted order with respect
            to their dependencies. Projects that depend on other projects will always show up later in this sequence
            than the projects they depend on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetDependencySets(System.Threading.CancellationToken)">
            <summary>
            Returns a sequence of sets, where each set contains items with shared interdependency,
            and there is no dependency between sets.  Each set returned will sorted in topological order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.TestAccessor.TryGetProjectsThatTransitivelyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively depend on this project, if it has already been
            cached.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.DoesProjectTransitivelyDependOnProject(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Checks whether <paramref name="id"/> depends on <paramref name="potentialDependency"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> for the addition of additional project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the addition of additional project references.
            </summary>
            <param name="existingReverseReferencesMap">The previous <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/>, or
            <see langword="null"/> if the reverse references map was not computed for the previous graph.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewTransitiveReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._transitiveReferencesMap"/> for the addition of additional project references. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseTransitiveReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._reverseTransitiveReferencesMap"/> for the addition of new projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForRemovedAllProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the removal of all project references from a
            project.
            </summary>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal,
            or <see langword="null"/> if the reverse references map was not computed for the prior graph.</param>
            <param name="projectId">The project ID from which a project reference is being removed.</param>
            <param name="referencedProjectIds">The targets of the project references which are being removed.</param>
            <returns>The updated (complete) reverse references map, or <see langword="null"/> if the reverse references
            map could not be incrementally updated.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> for the removal of a project.
            </summary>
            <param name="existingForwardReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> prior to the removal.</param>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal.
            This map serves as a hint to the removal process; i.e. it is assumed correct if it contains data, but may be
            omitted without impacting correctness.</param>
            <param name="removedProjectId">The ID of the project which is being removed.</param>
            <returns>The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> for the project dependency graph once the project is removed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the removal of a project.
            </summary>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal,
            or <see langword="null"/> if the value prior to removal was not computed for the graph.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._transitiveReferencesMap"/> for the removal of a project.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._reverseTransitiveReferencesMap"/> for the removal of a project.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForRemovedProjectReference(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the removal of a project reference.
            </summary>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal,
            or <see langword="null"/> if the reverse references map was not computed for the prior graph.</param>
            <param name="projectId">The project ID from which a project reference is being removed.</param>
            <param name="referencedProjectId">The target of the project reference which is being removed.</param>
            <returns>The updated (complete) reverse references map, or <see langword="null"/> if the reverse references
            map could not be incrementally updated.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectId">
            <summary>
            An identifier that can be used to refer to the same <see cref="T:Microsoft.CodeAnalysis.Project"/> across versions.
            </summary>
            <remarks>
            This supports the general message-pack <see cref="T:System.Runtime.Serialization.DataContractAttribute"/> of being serializable.  However, in
            practice, this is not serialized directly, but through the use of a custom formatter <see
            cref="T:Microsoft.CodeAnalysis.Remote.MessagePackFormatters.ProjectIdFormatter"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectId._lazyChecksum">
            <summary>
            Checksum of this ProjectId, built only from <see cref="P:Microsoft.CodeAnalysis.ProjectId.Id"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectId.Id">
            <summary>
            The system generated unique id.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectId._debugName">
            <summary>
            An optional name to show <em>only</em> for debugger-display purposes.  This must not be used for any other
            purpose.  Importantly, it must not be part of the equality/hashing/comparable contract of this type (including
            <see cref="F:Microsoft.CodeAnalysis.ProjectId._lazyChecksum"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectId.CreateNewId(System.String)">
            <summary>
            Create a new ProjectId instance.
            </summary>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectInfo">
            <summary>
            A class that represents all the arguments necessary to create a new project instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Id">
            <summary>
            The unique Id of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Version">
            <summary>
            The version of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Name">
            <summary>
            The name of the project. This may differ from the project's filename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.NameAndFlavor">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.NameAndFlavor"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AssemblyName">
            <summary>
            The name of the assembly that this project will create, without file extension.
            </summary>,
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Language">
            <summary>
            The language of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.OutputFilePath">
            <summary>
            The path to the output file (module or assembly).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.OutputRefFilePath">
            <summary>
            The path to the reference assembly output file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.CompilationOutputInfo">
            <summary>
            The path to the compiler output file (module or assembly).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.DefaultNamespace">
            <summary>
            The default namespace of the project ("" if not defined, which means global namespace),
            or null if it is unknown or not applicable.
            </summary>
            <remarks>
            Right now VB doesn't have the concept of "default namespace", but we conjure one in workspace
            by assigning the value of the project's root namespace to it. So various features can choose to
            use it for their own purpose.
            In the future, we might consider officially exposing "default namespace" for VB project
            (e.g. through a "defaultnamespace" msbuild property)
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ChecksumAlgorithm">
            <summary>
            Algorithm to calculate content checksum for debugging purposes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.IsSubmission">
            <summary>
            True if this is a submission project for interactive sessions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.HasAllInformation">
            <summary>
            True if project information is complete. In some workspace hosts, it is possible
            a project only has partial information. In such cases, a project might not have all
            information on its files or references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.RunAnalyzers">
            <summary>
            True if we should run analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.HasSdkCodeStyleAnalyzers">
            <summary>
            True if the project contains references to the SDK CodeStyle analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.CompilationOptions">
            <summary>
            The initial compilation options for the project, or null if the default options should be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ParseOptions">
            <summary>
            The initial parse options for the source code documents in this project, or null if the default options should be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Documents">
            <summary>
            The list of source documents initially associated with the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectReferences">
            <summary>
            The project references initially defined for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.MetadataReferences">
            <summary>
            The metadata references initially defined for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AnalyzerReferences">
            <summary>
            The analyzers initially associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AdditionalDocuments">
            <summary>
            The list of non-source documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AnalyzerConfigDocuments">
            <summary>
            The list of analyzerconfig documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.HostObjectType">
            <summary>
            Type of the host object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.Create(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Boolean,System.Type)">
            <summary>
            Create a new instance of a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.Create(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Boolean,System.Type,System.String)">
            <summary>
            Create a new instance of a <see cref="T:Microsoft.CodeAnalysis.ProjectInfo"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes">
            <summary>
            type that contains information regarding this project itself but
            no tree information such as document info
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.#ctor(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOutputInfo,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.String,System.String,System.String,System.String,System.Guid,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            type that contains information regarding this project itself but
            no tree information such as document info
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.s_projectNameAndFlavor">
            <summary>
            Matches names like: Microsoft.CodeAnalysis.Features (netcoreapp3.1)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Id">
            <summary>
            The unique Id of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Version">
            <summary>
            The version of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Name">
            <summary>
            The name of the project. This may differ from the project's filename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.AssemblyName">
            <summary>
            The name of the assembly that this project will create, without file extension.
            </summary>,
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Language">
            <summary>
            The language of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.OutputFilePath">
            <summary>
            The path to the output file (module or assembly).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.OutputRefFilePath">
            <summary>
            The path to the reference assembly output file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.CompilationOutputInfo">
            <summary>
            Paths to the compiler output files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.DefaultNamespace">
            <summary>
            The default namespace of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.ChecksumAlgorithm">
            <summary>
            Algorithm to calculate content checksum for debugging purposes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.IsSubmission">
            <summary>
            True if this is a submission project for interactive sessions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.HasAllInformation">
            <summary>
            True if project information is complete. In some workspace hosts, it is possible
            a project only has partial information. In such cases, a project might not have all
            information on its files or references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.RunAnalyzers">
            <summary>
            True if we should run analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.TelemetryId">
            <summary>
            The id report during telemetry events.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.HasSdkCodeStyleAnalyzers">
            <summary>
            True if the project contains references to the SDK CodeStyle analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.NameAndFlavor">
            <summary>
            The name and flavor portions of the project broken out.  For example, the project
            <c>Microsoft.CodeAnalysis.Workspace (netcoreapp3.1)</c> would have the name
            <c>Microsoft.CodeAnalysis.Workspace</c> and the flavor <c>netcoreapp3.1</c>.  Values may be null <see
            langword="null"/> if the name does not contain a flavor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectReference.Aliases">
            <summary>
            Aliases for the reference. Empty if the reference has no aliases.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectReference.EmbedInteropTypes">
            <summary>
            True if interop types defined in the referenced project should be embedded into the referencing project.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectState.AnalyzerConfigOptionsCache">
            <summary>
            Holds on a map from source path to <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigData"/> calculated by the compiler and chained to <paramref name="fallbackOptions"/>.
            This cache is stored on <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> and needs to be invalidated whenever <see cref="P:Microsoft.CodeAnalysis.SolutionState.FallbackAnalyzerOptions"/> for the language of the project change,
            editorconfig file is updated, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectState.AnalyzerConfigOptionsCache.#ctor(Microsoft.CodeAnalysis.TextDocumentStates{Microsoft.CodeAnalysis.AnalyzerConfigDocumentState},Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions)">
            <summary>
            Holds on a map from source path to <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigData"/> calculated by the compiler and chained to <paramref name="fallbackOptions"/>.
            This cache is stored on <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> and needs to be invalidated whenever <see cref="P:Microsoft.CodeAnalysis.SolutionState.FallbackAnalyzerOptions"/> for the language of the project change,
            editorconfig file is updated, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState.DocumentStates">
            <summary>
            The documents in this project. They are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/> to provide a stable sort for
            <see cref="M:Microsoft.CodeAnalysis.ProjectState.GetChecksumAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState.AdditionalDocumentStates">
            <summary>
            The additional documents in this project. They are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/> to provide a stable sort for
            <see cref="M:Microsoft.CodeAnalysis.ProjectState.GetChecksumAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState.AnalyzerConfigDocumentStates">
            <summary>
            The analyzer config documents in this project.  They are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/> to provide a stable sort for
            <see cref="M:Microsoft.CodeAnalysis.ProjectState.GetChecksumAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState._analyzerConfigOptionsCache">
            <summary>
            Analyzer config options to be used for specific trees.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectState.RazorDesignTimeAnalyzerConfigOptions">
            <summary>
            Provides editorconfig options for Razor design-time documents.
            Razor does not support editorconfig options but has custom settings for a few formatting options whose values
            are only available in-proc and the same for all Razor design-time documents.
            This type emulates these options as analyzer config options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectState.RazorDesignTimeAnalyzerConfigOptions.#ctor(Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Provides editorconfig options for Razor design-time documents.
            Razor does not support editorconfig options but has custom settings for a few formatting options whose values
            are only available in-proc and the same for all Razor design-time documents.
            This type emulates these options as analyzer config options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectState.NameAndFlavor">
            <inheritdoc cref="P:Microsoft.CodeAnalysis.ProjectInfo.NameAndFlavor"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectState.WithNewerAttributes(Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes)">
            <summary>
            Updates <see cref="P:Microsoft.CodeAnalysis.ProjectState.ProjectInfo"/> to a newer version of attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectState.ContainsReferenceToProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Determines whether <see cref="P:Microsoft.CodeAnalysis.ProjectState.ProjectReferences"/> contains a reference to a specified project.
            </summary>
            <param name="projectId">The target project of the reference.</param>
            <returns><see langword="true"/> if this project references <paramref name="projectId"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Solution">
            <summary>
            Represents a set of projects and their source code documents. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Solution._cachedFrozenSolution">
            <summary>
            Result of calling <see cref="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilationsAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Solution._documentIdToFrozenSolution">
            <summary>
            Mapping of DocumentId to the frozen solution we produced for it the last time we were queried.  This
            instance should be used as its own lock when reading or writing to it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Services">
            <summary>
            Per solution services provided by the host environment.  Use this instead of <see
            cref="P:Microsoft.CodeAnalysis.Workspace.Services"/> when possible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Workspace">
            <summary>
            The Workspace this solution is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Id">
            <summary>
            The Id of the solution. Multiple solution instances may share the same Id.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.FilePath">
            <summary>
            The path to the solution file or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Version">
            <summary>
            The solution version. This equates to the solution file's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.ProjectIds">
            <summary>
            A list of all the ids for all the projects contained by the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Projects">
            <summary>
            A list of all the projects contained by the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetLatestProjectVersion">
            <summary>
            The version of the most recently modified project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            True if the solution contains a project with the specified project ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the project in this solution with the specified project ID. 
            
            If the id is not an id of a project that is part of this solution the method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.IAssemblySymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Project"/> associated with an assembly symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetOriginatingProjectId(Microsoft.CodeAnalysis.ISymbol)">
             <summary>
             Given a <paramref name="symbol"/> returns the <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> of the <see cref="T:Microsoft.CodeAnalysis.Project"/> it came
             from.  Returns <see langword="null"/> if <paramref name="symbol"/> does not come from any project in this solution.
             </summary>
             <remarks>
             This function differs from <see cref="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.IAssemblySymbol,System.Threading.CancellationToken)"/> in terms of how it
             treats <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>s.  Specifically, say there is the following:
            
             <c>
             Project-A, containing Symbol-A.<para/>
             Project-B, with a reference to Project-A, and usage of Symbol-A.
             </c>
            
             It is possible (with retargeting, and other complex cases) that Symbol-A from Project-B will be a different
             symbol than Symbol-A from Project-A.  However, <see cref="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.IAssemblySymbol,System.Threading.CancellationToken)"/>
             will always try to return Project-A for either of the Symbol-A's, as it prefers to return the original
             Source-Project of the original definition, not the project that actually produced the symbol.  For many
             features this is an acceptable abstraction.  However, for some cases (Find-References in particular) it is
             necessary to resolve symbols back to the actual project/compilation that produced them for correctness.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetOriginatingProject(Microsoft.CodeAnalysis.ISymbol)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Solution.GetOriginatingProjectId(Microsoft.CodeAnalysis.ISymbol)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetOriginatingCompilation(Microsoft.CodeAnalysis.ISymbol)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Solution.GetOriginatingProjectId(Microsoft.CodeAnalysis.ISymbol)"/>
            <remarks>
            Returns the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> that produced the symbol.  In the case of a symbol that was retargetted
            this will be the compilation it was retargtted into, not the original compilation that it was retargetted from.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the additional document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the analyzer config document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the documentId in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the documentId in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentAsync(Microsoft.CodeAnalysis.DocumentId,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets a document or a source generated document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetTextDocumentAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Gets a document, additional document, analyzer config document or a source generated document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the additional document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the analyzer config document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the document in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(System.String,System.String,System.String)">
            <summary>
            Creates a new solution instance that includes a project with the specified language and names.
            Returns the new project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.String)">
            <summary>
            Creates a new solution instance that includes a project with the specified language and names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectInfo})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectInfo})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectInfo})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProject(Microsoft.CodeAnalysis.ProjectId)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.RemoveProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.RemoveProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the new
            assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectOutputRefFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the reference assembly output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectCompilationOutputInfo(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOutputInfo@)">
            <summary>
            Creates a new solution instance with the project specified updated to have the compiler output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectDefaultNamespace(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the default namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectChecksumAlgorithm(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Creates a new solution instance with the project specified updated to have the specified attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the project file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFallbackAnalyzerOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})">
            <summary>
            Create a new solution instance updated to use the specified <see cref="P:Microsoft.CodeAnalysis.Solution.FallbackAnalyzerOptions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithHasAllInformation(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified hasAllInformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithRunAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified runAnalyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithHasSdkCodeStyleAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified hasSdkCodeStyleAnalyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectDocumentsOrder(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableList{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance with the project documents in the order by the specified document ids.
            The specified document ids must be the same as what is already in the project; no adding or removing is allowed.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="documentIds"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.ArgumentException">The number of documents specified in <paramref name="documentIds"/> is not equal to the number of documents in project <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">Document specified in <paramref name="documentIds"/> does not exist in project <paramref name="projectId"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAttributes(Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes)">
            <summary>
            Updates the solution with project information stored in <paramref name="attributes"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectInfo(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Updates the solution with project information stored in <paramref name="info"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project already references the target project.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="projectReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project already references the target project.</exception>
            <exception cref="T:System.InvalidOperationException">Adding the project reference would create a circular dependency.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer
            include the specified project reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException">The solution does not contain <paramref name="projectId"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to contain
            the specified list of project references.
            </summary>
            <param name="projectId">Id of the project whose references to replace with <paramref name="projectReferences"/>.</param>
            <param name="projectReferences">New project references.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="projectReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified metadata reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project already contains the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified metadata references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="metadataReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project already contains the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified metadata reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project does not contain the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified metadata references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="metadataReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="metadataReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified analyzer reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified analyzer references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="analyzerReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project already contains the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified analyzer reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The project does not contain the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified analyzer references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="projectId"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="analyzerReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain <paramref name="projectId"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance updated to include the specified analyzer reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReference"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance updated to include the specified analyzer references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="analyzerReferences"/> contains duplicate items.</exception>
            <exception cref="T:System.InvalidOperationException">The solution already contains the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified analyzer reference.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReference"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.InvalidOperationException">The solution does not contain the specified reference.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new solution instance with the specified analyzer references.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="analyzerReferences"/> contains <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="analyzerReferences"/> contains duplicate items.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and root <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.TextLoader,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new solution instance with the project updated to include a new document with
            the arguments specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Create a new solution instance with the corresponding project updated to include a new 
            document instanced defined by the document info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Create a new <see cref="T:Microsoft.CodeAnalysis.Solution"/> instance with the corresponding <see cref="T:Microsoft.CodeAnalysis.Project"/>s updated to include
            the documents specified by <paramref name="documentInfos"/>.
            </summary>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.Solution"/> with the documents added.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            additional document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            additional document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            analyzer config document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerConfigDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Creates a new Solution instance that contains a new compiler configuration document like a .editorconfig file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance that no longer includes the specified documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified additional document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAdditionalDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance that no longer includes the specified additional documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAnalyzerConfigDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance that no longer includes the specified <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentName(Microsoft.CodeAnalysis.DocumentId,System.String)">
            <summary>
            Creates a new solution instance with the document specified updated to have the new name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentFolders(Microsoft.CodeAnalysis.DocumentId,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new solution instance with the document specified updated to be contained in
            the sequence of logical folders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentFilePath(Microsoft.CodeAnalysis.DocumentId,System.String)">
            <summary>
            Creates a new solution instance with the document specified updated to have the specified file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSyntaxRoot(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have a syntax tree
            rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSyntaxRoots(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode}},Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Solution.WithDocumentSyntaxRoot(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PreservationMode)"/>.
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new solution instance with the document specified updated to have the source
            code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAdditionalDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerConfigDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilations(System.Threading.CancellationToken)">
            <summary>
            Returns a solution instance where every project is frozen at whatever current state it is in
            </summary>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilationsAsync(System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilations(System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilationIncludingSpecificDocument(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Creates a branch of the solution that has its compilations frozen in whatever state they are in at the time,
            assuming a background compiler is busy building this compilations.
            <para/> A compilation for the project containing the specified document id will be guaranteed to exist with
            at least the syntax tree for the document.
            <para/> This not intended to be the public API, use Document.WithFrozenPartialSemantics() instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetFirstRelatedDocumentId(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns one of any of the related documents of <paramref name="documentId"/>.  Importantly, this will never
            return <paramref name="documentId"/> (unlike <see cref="M:Microsoft.CodeAnalysis.Solution.GetRelatedDocumentIds(Microsoft.CodeAnalysis.DocumentId)"/> which includes the original
            file in the result).
            </summary>
            <param name="relatedProjectIdHint">A hint on the first project to search when looking for related
            documents.  Must not be the project that <paramref name="documentId"/> is from.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetIsolatedSolution">
            <summary>
            Formerly, returned a copy of the solution isolated from the original so that they do not share computed state. It now does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with all the documents specified updated to have the same specified text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFrozenSourceGeneratedDocument(Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity,System.DateTime,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Returns a new Solution that will always produce a specific output for a generated file. This is used only in the
            implementation of <see cref="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContextWithChanges(Microsoft.CodeAnalysis.Text.SourceText)"/> where if a user has a source
            generated file open, we need to make sure everything lines up.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.UpdateSpecificSourceGeneratorExecutionVersions(Microsoft.CodeAnalysis.SourceGeneratorExecutionVersionMap)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.UpdateSpecificSourceGeneratorExecutionVersions(Microsoft.CodeAnalysis.SourceGeneratorExecutionVersionMap)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithoutFrozenSourceGeneratedDocuments">
            <summary>
            Undoes the operation of <see cref="M:Microsoft.CodeAnalysis.Solution.WithFrozenSourceGeneratedDocument(Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity,System.DateTime,Microsoft.CodeAnalysis.Text.SourceText)"/>; any frozen source generated document is allowed
            to have it's real output again.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithCachedSourceGeneratorState(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Project)">
            <summary>
            Returns a new Solution which represents the same state as before, but with the cached generator driver state from the given project updated to match.
            </summary>
            <remarks>
            When generators are ran in a Solution snapshot, they may cache state to speed up future runs. For Razor, we only run their generator on forked
            solutions that are thrown away; this API gives us a way to reuse that cached state in other forked solutions, since otherwise there's no way to reuse
            the cached state.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetChanges(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Gets an objects that lists the added, changed and removed projects between
            this solution and the specified solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentIdsWithFilePath(System.String)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s in this <see cref="T:Microsoft.CodeAnalysis.Solution"/> with a
            <see cref="P:Microsoft.CodeAnalysis.TextDocument.FilePath"/> that matches the given file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProjectDependencyGraph">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> that details the dependencies between projects for this solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Options">
            <summary>
            Returns the options that should be applied to this solution. This is equivalent to <see cref="P:Microsoft.CodeAnalysis.Workspace.Options" /> when the <see cref="T:Microsoft.CodeAnalysis.Solution"/> 
            instance was created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.AnalyzerReferences">
            <summary>
            Analyzer references associated with the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.FallbackAnalyzerOptions">
            <summary>
            Fallback analyzer config options by language. The set of languages does not need to match the set of languages of projects included in the current solution snapshot
            since these options can be updated independently of the projects contained in the solution.
            Generally, the host is responsible for keeping these options up-to-date with whatever option store it maintains
            and for making sure fallback options are available in the solution for all languages the host supports.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithOptions(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Creates a new solution instance with the specified <paramref name="options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithOptions(Microsoft.CodeAnalysis.Options.SolutionOptionSet)">
            <summary>
            Creates a new solution instance with the specified serializable <paramref name="options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CheckCircularProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Throws if setting the project references of project <paramref name="projectId"/> to specified <paramref name="projectReferences"/>
            would form a cycle in project dependency graph.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.CheckSubmissionProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Boolean)">
            <summary>
            Throws if setting the project references of project <paramref name="projectId"/> to specified <paramref name="projectReferences"/>
            would form an invalid submission project chain.
            
            Submission projects can reference at most one other submission project. Regular projects can't reference any.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Solution._activeDocumentSemanticModel">
            <summary>
            Strongly held reference to the semantic model for the active document.  By strongly holding onto it, we ensure
            that it won't be GC'ed between feature requests from multiple features that care about it.  As the active
            document has the most features running on it continuously, we definitely do not want to drop this.  Note: this
            cached value is only to help with performance.  Not with correctness.  Importantly, the concept of 'active
            document' is itself fundamentally racy.  That's ok though as we simply want to settle on these semantic models
            settling into a stable state over time.  We don't need to be perfect about it.  They are intentionally not
            locked either as we would only have contention right when switching to a new active document, and we would still
            latch onto the new document very quickly.
            </summary>
            <remarks>
            It is fine for these fields to never be read.  The purpose is simply to keep a strong reference around so that
            they will not be GC'ed as long as the active document stays the same.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Solution._activeDocumentNullableDisabledSemanticModel">
            <inheritdoc cref="F:Microsoft.CodeAnalysis.Solution._activeDocumentSemanticModel"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker">
            <summary>
            Tracks the changes made to a project and provides the facility to get a lazily built
            compilation for that project.  As the compilation is being built, the partial results are
            stored as well so that they can be used in the 'in progress' workspace snapshot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState">
            <summary>
            The base type of all <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker"/> states. The state of a <see
            cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker" /> starts at null, and then will progress through the other states until it
            finally reaches <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState" />.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState.CreationPolicy">
            <summary>
            Whether the generated documents in <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState.GeneratorInfo"/> are frozen and generators should
            never be ran again, ever, even if a document is later changed. This is used to ensure that when we
            produce a frozen solution for partial semantics, further downstream forking of that solution won't
            rerun generators. This is because of two reasons:
            <list type="number">
            <item>Generally once we've produced a frozen solution with partial semantics, we now want speed rather
            than accuracy; a generator running in a later path will still cause issues there.</item>
            <item>The frozen solution with partial semantics makes no guarantee that other syntax trees exist or
            whether we even have references -- it's pretty likely that running a generator might produce worse results
            than what we originally had.</item>
            </list>
            This also controls if we will generate skeleton references for cross-language P2P references when
            creating the compilation for a particular project.  When entirely frozen, we do not want to do this due
            to the enormous cost of emitting ref assemblies for cross language cases.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState.CompilationWithoutGeneratedDocuments">
            <summary>
            The best compilation that is available that source generators have not ran on. May be an
            in-progress, full declaration, a final compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.InProgressState">
            <summary>
            A state where we are holding onto a previously built compilation, and have a known set of transformations
            that could get us to a more final state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.InProgressState.LazyStaleCompilationWithGeneratedDocuments">
            <summary>
            The result of taking the original completed compilation that had generated documents and updating
            them by apply the <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction" />; this is not a
            correct snapshot in that the generators have not been rerun, but may be reusable if the generators
            are later found to give the same output.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.InProgressState.PendingTranslationActions">
            <summary>
            The list of changes that have happened since we last computed a compilation. The oldState corresponds to
            the state of the project prior to the mutation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState">
            <summary>
            The final state a compilation tracker reaches. At this point <see
            cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState.FinalCompilationWithGeneratedDocuments"/> is now available. It is a requirement that any <see
            cref="T:Microsoft.CodeAnalysis.Compilation"/> provided to any clients of the <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.SolutionState"/> (for example, through
            <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> or <see cref="M:Microsoft.CodeAnalysis.Project.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)"/> must be from a <see
            cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState"/>.  This is because <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState"/>
            stores extra information in it about that compilation that the <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.SolutionState"/> can be
            queried for (for example: <see cref="M:Microsoft.CodeAnalysis.Solution.GetOriginatingProject(Microsoft.CodeAnalysis.ISymbol)"/>.  If <see
            cref="T:Microsoft.CodeAnalysis.Compilation"/>s from other <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState"/>s are passed out, then these other
            APIs will not function correctly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState.HasSuccessfullyLoaded">
            <summary>
            Specifies whether <see cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState.FinalCompilationWithGeneratedDocuments"/> and all compilations it
            depends on contain full information or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState._rootedSymbolSet">
            <summary>
            Used to determine which project an assembly symbol came from after the fact.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState.FinalCompilationWithGeneratedDocuments">
            <summary>
            The final compilation, with all references and source generators run. This is distinct from <see
            cref="T:Microsoft.CodeAnalysis.Compilation"/>, which in the <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState"/> case will be the
            compilation before any source generators were ran. This ensures that a later invocation of the
            source generators consumes <see cref="T:Microsoft.CodeAnalysis.Compilation"/> which will avoid generators being ran a second
            time on a compilation that already contains the output of other generators. If source generators are
            not active, this is equal to <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState.GeneratedDocumentsUpToDate">
            <summary>
            Whether or not this final compilation state *just* generated documents which exactly correspond to the
            state of the compilation.  False if the generated documents came from a point in the past, and are being
            carried forward until the next time we run generators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.FinalCompilationTrackerState.Create(Microsoft.CodeAnalysis.SolutionCompilationState.CreationPolicy,System.Boolean,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Compilation,System.Boolean,Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerGeneratorInfo,Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.ProjectId})">
            <param name="projectId">Not held onto</param>
            <param name="metadataReferenceToProjectId">Not held onto</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerGeneratorInfo">
            <param name="Documents">
            The best generated documents we have for the current state. 
            </param>
            <param name="Driver">
            The <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.GeneratorDriver"/> that was used for the last run, to allow for incremental reuse. May be
            null if we don't have generators in the first place, haven't ran generators yet for this project, or had to
            get rid of our driver for some reason.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerGeneratorInfo.#ctor(Microsoft.CodeAnalysis.TextDocumentStates{Microsoft.CodeAnalysis.SourceGeneratedDocumentState},Microsoft.CodeAnalysis.GeneratorDriver)">
            <param name="Documents">
            The best generated documents we have for the current state. 
            </param>
            <param name="Driver">
            The <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.GeneratorDriver"/> that was used for the last run, to allow for incremental reuse. May be
            null if we don't have generators in the first place, haven't ran generators yet for this project, or had to
            get rid of our driver for some reason.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerGeneratorInfo.Documents">
            <summary>
            The best generated documents we have for the current state. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerGeneratorInfo.Driver">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.GeneratorDriver"/> that was used for the last run, to allow for incremental reuse. May be
            null if we don't have generators in the first place, haven't ran generators yet for this project, or had to
            get rid of our driver for some reason.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker._stateDoNotAccessDirectly">
            <summary>
            Access via the <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.ReadState"/> and <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.WriteState(Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState)"/> methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker._skeletonReferenceCache">
            <summary>
            Intentionally not readonly.  This is a mutable struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker._validateStates">
            <summary>
            Set via a feature flag to enable strict validation of the compilations that are produced, in that they match the original states. This validation is expensive, so we don't want it
            running in normal production scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.#ctor(Microsoft.CodeAnalysis.ProjectState)">
            <summary>
            Creates a tracker for the provided project.  The tracker will be in the 'empty' state
            and will have no extra information beyond the project itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.Fork(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction)">
            <summary>
            Creates a new instance of the compilation info, retaining any already built
            compilation state as the now 'old' state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)">
            <summary>
            Gets the final compilation if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.ValidateState(Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.CompilationTrackerState)">
            <summary>
            Validates the compilation is consistent and we didn't have a bug in producing it. This only runs under a feature flag.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker.ThrowExceptionIfFalse(System.Boolean,System.String)">
            <summary>
            This is just the same as <see cref="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.String,System.Int32,System.String)"/> but throws a custom exception type to make this easier to find in telemetry since the exception type
            is easily seen in telemetry.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.GeneratedDocumentCreationPolicy">
            <summary>
            Flags controlling if generator documents should be created or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.GeneratedDocumentCreationPolicy.Create">
            <summary>
            Source generators should be run and should produce up to date results.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.GeneratedDocumentCreationPolicy.DoNotCreate">
            <summary>
            Source generators should not run.  Whatever results were previously computed should be reused.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCreationPolicy">
            <summary>
            Flags controlling if skeleton references should be created or not.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCreationPolicy.Create">
            <summary>
            Skeleton references should be created, and should be up to date with the project they are created for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCreationPolicy.CreateIfAbsent">
            <summary>
            Skeleton references should only be created for a compilation if no existing skeleton exists for their
            project from some point in the past.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCreationPolicy.DoNotCreate">
            <summary>
            Skeleton references should not be created at all.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.CreationPolicy.Create">
            <summary>
            Create up to date source generator docs and create up to date skeleton references when needed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.CreationPolicy.DoNotCreate">
            <summary>
            Do not create up to date source generator docs and do not create up to date skeleton references for P2P
            references.  For both, use whatever has been generated most recently.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.s_assemblyOrModuleSymbolToProjectMap">
            <summary>
            Symbols need to be either <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.SolutionState">
            <summary>
            Green version of the information about this Solution instance.  Responsible for non-semantic information
            about the solution structure.  Specifically, the set of green <see cref="T:Microsoft.CodeAnalysis.ProjectState"/>s, with all their
            green <see cref="T:Microsoft.CodeAnalysis.DocumentState"/>s.  Contains the attributes, options and relationships between projects.
            Effectively, everything specified in a project file.  Does not contain anything related to <see
            cref="T:Microsoft.CodeAnalysis.Compilation"/>s or semantics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState._unrootedSymbolToProjectId">
            <summary>
            Cache we use to map between unrooted symbols (i.e. assembly, module and dynamic symbols) and the project
            they came from.  That way if we are asked about many symbols from the same assembly/module we can answer the
            question quickly after computing for the first one.  Created on demand.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ForkProject(Microsoft.CodeAnalysis.StateChange,System.Func{Microsoft.CodeAnalysis.StateChange,Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction},System.Boolean)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.ForkProject(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectDependencyGraph)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ForkProject``1(Microsoft.CodeAnalysis.StateChange,System.Func{Microsoft.CodeAnalysis.StateChange,``0,Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction},System.Boolean,``0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.ForkProject(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectDependencyGraph)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ForceForkProject(Microsoft.CodeAnalysis.StateChange,Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction,System.Boolean)">
            <summary>
            Same as <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.ForkProject(Microsoft.CodeAnalysis.StateChange,System.Func{Microsoft.CodeAnalysis.StateChange,Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction},System.Boolean)"/> except that it will still fork even if newSolutionState is unchanged from <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.SolutionState"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.CreateCompilationTrackerMap``1(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectDependencyGraph,System.Action{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker}.Builder,``0},``0,System.Boolean)">
            <summary>
            Creates a mapping of <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> to <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker"/>
            </summary>
            <param name="changedProjectId">Changed project id</param>
            <param name="dependencyGraph">Dependency graph</param>
            <param name="modifyNewTrackerInfo">Callback to modify tracker information. Return value indicates whether the collection was modified.</param>
            <param name="arg">Data to pass to <paramref name="modifyNewTrackerInfo"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.CreateCompilationTrackerMap``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ProjectId},Microsoft.CodeAnalysis.ProjectDependencyGraph,System.Action{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker}.Builder,``0},``0,System.Boolean)">
            <summary>
            Creates a mapping of <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> to <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker"/>
            </summary>
            <param name="changedProjectIds">Changed project ids</param>
            <param name="dependencyGraph">Dependency graph</param>
            <param name="modifyNewTrackerInfo">Callback to modify tracker information. Return value indicates whether the collection was modified.</param>
            <param name="arg">Data to pass to <paramref name="modifyNewTrackerInfo"/></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.CreateCompilationTrackerMap``2(System.Func{Microsoft.CodeAnalysis.ProjectId,``0,System.Boolean},``0,System.Action{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker}.Builder,``1},``1,System.Boolean)">
            <summary>
            Creates a mapping of <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> to <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker"/>
            </summary>
            <param name="canReuse">Callback to determine whether an item can be reused</param>
            <param name="argCanReuse">Data to pass to <paramref name="argCanReuse"/></param>
            <param name="modifyNewTrackerInfo">Callback to modify tracker information. Return value indicates whether the collection was modified.</param>
            <param name="argModifyNewTrackerInfo">Data to pass to <paramref name="modifyNewTrackerInfo"/></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.SourceGeneratorExecutionVersionMap">
            <summary>
            Map from each project to the <see cref="T:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion"/> it is currently at. Loosely, the
            execution version allows us to have the generated documents for a project get fixed at some point in the past
            when they were generated, up until events happen in the host that cause a need for them to be brought up to
            date.  This is ambient, compilation-level, information about our projects, which is why it is stored at this
            compilation-state level.  When syncing to our OOP process, this information is included, allowing the oop side
            to move its own generators forward when a host changes these versions.
            </summary>
            <remarks>
            Contains information for all projects, even non-C#/VB ones.  Though this will have no meaning for those project
            types.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectInfo})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.AddProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectInfo})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RemoveProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.RemoveProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectOutputRefFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOutputRefFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectCompilationOutputInfo(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOutputInfo@)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectCompilationOutputInfo(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOutputInfo@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectDefaultNamespace(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectCompilationOutputInfo(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOutputInfo@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectChecksumAlgorithm(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectChecksumAlgorithm(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectName(Microsoft.CodeAnalysis.ProjectId,System.String)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithHasAllInformation(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithHasAllInformation(Microsoft.CodeAnalysis.ProjectId,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithRunAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithRunAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithHasSdkCodeStyleAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithHasSdkCodeStyleAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectDocumentsOrder(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableList{Microsoft.CodeAnalysis.DocumentId})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectDocumentsOrder(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableList{Microsoft.CodeAnalysis.DocumentId})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.ProjectReference})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.ProjectReference})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectReference})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectReference})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.MetadataReference})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.MetadataReference})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.MetadataReference})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.MetadataReference})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddAnalyzerReferences(Microsoft.CodeAnalysis.StateChange,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.AddAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithDocumentAttributes``1(Microsoft.CodeAnalysis.DocumentId,``0,System.Func{Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes,``0,Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentAttributes``1(Microsoft.CodeAnalysis.DocumentId,``0,System.Func{Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes,``0,Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.UpdateDocumentsInMultipleProjects``3(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,``1}},``2,System.Func{``0,``1,``2,``0})">
            <summary>
            Applies an update operation <paramref name="updateDocument"/> to specified <paramref name="documentsToUpdate"/>.
            Documents may be in different projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithDocumentStatesOfMultipleProjects``1(System.Collections.Generic.IEnumerable{System.ValueTuple{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{``0}}},System.Func{Microsoft.CodeAnalysis.ProjectState,System.Collections.Immutable.ImmutableArray{``0},Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction})">
            <summary>
            Returns <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState"/> with projects updated to new document states specified in <paramref name="updatedDocumentStatesPerProject"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetUpdateDocumentsTranslationAction``1(Microsoft.CodeAnalysis.ProjectState,System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Updates the <paramref name="oldProjectState"/> to a new state with <paramref name="newDocumentStates"/> and returns a <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction"/> that 
            reflects these changes in the project compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithFallbackAnalyzerOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithFallbackAnalyzerOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithDocumentSyntaxRoots(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode}},Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Solution.WithDocumentSyntaxRoots(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode}},Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.UpdateDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.UpdateDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.UpdateAdditionalDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.UpdateAdditionalDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.UpdateAnalyzerConfigDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionState.UpdateAnalyzerConfigDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetProjectId(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Project"/> associated with an assembly symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetCompilationAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>
            Returns the compilation for the specified <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>.  Can return <see langword="null"/> when the project
            does not support compilations.
            </summary>
            <remarks>
            The compilation is guaranteed to have a syntax tree for each document of the project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetCompilationAsync(Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Returns the compilation for the specified <see cref="T:Microsoft.CodeAnalysis.ProjectState"/>.  Can return <see langword="null"/> when the project
            does not support compilations.
            </summary>
            <remarks>
            The compilation is guaranteed to have a syntax tree for each document of the project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.HasSuccessfullyLoadedAsync(Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Return reference completeness for the given project and all projects this references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetSourceGeneratedDocumentStatesAsync(Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Returns the generated document states for source generated documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetSourceGeneratedDocumentStatesAsync(Microsoft.CodeAnalysis.ProjectState,System.Boolean,System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetSourceGeneratedDocumentStatesAsync(Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.TryGetSourceGeneratedDocumentStateForAlreadyGeneratedId(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.SourceGeneratedDocumentState"/> for a source generated document that has already been generated and observed.
            </summary>
            <remarks>
            This is only safe to call if you already have seen the SyntaxTree or equivalent that indicates the document state has already been
            generated. This method exists to implement <see cref="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)"/> and is best avoided unless you're doing something
            similarly tricky like that.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetMetadataReferenceAsync(Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectReference,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get a metadata reference to this compilation info's compilation with respect to
            another project. For cross language references produce a skeletal assembly. If the
            compilation is not available, it is built. If a skeletal assembly reference is
            needed and does not exist, it is also built.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetMetadataReferenceAsync(Microsoft.CodeAnalysis.ProjectReference,Microsoft.CodeAnalysis.ProjectState,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get a metadata reference for the project's compilation.  Returns <see langword="null"/> upon failure, which 
            can happen when trying to build a skeleton reference that fails to build.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithoutFrozenSourceGeneratedDocuments">
            <summary>
            Undoes the operation of <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocuments(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity,System.DateTime,Microsoft.CodeAnalysis.Text.SourceText}})"/>; any frozen source generated document is allowed
            to have it's real output again.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocuments(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity,System.DateTime,Microsoft.CodeAnalysis.Text.SourceText}})">
            <summary>
            Returns a new SolutionState that will always produce a specific output for a generated file. This is used only in the
            implementation of <see cref="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContextWithChanges(Microsoft.CodeAnalysis.Text.SourceText)"/> where if a user has a source
            generated file open, we need to make sure everything lines up.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.UpdateSpecificSourceGeneratorExecutionVersions(Microsoft.CodeAnalysis.SourceGeneratorExecutionVersionMap)">
            <summary>
            Updates entries in our <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.SourceGeneratorExecutionVersionMap"/> to the corresponding values in the
            given <paramref name="sourceGeneratorExecutionVersions"/>.  Importantly, <paramref
            name="sourceGeneratorExecutionVersions"/> must refer to projects in this solution.  Projects not mentioned in
            <paramref name="sourceGeneratorExecutionVersions"/> will not be touched (and they will stay in the map).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenPartialCompilationIncludingSpecificDocument(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Creates a branch of the solution that has its compilations frozen in whatever state they are in at the time,
            assuming a background compiler is busy building this compilations.
            <para/>
            A compilation for the project containing the specified document id will be guaranteed to exist with at least the
            syntax tree for the document.
            <para/>
            This not intended to be the public API, use Document.WithFrozenPartialSemantics() instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.AddDocumentsToMultipleProjects``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Core helper that takes a set of <see cref="T:Microsoft.CodeAnalysis.DocumentInfo" />s and does the application of the appropriate documents to each project.
            </summary>
            <param name="documentInfos">The set of documents to add.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithCachedSourceGeneratorState(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Project)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Solution.WithCachedSourceGeneratorState(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Project)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithDocumentText(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with all the documents specified updated to have the same specified text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker.ContainsAssemblyOrModuleOrDynamic(Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.Compilation@,System.Nullable{Microsoft.CodeAnalysis.SolutionCompilationState.MetadataReferenceInfo}@)">
            <summary>
            Returns <see langword="true"/> if this <see cref="T:Microsoft.CodeAnalysis.Project"/>/<see cref="T:Microsoft.CodeAnalysis.Compilation"/> could produce the
            given <paramref name="symbol"/>.  The symbol must be a <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>, <see
            cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IDynamicTypeSymbol"/>.
            </summary>
            <remarks>
            If <paramref name="primary"/> is true, then <see cref="P:Microsoft.CodeAnalysis.Compilation.References"/> will not be considered
            when answering this question.  In other words, if <paramref name="symbol"/>  is an <see
            cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> and <paramref name="primary"/> is <see langword="true"/> then this will only
            return true if the symbol is <see cref="P:Microsoft.CodeAnalysis.Compilation.Assembly"/>.  If <paramref name="primary"/> is
            false, then it can return true if <paramref name="symbol"/> is <see cref="P:Microsoft.CodeAnalysis.Compilation.Assembly"/> or any
            of the symbols returned by <see cref="M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)"/> for
            any of the references of the <see cref="P:Microsoft.CodeAnalysis.Compilation.References"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker.WithCreateCreationPolicy(System.Boolean)">
            <summary>
            Updates the creation policy for this tracker.  Setting it to <see cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.CreationPolicy.Create"/>.
            </summary>
            <param name="forceRegeneration">Forces source generated documents to be created by dumping any existing <see
            cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker.GeneratorDriver"/> and rerunning generators from scratch for this tracker.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker.WithDoNotCreateCreationPolicy">
            <summary>
            Updates the creation policy for this tracker.  Setting it to <see cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.CreationPolicy.DoNotCreate"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker.GetSourceGeneratedDocumentStatesAsync(Microsoft.CodeAnalysis.SolutionCompilationState,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the source generator files generated by this <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker"/>. <paramref
            name="withFrozenSourceGeneratedDocuments"/>Controls whether frozen source generated documents are included
            in the result.  If <see langword="false"/> this will call all the way through to the most underlying <see
            cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.RegularCompilationTracker"/> to get its generated documents.  If this is <see langword="true"/> then
            this will be those same generated documents, along with all the generated documents from all wrapping <see
            cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocumentsCompilationTracker"/>'s frozen documents overlaid on top.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.OriginatingProjectInfo">
            <summary>
            Information maintained for unrooted symbols. 
            </summary>
            <param name="ProjectId">
            The project the symbol originated from, i.e. the symbol is defined in the project or its metadata reference.
            </param>
            <param name="Compilation">
            The Compilation that produced the symbol.
            </param>
            <param name="ReferencedThrough">
            If the symbol is defined in a metadata reference of <paramref name="ProjectId"/>, information about the
            reference.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.OriginatingProjectInfo.#ctor(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Compilation,System.Nullable{Microsoft.CodeAnalysis.SolutionCompilationState.MetadataReferenceInfo})">
            <summary>
            Information maintained for unrooted symbols. 
            </summary>
            <param name="ProjectId">
            The project the symbol originated from, i.e. the symbol is defined in the project or its metadata reference.
            </param>
            <param name="Compilation">
            The Compilation that produced the symbol.
            </param>
            <param name="ReferencedThrough">
            If the symbol is defined in a metadata reference of <paramref name="ProjectId"/>, information about the
            reference.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.OriginatingProjectInfo.ProjectId">
            <summary>
            The project the symbol originated from, i.e. the symbol is defined in the project or its metadata reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.OriginatingProjectInfo.Compilation">
            <summary>
            The Compilation that produced the symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.OriginatingProjectInfo.ReferencedThrough">
            <summary>
            If the symbol is defined in a metadata reference of <paramref name="ProjectId"/>, information about the
            reference.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.RootedSymbolSet">
            <summary>
            A helper type for mapping <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> back to an originating <see cref="T:Microsoft.CodeAnalysis.Project"/>/<see
            cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.RootedSymbolSet.Compilation"/>.
            </summary>
            <remarks>
            In IDE scenarios we have the need to map from an <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> to the <see cref="T:Microsoft.CodeAnalysis.Project"/> that
            contained a <see cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.RootedSymbolSet.Compilation"/> that could have produced that symbol.  This is especially needed with OOP
            scenarios where we have to communicate to OOP from VS (And vice versa) what symbol we are referring to. To do
            this, we pass along a project where this symbol could be found, and enough information (a <see
            cref="T:Microsoft.CodeAnalysis.SymbolKey"/>) to resolve that symbol back in that that <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.RootedSymbolSet.SecondaryReferencedSymbols">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>s or <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/>s produced through <see
            cref="M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)"/> for all the references exposed by <see
            cref="P:Microsoft.CodeAnalysis.Compilation.References"/>.  Sorted by the hash code produced by <see
            cref="M:Roslyn.Utilities.ReferenceEqualityComparer.GetHashCode(System.Object)"/> so that it can be binary searched efficiently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache">
            <summary>
            Caches the skeleton references produced for a given project/compilation under the varying <see
            cref="T:Microsoft.CodeAnalysis.MetadataReferenceProperties"/> it might be referenced by.  Skeletons are used in the compilation tracker
            to allow cross-language project references with live semantic updating between VB/C# and vice versa.
            Specifically, in a cross language case we will build a skeleton ref for the referenced project and have the
            referrer use that to understand its semantics.
            <para>
            This approach works, but has the caveat that live cross-language semantics are only possible when the skeleton
            assembly can be built.  This should always be the case for correct code, but it may not be the case for code
            with errors depending on if the respective language compiler is resilient to those errors or not. In that case
            though where the skeleton cannot be built, this type provides mechanisms to fallback to the last successfully
            built skeleton so that a somewhat reasonable experience can be maintained.  If we failed to do this and instead
            returned nothing, a user would find that practically all semantic experiences that depended on that particular
            project would fail or be seriously degraded (e.g. diagnostics).  To that end, it's better to limp along with
            stale date, then barrel on ahead with no data.
            </para>
            <para>
            The implementation works by keeping metadata references around associated with a specific <see
            cref="T:Microsoft.CodeAnalysis.VersionStamp"/> for a project. As long as the <see cref="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)"/> for
            that project is the same, then all the references of it can be reused.  When an <see
            cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker"/> forks itself, it will also <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache.Clone"/> this, allowing previously computed
            references to be used by later forks. However, this means that later forks (esp. ones that fail to produce a
            skeleton, or which produce a skeleton for different semantics) will not leak backward to a prior <see
            cref="T:Microsoft.CodeAnalysis.ProjectState"/>, causing it to see a view of the world inapplicable to its current snapshot.  A downside
            of this is that if a fork happens to a compilation tracker *prior* to the skeleton for it being computed, then
            when the skeleton is actually produced it won't be shared forward.  In practice the hope is that this is rare,
            and that eventually the compilation trackers will have computed the skeleton and will be able to pass it forward
            from that point onwards.
            </para>
            <para>
            The cached data we compute is associated with a particular compilation-tracker.  Because of this, once we
            compute the skeleton information for that tracker, we hold onto it for as long as the tracker is itself alive.
            The presumption here is that once created, it will likely be needed in the future as well as there will still be
            downstream projects of different languages that reference this.  The only time this won't hold true is if there
            was a cross language p2p ref, but then it gets removed from the solution.  However, this sort of change should
            be rare in a solution, so it's unlikely to happen much, and the only negative is holding onto a little bit more
            memory.
            </para>
            </summary>
            <remarks>
            Note: this is a mutable struct that updates itself in place atomically.  As such, it should never be copied by
            consumers (hence the <see cref="T:Roslyn.Utilities.NonCopyableAttribute"/> restriction).  Consumers wanting to make a copy should
            only do so by calling <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache.Clone"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache.s_metadataOnlyEmitOptions">
            <summary>
            We don't want to include private members for several reasons.  First, it provides more opportunity to fail
            to generate the skeleton reference.  Second, it adds much more perf cost having to bind and emit all those
            members. Finally, those members serve no purpose as within the IDE we don't even load privates from metadata
            in our compilations.  So this information doesn't even end up supporting any scenarios.  Note: Due to not
            loading privates, it means that if a cross language call references something private, you'll get an error,
            but go-to-def won't work.  That not ideal, but not the end of the world.  And the cost needed to support
            that working is simply too high (both on emit and on load) to be worthwhile.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache.s_stateGate">
            <summary>
            Lock around <see cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache._version"/> and <see cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache._skeletonReferenceSet"/> to ensure they are updated/read
            in an atomic fashion.  Static to keep this only as a single allocation.  As this is only for reading/writing
            very small pieces of data, this is fine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache.s_compilationToSkeletonSet">
            <summary>
            Static conditional mapping from a compilation to the skeleton set produced for it.  This is valuable for a
            couple of reasons. First, a compilation tracker may fork, but produce the same compilation.  As such, we
            want to get the same skeleton set for it.  Second, consider the following scenario:
            <list type="number">
            <item>Project A is referenced by projects B and C (both have a different language than A).</item>
            <item>Producing the compilation for 'B' produces the compilation for 'A' which produces the skeleton that 'B' references.</item>
            <item>B's compilation is released and then GC'ed.</item> 
            <item>Producing the compilation for 'C' needs the skeleton from 'A'</item>
            </list>
            At this point we would not want to re-emit the assembly metadata for A's compilation.  We already did that
            for 'B', and it can be enormously expensive to do so again.  So as long as A's compilation lives, we really
            want to keep it's skeleton cache around.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache._version">
            <summary>
            The <see cref="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)"/> version of the project that the <see
            cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache._skeletonReferenceSet"/> corresponds to.  Initially set to <see cref="P:Microsoft.CodeAnalysis.VersionStamp.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache._skeletonReferenceSet">
            <summary>
            Mapping from metadata-reference-properties to the actual metadata reference for them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache.Clone">
            <summary>
            Produces a copy of the <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceCache"/>, allowing forks of <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> to
            reuse <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/>s when their dependent semantic version matches ours.  In the case
            where the version is different, then the clone will attempt to make a new skeleton reference for that
            version.  If it succeeds, it will use that.  If it fails however, it can still use our skeletons.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceSet">
            <param name="metadata">
            The actual assembly metadata produced from another compilation.
            </param>
            <param name="documentationProvider">
            The documentation provider used to lookup xml docs for any metadata reference we pass out.  See
            docs on <see cref="T:Microsoft.CodeAnalysis.DeferredDocumentationProvider"/> for why this is safe to hold onto despite it
            rooting a compilation internally.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceSet.#ctor(Microsoft.CodeAnalysis.AssemblyMetadata,Microsoft.CodeAnalysis.Host.ITemporaryStorageStreamHandle,System.String,Microsoft.CodeAnalysis.DeferredDocumentationProvider)">
            <param name="metadata">
            The actual assembly metadata produced from another compilation.
            </param>
            <param name="documentationProvider">
            The documentation provider used to lookup xml docs for any metadata reference we pass out.  See
            docs on <see cref="T:Microsoft.CodeAnalysis.DeferredDocumentationProvider"/> for why this is safe to hold onto despite it
            rooting a compilation internally.
            </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.SkeletonReferenceSet._referenceMap">
            <summary>
            Lock this object while reading/writing from it.  Used so we can return the same reference for the same
            properties.  While this is isn't strictly necessary (as the important thing to keep the same is the
            AssemblyMetadata), this allows higher layers to see that reference instances are the same which allow
            reusing the same higher level objects (for example, the set of references a compilation has).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction">
            <summary>
            Represents a change that needs to be made to a <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, <see cref="T:Microsoft.CodeAnalysis.GeneratorDriver"/>, or both
            in response to some user edit.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.OldProjectState">
            <summary>
            The original state of the project prior to the user edit.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.NewProjectState">
            <summary>
            The state of the project after the user edit was made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.CanUpdateCompilationWithStaleGeneratedTreesIfGeneratorsGiveSameOutput">
            <summary>
            Whether or not <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.TransformCompilationAsync(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)" /> can be called on Compilations that may contain
            generated documents.
            </summary>
            <remarks>
            Most translation actions add or remove a single syntax tree which means we can do the "same" change
            to a compilation that contains the generated files and one that doesn't; however some translation actions
            (like <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.ReplaceAllSyntaxTreesAction"/>) will unilaterally remove all trees, and would have unexpected
            side effects. This opts those out of operating on ones with generated documents where there would be side effects.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.TryMergeWithPrior(Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction)">
            <summary>
            When changes are made to a solution, we make a list of translation actions. If multiple similar changes happen in rapid
            succession, we may be able to merge them without holding onto intermediate state.
            </summary>
            <param name="priorAction">The action prior to this one. May be a different type.</param>
            <returns>A non-null <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction" /> if we could create a merged one, null otherwise.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.TouchDocumentsAction.CanUpdateCompilationWithStaleGeneratedTreesIfGeneratorsGiveSameOutput">
            <summary>
            Replacing a single tree doesn't impact the generated trees in a compilation, so we can use this against
            compilations that have generated trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.TouchAnalyzerConfigDocumentsAction.TransformCompilationAsync(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Updating editorconfig document updates <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.SyntaxTreeOptionsProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.TranslationAction.AddDocumentsAction.AddDocumentsBatchSize">
            <summary>
            Amount to break batches of documents into.  That allows us to process things in parallel, without also
            creating too many individual actions that then need to be processed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocumentsCompilationTracker">
            <summary>
            An implementation of <see cref="T:Microsoft.CodeAnalysis.SolutionCompilationState.ICompilationTracker"/> that takes a compilation from another compilation tracker
            and updates it to return a generated document with a specific content, regardless of what the generator actually
            produces. In other words, it says "take the compilation this other thing produced, and pretend the generator
            gave this content, even if it wouldn't."  This is used by <see
            cref="M:Microsoft.CodeAnalysis.Solution.WithFrozenSourceGeneratedDocuments(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity,System.DateTime,Microsoft.CodeAnalysis.Text.SourceText}})"/> to ensure that a particular solution snapshot contains a
            pre-existing generated document from a prior run that the user is interacting with in the host.  The current
            snapshot might not produce the same content from before (or may not even produce that document anymore).  But we
            want to still let the user work with that doc effectively up until the point that new generated documents are
            produced and replace it in the host view.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocumentsCompilationTracker._compilationWithReplacements">
            <summary>
            The lazily-produced compilation that has the generated document updated. This is initialized by call to
            <see cref="M:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocumentsCompilationTracker.GetCompilationAsync(Microsoft.CodeAnalysis.SolutionCompilationState,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.WithFrozenSourceGeneratedDocumentsCompilationTracker._skeletonReferenceCache">
            <summary>
            Intentionally not readonly as this is a mutable struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState._lazyChecksums">
            <summary>
            Checksum representing the full checksum tree for this solution compilation state.  Includes the checksum for
            <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.SolutionState"/>, as well as the checksums for <see cref="P:Microsoft.CodeAnalysis.SolutionCompilationState.FrozenSourceGeneratedDocumentStates"/>
            if present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState._lazyProjectChecksums">
            <summary>
            Mapping from project-id to the checksums needed to synchronize it over to an OOP host.  Lock this specific
            field before reading/writing to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetStateChecksumsAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>Gets the checksum for only the requested project (and any project it depends on)</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetChecksumAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>Gets the checksum for only the requested project (and any project it depends on)</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.s_projectStateToSourceGeneratorsMap">
            <summary>
            Cached mapping from language (only C#/VB since those are the only languages that support analyzers) to the lists
            of analyzer references (see <see cref="P:Microsoft.CodeAnalysis.ProjectState.AnalyzerReferences"/>) to all the <see
            cref="T:Microsoft.CodeAnalysis.ISourceGenerator"/>s produced by those references.  This should only be created and cached on the OOP side
            of things so that we don't cause source generators to be loaded (and fixed) within VS (which is .net framework
            only).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCompilationState.s_languageToAnalyzerReferenceMap">
            <summary>
            Cached information about if a project has source generators or not.  Note: this is distinct from <see
            cref="F:Microsoft.CodeAnalysis.SolutionCompilationState.s_projectStateToSourceGeneratorsMap"/> as we want to be able to compute it by calling over to our OOP
            process (if present) and having it make the determination, without the host necessarily loading generators
            itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetSourceGenerators(Microsoft.CodeAnalysis.ProjectState)">
            <summary>
            This method should only be called in a .net core host like our out of process server.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCompilationState.GetAnalyzerReference(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ISourceGenerator)">
            <summary>
            This method should only be called in a .net core host like our out of process server.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionId">
            <summary>
            An identifier that can be used to refer to the same Solution across versions. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionId.Id">
            <summary>
            The unique id of the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionId.CreateNewId(System.String)">
            <summary>
            Create a new Solution Id
            </summary>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionInfo">
            <summary>
            A class that represents all the arguments necessary to create a new solution instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Id">
            <summary>
            The unique Id of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Version">
            <summary>
            The version of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.FilePath">
            <summary>
            The path to the solution file, or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Projects">
            <summary>
            A list of projects initially associated with the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.AnalyzerReferences">
            <summary>
            The analyzers initially associated with this solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.FallbackAnalyzerOptions">
            <summary>
            Per-language analyzer config options that are used as a fallback if the option is not present in <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigOptionsResult"/> produced by the compiler.
            Implements a top-level (but not global) virtual editorconfig file that's in scope for all source files of the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionInfo.Create(Microsoft.CodeAnalysis.SolutionId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Create a new instance of a SolutionInfo.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionInfo.Create(Microsoft.CodeAnalysis.SolutionId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new instance of a SolutionInfo.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionInfo.Create(Microsoft.CodeAnalysis.SolutionId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})">
            <summary>
            Create a new instance of a SolutionInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes">
            <summary>
            type that contains information regarding this solution itself but
            no tree information such as project info
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.#ctor(Microsoft.CodeAnalysis.SolutionId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.Guid)">
            <summary>
            type that contains information regarding this solution itself but
            no tree information such as project info
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.Id">
            <summary>
            The unique Id of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.Version">
            <summary>
            The version of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.FilePath">
            <summary>
            The path to the solution file, or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.TelemetryId">
            <summary>
            The id report during telemetry events.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState">
             <summary>
             Represents a set of projects and their source code documents.
            
             this is a green node of Solution like ProjectState/DocumentState are for
             Project and Document.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CachingFilePathComparer">
            <summary>
            String comparer for file paths that caches the last result of the comparison to avoid expensive rehashing of the
            same string over and over again.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState.CachingFilePathComparer.s_comparer">
            <summary>
            Note: this insensitive comparer is busted on many systems.  But we do things this way for compat with the logic
            we've had on windows since forever.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState.CachingFilePathComparer._lock">
            <summary>
            Lock to protect the the last string and hash code we computed.  `enableThreadOwnerTracking: false` as we
            don't need that tracking, and it substantially speeds up the spin lock (removing 0.7% cpu from solution load
            scenario).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CachingFilePathComparer.AllCharsInUInt32AreAscii(System.UInt32)">
            <summary>
            Returns true iff the UInt32 represents two ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.FallbackAnalyzerOptions">
            <summary>
            Fallback analyzer config options by language. The set of languages does not need to match the set of langauges of projects included in the surrent solution snapshot.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.ProjectCountByLanguage">
            <summary>
            Number of projects in the solution of the given language.  The value is guaranteed to always be greater than zero.
            If the project count does ever hit zero then there simply is no key/value pair for that language in this map.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.Id">
            <summary>
            The Id of the solution. Multiple solution instances may share the same Id.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.FilePath">
            <summary>
            The path to the solution file or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.Version">
            <summary>
            The solution version. This equates to the solution file's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.ProjectIds">
            <summary>
            A list of all the ids for all the projects contained by the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithNewWorkspace(System.String,System.Int32,Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            Updates the solution with specified workspace kind, workspace version and services.
            This implicitly also changes the value of <see cref="P:Microsoft.CodeAnalysis.Solution.Workspace"/> for this solution,
            since that is extracted from <see cref="T:Microsoft.CodeAnalysis.Host.SolutionServices"/> for backwards compatibility.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetLatestProjectVersion">
            <summary>
            The version of the most recently modified project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            True if the solution contains a project with the specified project ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the additional document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the analyzer config document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Create a new solution instance that includes projects with the specified project information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveProjects(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Create a new solution instance without the projects specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the new
            assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOutputRefFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectCompilationOutputInfo(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOutputInfo@)">
            <summary>
            Creates a new solution instance with the project specified updated to have the compiler output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectDefaultNamespace(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the default namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectChecksumAlgorithm(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)">
            <summary>
            Creates a new solution instance with the project specified updated to have the name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the project file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithHasAllInformation(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified hasAllInformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithRunAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified runAnalyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithHasSdkCodeStyleAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified hasSdkCodeStyleAnalyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer
            include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to contain
            the specified list of project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectDocumentsOrder(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableList{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance with the project documents in the order by the specified document ids.
            The specified document ids must be the same as what is already in the project; no adding or removing is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyCollection{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithFallbackAnalyzerOptions(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})">
            <summary>
            Creates a new solution instance with updated analyzer fallback options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentAttributes``1(Microsoft.CodeAnalysis.DocumentId,``0,System.Func{Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes,``0,Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes})">
            <summary>
            Creates a new solution instance with an attribute of the document updated, if its value has changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new solution instance with the document specified updated to have the source
            code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.UpdateAdditionalDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.UpdateAnalyzerConfigDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ForkProject(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectDependencyGraph)">
            <summary>
            Creates a new snapshot with an updated project and an action that will produce a new
            compilation matching the new project out of an old compilation. All dependent projects
            are fixed-up if the change to the new project affects its public metadata, and old
            dependent compilations are forgotten.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetDocumentIdsWithFilePath(System.String)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s in this <see cref="T:Microsoft.CodeAnalysis.Solution"/> with a
            <see cref="P:Microsoft.CodeAnalysis.TextDocument.FilePath"/> that matches the given file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetProjectDependencyGraph">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> that details the dependencies between projects for this solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState._lazyChecksums">
            <summary>
            Checksum representing the full checksum tree for this solution compilation state.  Includes the checksum for
            <see cref="T:Microsoft.CodeAnalysis.SolutionState"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState._lazyProjectChecksums">
            <summary>
            Mapping from project-id to the checksums needed to synchronize it (and the projects it depends on) over 
            to an OOP host.  Lock this specific field before reading/writing to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetStateChecksumsAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>Gets the checksum for only the requested project (and any project it depends on)</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetChecksumAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>Gets the checksum for only the requested project (and any project it depends on)</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ComputeChecksumsAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <param name="projectConeId">Cone of projects to compute a checksum for.  Pass in <see langword="null"/> to get a
            checksum for the entire solution</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratedDocument">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Document"/> that was generated by an <see cref="T:Microsoft.CodeAnalysis.ISourceGenerator" />.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity">
            <summary>
            A small struct that holds the values that define the identity of a source generated document, and don't change
            as new generations happen. This is mostly for convenience as we are reguarly working with this combination of values.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SourceGeneratedDocumentState._lazyContentHash">
            <summary>
            Backing store for <see cref="M:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.GetOriginalSourceTextContentHash"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.SourceText">
            <summary>
            It's reasonable to capture 'text' here and keep it alive.  We're already holding onto the generated text
            strongly in the ConstantTextAndVersionSource we're passing to our base type. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.GetOriginalSourceTextContentHash">
            <summary>
            Checksum of <see cref="P:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.SourceText"/> when it was <em>originally</em> created.  This is subtly, but importantly
            different from the checksum acquired from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.GetChecksum"/>.  Specifically, the original
            source text may have been created from a <see cref="T:System.IO.Stream"/> in a lossy fashion (for example,
            removing BOM marks and the like) on the OOP side. As such, its checksum might not be reconstructible from the
            actual text and hash algorithm that were used to create the SourceText on the host side.  To ensure both the
            host and OOP are in agreement about the true content checksum, we store this separately.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratedDocumentState.SourceGeneratedTextDocumentServiceProvider">
            <summary>
            This is modeled after <see cref="T:Microsoft.CodeAnalysis.DefaultTextDocumentServiceProvider"/>, but sets
            <see cref="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.CanApplyChange"/> to <see langword="false"/> for source generated
            documents.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion">
            <summary>
            Represents the version of source generator execution that a project is at. Source generator results are kept around
            as long as this version stays the same and we are in <see cref="F:Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference.Balanced"/>
            mode. This has no effect when in <see cref="F:Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference.Automatic"/> mode (as we always rerun
            generators on any change). This should effectively be used as a monotonically increasing value.
            </summary>
            <param name="MajorVersion">Controls the major version of source generation execution.  When this changes the
            generator driver should be dropped and all generation should be rerun.</param>
            <param name="MinorVersion">Controls the minor version of source generation execution.  When this changes the
            generator driver can be reused and should incrementally determine what the new generated documents should be.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion.#ctor(System.Int32,System.Int32)">
            <summary>
            Represents the version of source generator execution that a project is at. Source generator results are kept around
            as long as this version stays the same and we are in <see cref="F:Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference.Balanced"/>
            mode. This has no effect when in <see cref="F:Microsoft.CodeAnalysis.Host.SourceGeneratorExecutionPreference.Automatic"/> mode (as we always rerun
            generators on any change). This should effectively be used as a monotonically increasing value.
            </summary>
            <param name="MajorVersion">Controls the major version of source generation execution.  When this changes the
            generator driver should be dropped and all generation should be rerun.</param>
            <param name="MinorVersion">Controls the minor version of source generation execution.  When this changes the
            generator driver can be reused and should incrementally determine what the new generated documents should be.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion.MajorVersion">
            <summary>Controls the major version of source generation execution.  When this changes the
            generator driver should be dropped and all generation should be rerun.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion.MinorVersion">
            <summary>Controls the minor version of source generation execution.  When this changes the
            generator driver can be reused and should incrementally determine what the new generated documents should be.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersionMap">
            <summary>
            Helper construct to allow a mapping from <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>s to <see cref="T:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion"/>.
            Limited to just the surface area the workspace needs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersionMap.#ctor(System.Collections.Immutable.ImmutableSortedDictionary{Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion})">
            <summary>
            Helper construct to allow a mapping from <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>s to <see cref="T:Microsoft.CodeAnalysis.SourceGeneratorExecutionVersion"/>.
            Limited to just the surface area the workspace needs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SourceGeneratorIdentity">
            <remarks>
            Assembly path is used as a part of a generator identity to deal with the case that the user accidentally installed
            the same generator twice from two different paths, or actually has two different generators that just happened to
            use the same name. In the wild we've seen cases where a user has a broken project or build that results in the same
            generator being added twice; we aren't going to try to deduplicate those anywhere since currently the compiler
            does't do any deduplication either: you'll simply get duplicate outputs which might collide and cause compile
            errors. If https://github.com/dotnet/roslyn/issues/56619 is addressed, we can potentially match the compiler
            behavior by taking a different approach here.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SourceGeneratorIdentity.#ctor(System.String,System.String,System.Version,System.String)">
            <remarks>
            Assembly path is used as a part of a generator identity to deal with the case that the user accidentally installed
            the same generator twice from two different paths, or actually has two different generators that just happened to
            use the same name. In the wild we've seen cases where a user has a broken project or build that results in the same
            generator being added twice; we aren't going to try to deduplicate those anywhere since currently the compiler
            does't do any deduplication either: you'll simply get duplicate outputs which might collide and cause compile
            errors. If https://github.com/dotnet/roslyn/issues/56619 is addressed, we can potentially match the compiler
            behavior by taking a different approach here.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextAndVersion">
            <summary>
            A class that represents both a source text and its version stamp.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.Text">
            <summary>
            The source text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.Version">
            <summary>
            The version of the source text
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.FilePath">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.LoadDiagnostic">
            <summary>
            If an error occurred while loading the text the corresponding diagnostic, otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextAndVersion.Create(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.VersionStamp,System.String)">
            <summary>
            Create a new <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> instance.
            </summary>
            <param name="text">The text</param>
            <param name="version">The version</param>
            <param name="filePath">Obsolete.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextAndVersion.Create(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.VersionStamp,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Create a new <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> instance.
            </summary>
            <param name="text">The text</param>
            <param name="version">The version</param>
            <param name="loadDiagnostic">Diagnostic describing failure to load the source text.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextDifferenceTypes">
            <summary>
            A bitwise combination of the enumeration values to use when computing differences with 
            <see cref="T:Microsoft.CodeAnalysis.IDocumentTextDifferencingService" />. 
            </summary>
            <remarks>
            Since computing differences can be slow with large data sets, you should not use the Character type
            unless the given text is relatively small.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDifferenceTypes.Line">
            <summary>
            Compute the line difference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDifferenceTypes.Word">
            <summary>
            Compute the word difference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDifferenceTypes.Character">
            <summary>
            Compute the character difference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Project">
            <summary>
            The project this document belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Id">
            <summary>
            The document's identifier. Many document instances may share the same ID, but only one
            document in a solution may have that ID.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.FilePath">
            <summary>
            The path to the document file or null if there is no document file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Folders">
            <summary>
            The sequence of logical folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.DocumentServiceProvider">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> associated with this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Get the current text for the document if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.TryGetTextVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Gets the version of the document's text if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the current text for the document asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextSynchronously(System.Threading.CancellationToken)">
            <summary>
            Fetches the current text for the document synchronously.
            </summary>
            <remarks>This is internal for the same reason <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeSynchronously(System.Threading.CancellationToken)"/> is internal:
            we have specialized cases where we need it, but we worry that making it public will do more harm than good.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the document's text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextVersionSynchronously(System.Threading.CancellationToken)">
            <summary>
            Fetches the current version for the document synchronously.
            </summary>
            <remarks>This is internal for the same reason <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeSynchronously(System.Threading.CancellationToken)"/> is internal:
            we have specialized cases where we need it, but we worry that making it public will do more harm than good.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTopLevelChangeTextVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the document's top level signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.HasInfoChanged(Microsoft.CodeAnalysis.TextDocument)">
            <summary>
            True if the info of the document change (name, folders, file path; not the content).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.HasTextChanged(Microsoft.CodeAnalysis.TextDocument,System.Boolean)">
            <summary>
            Only checks if the source of the text has changed, no content check is done.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextDocumentKind">
            <summary>
            Indicates kind of a <see cref="T:Microsoft.CodeAnalysis.TextDocument"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentKind.Document">
            <summary>
            Indicates a regular source <see cref="T:Microsoft.CodeAnalysis.Document"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentKind.AdditionalDocument">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.AdditionalDocument"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentKind.AnalyzerConfigDocument">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocumentState.HasTextChanged(Microsoft.CodeAnalysis.TextDocumentState,System.Boolean)">
            <summary>
            Only checks if the source of the text has changed, no content check is done.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextDocumentStates`1">
            <summary>
            Holds on a <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> to <see cref="T:Microsoft.CodeAnalysis.TextDocumentState"/> map and an ordering.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocumentStates`1.Ids">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s in the order in which they were added to the project (the compilation order).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocumentStates`1.States">
            <summary>
            States ordered by <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>.
            </summary>
            <remarks>
            The entries in the map are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/>, which yields locally deterministic order but not the order that
            matches the order in which documents were added. Therefore this ordering can't be used when creating compilations and it can't be 
            used when persisting document lists that do not preserve the GUIDs.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocumentStates`1.GetStatesInCompilationOrder">
            <summary>
            Get states ordered in compilation order.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocumentStates`1.GetChangedStateIds(Microsoft.CodeAnalysis.TextDocumentStates{`0},System.Boolean,System.Boolean)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of documents whose state changed when compared to older states.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocumentStates`1.GetAddedStateIds(Microsoft.CodeAnalysis.TextDocumentStates{`0})">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of added documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocumentStates`1.GetRemovedStateIds(Microsoft.CodeAnalysis.TextDocumentStates{`0})">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s of removed documents.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextLoader">
            <summary>
            A class that represents access to a source text and its version from a storage location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextLoader.AlwaysHoldStrongly">
            <summary>
            <see langword="true"/> if the document that holds onto this loader should do so with a strong reference, versus
            a reference that will take the contents of this loader and store them in a recoverable form (e.g. a memory
            mapped file within the <em>same</em> process).  This should be used when the underlying data is already stored
            in a recoverable form somewhere else and it would be wasteful to store another copy.  For example, a document
            that is backed by memory-mapped contents in <em>another</em> process does not need to dump it's content to
            another memory-mapped file in the process it lives in.  It can always recover the text from the original
            process.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextLoader.CanReloadText">
            <summary>
            True if <see cref="M:Microsoft.CodeAnalysis.TextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)"/> reloads <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from its original binary representation (e.g. file on disk).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document.
            </summary>
            <param name="options">
            Implementations of this method should use <see cref="P:Microsoft.CodeAnalysis.LoadTextOptions.ChecksumAlgorithm"/> when creating <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from an original binary representation and
            ignore it otherwise.
            Callers of this method should pass <see cref="T:Microsoft.CodeAnalysis.LoadTextOptions"/> specifying the desired properties of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>. The implementation may return a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>
            that does not satisfy the given requirements. For example, legacy types that do not override this method would ignore all <paramref name="options"/>.
            </param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.IO.IOException" />
            <exception cref="T:System.IO.InvalidDataException"/>
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document.
            </summary>
            <param name="workspace">Obsolete. Null.</param>
            <param name="documentId">Obsolete. Null.</param>
            <exception cref="T:System.IO.IOException" />
            <exception cref="T:System.IO.InvalidDataException"/>
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.LoadTextAndVersionSynchronously(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException" />
            <exception cref="T:System.IO.InvalidDataException"/>
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.From(Microsoft.CodeAnalysis.TextAndVersion)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.TextLoader"/> from an already existing source text and version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.From(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.VersionStamp,System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.TextLoader"/> from a <see cref="T:Microsoft.CodeAnalysis.Text.SourceTextContainer"/> and version. 
            
            The text obtained from the loader will be the current text of the container at the time
            the loader is accessed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeAndVersion">
            <summary>
            A class that represents both a tree and its top level signature version
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TreeAndVersion.#ctor(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            A class that represents both a tree and its top level signature version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TreeAndVersion.Tree">
            <summary>
            The syntax tree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TreeAndVersion.Version">
            <summary>
            The version of the top level signature of the tree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITextAndVersionSource.CanReloadText">
            <summary>
            True if <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> can be reloaded.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ITextAndVersionSource.TextLoader">
            <summary>
            Retrieves the underlying <see cref="P:Microsoft.CodeAnalysis.ITextAndVersionSource.TextLoader"/> if that's what this <see cref="T:Microsoft.CodeAnalysis.ITextAndVersionSource"/> was
            created from and still has access to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ITextAndVersionSource.GetVersionAsync(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)">
            <summary>
            Retrieves just the version information from this instance.  Cheaper than <see cref="M:Microsoft.CodeAnalysis.ITextAndVersionSource.GetValueAsync(Microsoft.CodeAnalysis.LoadTextOptions,System.Threading.CancellationToken)"/> when only
            the version is needed, and avoiding loading the text is desirable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ITreeAndVersionSource">
            <summary>
            Similar to <see cref="T:Microsoft.CodeAnalysis.ITextAndVersionSource"/>, but for trees.  Allows hiding (or introspecting) the details of how
            a tree is created for a particular document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions._instance">
            <summary>
            Strong reference to the loaded text and version.  Only held onto once computed if <see cref="F:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions.Source"/>.<see
            cref="F:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.CacheResult"/> is <see langword="true"/>.  Once held onto, this will be returned from all calls to
            <see cref="M:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions.TryGetValue(Microsoft.CodeAnalysis.TextAndVersion@)"/>, <see cref="M:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions.GetValue(System.Threading.CancellationToken)"/> or <see cref="M:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions.GetValueAsync(System.Threading.CancellationToken)"/>.  Once non-null will always
            remain non-null.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions._weakInstance">
            <summary>
            Weak reference to the loaded text and version that we create whenever the value is computed.  We will
            attempt to return from this if still alive when clients call back into this.  If neither this, nor <see
            cref="F:Microsoft.CodeAnalysis.LoadableTextAndVersionSource.LazyValueWithOptions._instance"/> are available, the value will be reloaded.  Once non-null, this will always be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RecoverableTextAndVersion">
            <summary>
            A recoverable TextAndVersion source that saves its text to temporary storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.#ctor(Microsoft.CodeAnalysis.ITextAndVersionSource,Microsoft.CodeAnalysis.Host.SolutionServices)">
            <summary>
            A recoverable TextAndVersion source that saves its text to temporary storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.TryGetInitialSourceOrRecoverableText(Microsoft.CodeAnalysis.ITextAndVersionSource@,Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText@)">
            <returns>
            True if the <paramref name="source"/> is available, false if <paramref name="text"/> is returned.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.RecoverableTextAndVersion.TextLoader">
            <summary>
            Attempt to return the original loader if we still have it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText">
            <summary>
            This class holds onto a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> value weakly, but can save its value and recover it on demand
            if needed.  The value is initially strongly held, until the first time that <see cref="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.GetValue(System.Threading.CancellationToken)"/> or <see
            cref="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.GetValueAsync(System.Threading.CancellationToken)"/> is called.  At that point, it will be dumped to secondary storage, and retrieved and
            weakly held from that point on in the future.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText._lazyGate">
            <summary>
            Lazily created. Access via the <see cref="P:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.Gate"/> property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText._saved">
            <summary>
            Whether or not we've saved our value to secondary storage.  Used so we only do that once.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText._initialValue">
            <summary>
            Initial strong reference to the SourceText this is initialized with.  Will be used to respond to the first
            request to get the value, at which point it will be dumped into secondary storage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText._weakReference">
            <summary>
            Weak reference to the value last returned from this value source.  Will thus return the same value as long
            as something external is holding onto it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.TryGetWeakValue(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Attempts to get the value, but only through the weak reference.  This will only succeed *after* the value
            has been retrieved at least once, and has thus then been save to secondary storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.TryGetStrongOrWeakValue(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Attempts to get the value, either through our strong or weak reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RecoverableTextAndVersion.RecoverableText.UpdateWeakReferenceAndEnqueueSaveTask_NoLock(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Kicks off the work to save this instance to secondary storage at some point in the future.  Once that save
            occurs successfully, we will drop our cached data and return values from that storage instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SimpleTreeAndVersionSource">
            <summary>
            Simple implementation of <see cref="T:Microsoft.CodeAnalysis.ITreeAndVersionSource"/> backed by an opaque <see
            cref="T:Roslyn.Utilities.AsyncLazy`1"/>."/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.VersionStamp">
            <summary>
            VersionStamp should be only used to compare versions returned by same API.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp.s_globalVersion">
            <summary>
            global counter to avoid collision within same session. 
            it starts with a big initial number just for a clarity in debugging
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp._utcLastModified">
            <summary>
            time stamp
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp._localIncrement">
            <summary>
            indicate whether there was a collision on same item
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp._globalIncrement">
            <summary>
            unique version in same session
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.Create">
            <summary>
            Creates a new instance of a VersionStamp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.Create(System.DateTime)">
            <summary>
            Creates a new instance of a version stamp based on the specified DateTime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.GetNewerVersion(Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            compare two different versions and return either one of the versions if there is no collision, otherwise, create a new version
            that can be used later to compare versions between different items
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.GetNewerVersion">
            <summary>
            Gets a new VersionStamp that is guaranteed to be newer than its base one
            this should only be used for same item to move it to newer version
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.ToString">
            <summary>
            Returns the serialized text form of the VersionStamp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.TestAccessor.IsNewerThan(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            True if this VersionStamp is newer than the specified one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetRelatedDocumentsWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the documents from the corresponding workspace's current solution that are associated with the source text's container,
            updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContextWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Document"/> from the corresponding workspace's current solution that is associated with the source text's container 
            in its current project context, updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenTextDocumentInCurrentContextWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.TextDocument"/> from the corresponding workspace's current solution that is associated with the source text's container 
            in its current project context, updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetRelatedDocuments(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the documents from the corresponding workspace's current solution that are associated with the text container. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the document from the corresponding workspace's current solution that is associated with the text container 
            in its current project context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetDocumentWithFrozenPartialSemantics(Microsoft.CodeAnalysis.Text.SourceText,System.Threading.CancellationToken)">
            <summary>
            Tries to get the document corresponding to the text from the current partial solution 
            associated with the text's container. If the document does not contain the exact text a document 
            from a new solution containing the specified text is constructed. If no document is associated
            with the specified text's container, or the text's container isn't associated with a workspace,
            then the method returns false.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Text.SourceHashAlgorithms">
            <summary>
            Hash algorithms supported by the debugger used for source file checksums stored in the PDB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.SourceHashAlgorithms.OpenDocumentChecksumAlgorithm">
            <summary>
            Defines a source hash algorithm constant we can re-use when creating source texts for open documents.
            This ensures that both LSP and documents opened as a text buffer are created with the same checksum algorithm
            so that we can compare their contents using checksums later on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_utf8Encoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.CreateFallbackEncoding">
            <summary>
            Encoding to use when UTF-8 fails. We try to find the following, in order, if available:
                1. The default ANSI codepage
                2. CodePage 1252.
                3. Latin1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF-8 and, if that fails, it will
               try CodePage 1252. If CodePage 1252 is not available on the system, then it will try Latin1.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be Encoding.Default.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="canBeEmbedded">Indicates if the file can be embedded in the PDB.</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <param name="canBeEmbedded">Indicates if the text can be embedded in the PDB.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <exception cref="T:System.IO.IOException">Error reading from stream.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromStream(System.IO.Stream,System.ArraySegment{System.Byte}@)">
            <summary>
            Some streams are easily represented as bytes.
            </summary>
            <param name="data">The stream</param>
            <param name="bytes">The bytes, if available.</param>
            <returns>
            True if the stream's bytes could easily be read, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromFileStream(System.IO.FileStream,System.ArraySegment{System.Byte}@)">
            <summary>
            Read the contents of a FileStream into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="bytes">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspace">
            <summary>
            A workspace provides access to a active set of source code projects and documents and their
            associated syntax trees, compilations and semantic models. A workspace has a current solution
            that is an immutable snapshot of the projects and documents. This property may change over time
            as the workspace is updated either from live interactions in the environment or via call to the
            workspace's <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspace._latestSolution">
            <summary>
            Current solution.  Must be locked with <see cref="F:Microsoft.CodeAnalysis.Workspace._serializationLock"/> when writing to it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.IgnoreUnchangeableDocumentsWhenApplyingChanges">
            <summary>
            Determines whether changes made to unchangeable documents will be silently ignored or cause exceptions to be thrown
            when they are applied to workspace via <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution,System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress})"/>. 
            A document is unchangeable if <see cref="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.CanApplyChange"/> is false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.#ctor(Microsoft.CodeAnalysis.Host.HostServices,System.String)">
            <summary>
            Constructs a new workspace instance.
            </summary>
            <param name="host">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> this workspace uses</param>
            <param name="workspaceKind">A string that can be used to identify the kind of workspace. Usually this matches the name of the class.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Services">
            <summary>
            Services provider by the host for implementing workspace features.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.PartialSemanticsEnabled">
            <summary>
            Override this property if the workspace supports partial semantics for documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Kind">
            <summary>
            The kind of the workspace.
            This is generally <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.Host"/> if originating from the host environment, but may be
            any other name used for a specific kind of workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Create a new empty solution instance associated with this workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionInfo,Microsoft.CodeAnalysis.Options.SolutionOptionSet,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})">
            <summary>
            Create a new empty solution instance associated with this workspace, and with the given options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Create a new empty solution instance associated with this workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution">
             <summary>
             The current solution.
            
             The solution is an immutable model of the current set of projects and source documents.
             It provides access to source text, syntax trees and semantics.
            
             This property may change as the workspace reacts to changes in the environment or
             after <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> is called.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Sets the <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> of this workspace. This method does not raise a <see cref="E:Microsoft.CodeAnalysis.Workspace.WorkspaceChanged"/> event.
            </summary>
            <remarks>
            This method does not guarantee that linked files will have the same contents. Callers
            should enforce that policy before passing in the new solution.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolutionEx(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Sets the <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> of this workspace. This method does not raise a <see
            cref="E:Microsoft.CodeAnalysis.Workspace.WorkspaceChanged"/> event.  This method should be used <em>sparingly</em>.  As much as possible,
            derived types should use the SetCurrentSolution overloads that take a transformation.
            </summary>
            <remarks>
            This method does not guarantee that linked files will have the same contents. Callers
            should enforce that policy before passing in the new solution.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution(System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution},Microsoft.CodeAnalysis.WorkspaceChangeKind,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution(System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution},System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.ValueTuple{Microsoft.CodeAnalysis.WorkspaceChangeKind,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId}},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution(System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution},System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.ValueTuple{Microsoft.CodeAnalysis.WorkspaceChangeKind,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId}},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution})">
            <summary>
            Applies specified transformation to <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/>, updates <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> to
            the new value and raises a workspace change event of the specified kind.  All linked documents in the
            solution (which normally will have the same content values) will be updated to to have the same content
            *identity*.  In other words, they will point at the same <see cref="T:Microsoft.CodeAnalysis.ITextAndVersionSource"/> instances,
            allowing that memory to be shared.
            </summary>
            <param name="transformation">Solution transformation.</param>
            <param name="changeKind">The kind of workspace change event to raise. The id of the project updated by
            <paramref name="transformation"/> to be passed to the workspace change event.  And the id of the document
            updated by <paramref name="transformation"/> to be passed to the workspace change event.</param>
            <returns>True if <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> was set to the transformed solution, false if the
            transformation did not change the solution.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.InitializeAnalyzerFallbackOptions(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution)">
            <summary>
            Ensures that whenever a new language is added to <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> we 
            allow the host to initialize <see cref="P:Microsoft.CodeAnalysis.Solution.FallbackAnalyzerOptions"/> for that language.
            Conversely, if a language is no longer present in <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> 
            we clear out its <see cref="P:Microsoft.CodeAnalysis.Solution.FallbackAnalyzerOptions"/>.
            
            This mechanism only takes care of flowing the initial snapshot of option values.
            It's up to the host to keep the individual values up-to-date by updating 
            <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> as appropriate.
            
            Implementing the initialization here allows us to uphold an invariant that
            the host had the opportunity to initialize <see cref="P:Microsoft.CodeAnalysis.Solution.FallbackAnalyzerOptions"/>
            of any <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot stored in <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution``1(``0,System.Func{Microsoft.CodeAnalysis.Solution,``0,Microsoft.CodeAnalysis.Solution},System.Boolean,System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,``0},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,``0})">
            <summary>
            Applies specified transformation to <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/>, updates <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> to
            the new value and performs a requested callback immediately before and after that update.  The callbacks
            will be invoked atomically while while <see cref="F:Microsoft.CodeAnalysis.Workspace._serializationLock"/> is being held.
            </summary>
            <param name="transformation">Solution transformation. This may be run multiple times.  As such it should be
            a purely functional transformation on the solution instance passed to it.  It should not make stateful
            changes elsewhere.</param>
            <param name="mayRaiseEvents"><see langword="true"/> if this operation may raise observable events;
            otherwise, <see langword="false"/>. If <see langword="true"/>, the operation will call
            <see cref="M:Microsoft.CodeAnalysis.Workspace.EnsureEventListeners"/> to ensure listeners are registered prior to callbacks that may raise
            events.</param>
            <param name="onBeforeUpdate">Action to perform immediately prior to updating <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/>.
            The action will be passed the old <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> that will be replaced and the exact solution
            it will be replaced with. The latter may be different than the solution returned by <paramref
            name="transformation"/> as it will have its <see cref="P:Microsoft.CodeAnalysis.Solution.WorkspaceVersion"/> updated
            accordingly.  This will only be run once.</param>
            <param name="onAfterUpdate">Action to perform once <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> has been updated.  The
            action will be passed the old <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> that was just replaced and the exact solution it
            was replaced with. The latter may be different than the solution returned by <paramref
            name="transformation"/> as it will have its <see cref="P:Microsoft.CodeAnalysis.Solution.WorkspaceVersion"/> updated
            accordingly.  This will only be run once.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolutionAsync``1(System.Boolean,``0,System.Func{Microsoft.CodeAnalysis.Solution,``0,Microsoft.CodeAnalysis.Solution},System.Boolean,System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,``0},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,``0},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution``1(``0,System.Func{Microsoft.CodeAnalysis.Solution,``0,Microsoft.CodeAnalysis.Solution},System.Boolean,System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,``0},System.Action{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,``0})"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Options">
            <summary>
            Gets or sets the set of all global options and <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            Setter also force updates the <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> to have the updated <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ScheduleTask(System.Action,System.String)">
            <summary>
            Executes an action as a background task, as part of a sequential queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ScheduleTask``1(System.Func{``0},System.String)">
            <summary>
            Execute a function as a background task, as part of a sequential queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.Document)">
            <summary>
            Override this method to act immediately when the text of a document has changed, as opposed
            to waiting for the corresponding workspace changed event to fire asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentClosing(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Override this method to act immediately when a document is closing, as opposed
            to waiting for the corresponding workspace changed event to fire asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolution">
            <summary>
            Clears all solution data and empties the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolution(System.Boolean)">
            <param name="reportChangeEvent">Used so that while disposing we can clear the solution without issuing more
            events. As we are disposing, we don't want to cause any current listeners to do work on us as we're in the
            process of going away.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolutionData">
            <summary>
            This method is called when a solution is cleared.
            <para>
            Override this method if you want to do additional work when a solution is cleared. Call the base method at
            the end of your method.</para>
            <para>
            This method is called while a lock is held.  Be very careful when overriding as innapropriate work can cause deadlocks.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearProjectData(Microsoft.CodeAnalysis.ProjectId)">
             <summary>
             This method is called when an individual project is removed.
            
             Override this method if you want to do additional work when a project is removed.
             Call the base method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearDocumentData(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called to clear an individual document is removed.
            
             Override this method if you want to do additional work when a document is removed.
             Call the base method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.Dispose">
            <summary>
            Disposes this workspace. The workspace can longer be used after it is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.Dispose(System.Boolean)">
             <summary>
             Call this method when the workspace is disposed.
            
             Override this method to do additional work when the workspace is disposed.
             Call this method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionAdded(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Call this method to respond to a solution being opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionReloaded(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Call this method to respond to a solution being reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionRemoved">
             <summary>
             This method is called when the solution is removed from the workspace.
            
             Override this method if you want to do additional work when the solution is removed.
             Call the base method at the end of your method.
             Call this method to respond to a solution being removed/cleared/closed in the host environment.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectAdded(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Call this method to respond to a project being added/opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReloaded(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Call this method to respond to a project being reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectRemoved(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Call this method to respond to a project being removed from the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectCanBeRemoved(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Currently projects can always be removed, but this method still exists because it's protected and we don't
            want to break people who may have derived from <see cref="T:Microsoft.CodeAnalysis.Workspace"/> and either called it, or overridden it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAssemblyNameChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's assembly name is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnOutputFilePathChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's output file path is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnOutputRefFilePathChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's output ref file path is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectNameChanged(Microsoft.CodeAnalysis.ProjectId,System.String,System.String)">
            <summary>
            Call this method when a project's name is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDefaultNamespaceChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's default namespace is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnCompilationOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Call this method when a project's compilation options are changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnParseOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Call this method when a project's parse options are changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Call this method when a project reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Call this method when a project reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnMetadataReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Call this method when a metadata reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnMetadataReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Call this method when a metadata reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionAnalyzerReferenceAdded(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionFallbackAnalyzerOptionsChanged(System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions})">
            <summary>
            Call this method when <see cref="P:Microsoft.CodeAnalysis.Solution.FallbackAnalyzerOptions"/> change in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnHasAllInformationChanged(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Call this method when status of project has changed to incomplete.
            See <see cref="P:Microsoft.CodeAnalysis.ProjectInfo.HasAllInformation"/> for more information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnRunAnalyzersChanged(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Call this method when a project's RunAnalyzers property is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when a document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentsAdded(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Call this method when multiple document are added to one or more projects in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentReloaded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when a document is reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when a document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentInfoChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when the document info changes, such as the name, folders or file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of a document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of an additional document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of an analyzer config document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,System.Boolean)">
            <summary>
            Call this method when the text of a document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a additional document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a analyzer config document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnyDocumentTextChanged``1(Microsoft.CodeAnalysis.DocumentId,``0,System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextDocument},System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,``0,Microsoft.CodeAnalysis.Solution},Microsoft.CodeAnalysis.WorkspaceChangeKind,System.Boolean,System.Boolean)">
            <summary>
            When a <see cref="T:Microsoft.CodeAnalysis.Document"/>s text is changed, we need to make sure all of the linked files also have their
            content updated in the new solution before applying it to the workspace to avoid the workspace having
            solutions with linked files where the contents do not match.
            </summary>
            <param name="requireDocumentPresent">Allow caller to indicate behavior that should happen if this is a
            request to update a document not currently in the workspace.  This should be used only in hosts where there
            may be disparate sources of text change info, without an underlying agreed upon synchronization context to
            ensure consistency between events.  For example, in an LSP server it might be the case that some events were
            being posted by an attached lsp client, while another source of events reported information produced by a
            self-hosted project system.  These systems might report events on entirely different cadences, leading to
            scenarios where there might be disagreements as to the state of the workspace.  Clients in those cases must
            be resilient to those disagreements (for example, by falling back to a misc-workspace if the lsp client
            referred to a document no longer in the workspace populated by the project system).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentSourceCodeKindChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Call this method when the SourceCodeKind of a document changes in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when an additional document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when an additional document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when an analyzer config document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when an analyzer config document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.UpdateReferencesAfterAdd">
            <summary>
            Updates all projects to properly reference other projects as project references instead of metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)">
            <summary>
            Determines if the specific kind of change is supported by the <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanAddProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns <see langword="true"/> if a reference to referencedProject can be added to
            referencingProject.  <see langword="false"/> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)">
             <summary>
             Apply changes made to a solution back to the workspace.
            
             The specified solution must be one that originated from this workspace. If it is not, or the workspace
             has been updated since the solution was obtained from the workspace, then this method returns false. This method
             will still throw if the solution contains changes that are not supported according to the <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/>
             method.
             </summary>
             <exception cref="T:System.NotSupportedException">Thrown if the solution contains changes not supported according to the
             <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/> method.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanApplyCompilationOptionChange(Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.Project)">
            <summary>
            Called during a call to <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to determine if a specific change to <see cref="P:Microsoft.CodeAnalysis.Project.CompilationOptions"/> is allowed.
            </summary>
            <remarks>
            This method is only called if <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)" /> returns false for <see cref="F:Microsoft.CodeAnalysis.ApplyChangesKind.ChangeCompilationOptions"/>.
            If <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)" /> returns true, then that means all changes are allowed and this method does not need to be called.
            </remarks>
            <param name="oldOptions">The old <see cref="T:Microsoft.CodeAnalysis.CompilationOptions"/> of the project from prior to the change.</param>
            <param name="newOptions">The new <see cref="T:Microsoft.CodeAnalysis.CompilationOptions"/> of the project that was passed to <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/>.</param>
            <param name="project">The project contained in the <see cref="T:Microsoft.CodeAnalysis.Solution"/> passed to <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanApplyParseOptionChange(Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.ParseOptions,Microsoft.CodeAnalysis.Project)">
            <summary>
            Called during a call to <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to determine if a specific change to <see cref="P:Microsoft.CodeAnalysis.Project.ParseOptions"/> is allowed.
            </summary>
            <remarks>
            This method is only called if <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)" /> returns false for <see cref="F:Microsoft.CodeAnalysis.ApplyChangesKind.ChangeParseOptions"/>.
            If <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)" /> returns true, then that means all changes are allowed and this method does not need to be called.
            </remarks>
            <param name="oldOptions">The old <see cref="T:Microsoft.CodeAnalysis.ParseOptions"/> of the project from prior to the change.</param>
            <param name="newOptions">The new <see cref="T:Microsoft.CodeAnalysis.ParseOptions"/> of the project that was passed to <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/>.</param>
            <param name="project">The project contained in the <see cref="T:Microsoft.CodeAnalysis.Solution"/> passed to <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(Microsoft.CodeAnalysis.ProjectChanges)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> for each project
             that has been added, removed or changed.
            
             Override this method if you want to modify how project changes are applied.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectAdded(Microsoft.CodeAnalysis.ProjectInfo)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a project to the current solution.
            
             Override this method to implement the capability of adding projects.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectRemoved(Microsoft.CodeAnalysis.ProjectId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a project from the current solution.
            
             Override this method to implement the capability of removing projects.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyCompilationOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to change the compilation options.
            
             Override this method to implement the capability of changing compilation options.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyParseOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to change the parse options.
            
             Override this method to implement the capability of changing parse options.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a project reference to a project.
            
             Override this method to implement the capability of adding project references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a project reference from a project.
            
             Override this method to implement the capability of removing project references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyMetadataReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a metadata reference to a project.
            
             Override this method to implement the capability of adding metadata references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyMetadataReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a metadata reference from a project.
            
             Override this method to implement the capability of removing metadata references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add an analyzer reference to a project.
            
             Override this method to implement the capability of adding analyzer references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an analyzer reference from a project.
            
             Override this method to implement the capability of removing analyzer references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplySolutionAnalyzerReferenceAdded(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add an analyzer reference to the solution.
            
             Override this method to implement the capability of adding analyzer references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplySolutionAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an analyzer reference from the solution.
            
             Override this method to implement the capability of removing analyzer references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a new document to a project.
            
             Override this method to implement the capability of adding documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a document from a project.
            
             Override this method to implement the capability of removing documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called to change the text of a document.
            
             Override this method to implement the capability of changing document text.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentInfoChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.DocumentInfo)">
             <summary>
             This method is called to change the info of a document.
            
             Override this method to implement the capability of changing a document's info.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAdditionalDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a new additional document to a project.
            
             Override this method to implement the capability of adding additional documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAdditionalDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an additional document from a project.
            
             Override this method to implement the capability of removing additional documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAdditionalDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called to change the text of an additional document.
            
             Override this method to implement the capability of changing additional document text.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerConfigDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a new analyzer config document to a project.
            
             Override this method to implement the capability of adding analyzer config documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerConfigDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an analyzer config document from a project.
            
             Override this method to implement the capability of removing analyzer config documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerConfigDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called to change the text of an analyzer config document.
            
             Override this method to implement the capability of changing analyzer config document text.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckSolutionIsEmpty">
            <summary>
            Throws an exception is the solution is not empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectIsInCurrentSolution(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception if the project is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectIsNotInCurrentSolution(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception is the project is part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Throws an exception if a project does not have a specific project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Throws an exception if a project already has a specific project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveTransitiveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception if project has a transitive reference to another project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Throws an exception if a project does not have a specific metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Throws an exception if a project already has a specific metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project does not have a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project already has a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckSolutionHasAnalyzerReference(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project already has a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckSolutionDoesNotHaveAnalyzerReference(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project already has a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if a document is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAdditionalDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if an additional document is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAnalyzerConfigDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if an analyzer config is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if a document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAdditionalDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if an additional document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAnalyzerConfigDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if the analyzer config document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetProjectName(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the name to use for a project in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for a document in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetAdditionalDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for an additional document in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetAnalyzerConfigDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for an analyzer document in an error message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspace.TextTracker">
            <summary>
            A class that responds to text buffer changes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspace._bufferToDocumentInCurrentContextMap">
            <summary>
            Tracks the document ID in the current context for a source text container for an opened text buffer.
            </summary>
            <remarks>For each entry in this map, there must be a corresponding entry in <see cref="F:Microsoft.CodeAnalysis.Workspace._bufferToAssociatedDocumentsMap"/> where the document ID in current context is one of associated document IDs.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspace._bufferToAssociatedDocumentsMap">
            <summary>
            Tracks all the associated document IDs for a source text container for an opened text buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CanOpenDocuments">
            <summary>
            True if this workspace supports manually opening and closing documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CanChangeActiveContextDocument">
            <summary>
            True if this workspace supports manually changing the active context document of a text buffer by calling <see cref="M:Microsoft.CodeAnalysis.Workspace.SetDocumentContext(Microsoft.CodeAnalysis.DocumentId)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified additional document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified additional document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified analyzer config document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified analyzer config document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.IsDocumentOpen(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Determines if the document is currently open in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetOpenDocumentIds(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets a list of the currently opened documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetRelatedDocumentIds(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the ids for documents in the <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> snapshot associated with the given <paramref name="container"/>.
            Documents are normally associated with a text container when the documents are opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the id for the document associated with the given text container in its current context.
            Documents are normally associated with a text container when the documents are opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Finds the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> related to the given <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> that
            is in the current context. If the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> is currently closed, then 
            it is returned directly. If it is open, then this returns the same result that 
            <see cref="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)"/> would return for the
            <see cref="T:Microsoft.CodeAnalysis.Text.SourceTextContainer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetDocumentContext(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method to tell the host environment to change the current active context to this document. Only supported if
            <see cref="P:Microsoft.CodeAnalysis.Workspace.CanChangeActiveContextDocument"/> returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when a document has been made the active context in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSourceGeneratedDocumentOpened(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.SourceGeneratedDocument)">
            <summary>
            Registers a SourceTextContainer to a source generated document. Unlike <see
            cref="M:Microsoft.CodeAnalysis.Workspace.OnDocumentOpened(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceTextContainer,System.Boolean)" />, this doesn't result in the workspace
            being updated any time the contents of the container is changed; instead this ensures that features going
            from the text container to the buffer back to a document get a usable document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryOnDocumentClosedAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Tries to close the document identified by <paramref name="documentId"/>.  This is only needed by
            implementations of ILspWorkspace to indicate that the workspace should try to transition to the closed state
            for this document, but can bail out gracefully if they don't know about it (for example if they haven't
            heard about the file from the project system).  Subclasses should determine what file contents they should
            transition to if the file is within the workspace.
            </summary>
            <param name="documentId"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RemoveDocumentFromCurrentContextMapping_NoLock(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.DocumentId)">
            <returns>The DocumentId of the current context document attached to the textContainer, if any.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AdjustReloadedSolution(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution)">
            <summary>
             This method is called during OnSolutionReload.  Override this method if you want to manipulate
             the reloaded solution.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.WorkspaceChanged">
            <summary>
            An event raised whenever the current solution is changed.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.WorkspaceFailed">
            <summary>
            An event raised whenever the workspace or part of its solution model
            fails to access a file or other external resource.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentOpened">
            <summary>
            An event that is fired when a <see cref="T:Microsoft.CodeAnalysis.Document"/> is opened in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.TextDocumentOpened">
            <summary>
            An event that is fired when any <see cref="T:Microsoft.CodeAnalysis.TextDocument"/> is opened in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentClosed">
            <summary>
            An event that is fired when a <see cref="T:Microsoft.CodeAnalysis.Document"/> is closed in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.TextDocumentClosed">
            <summary>
            An event that is fired when any <see cref="T:Microsoft.CodeAnalysis.TextDocument"/> is closed in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentActiveContextChanged">
            <summary>
            An event that is fired when the active context document associated with a buffer 
            changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryGetWorkspace(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.Workspace@)">
            <summary>
            Gets the workspace associated with the specific text container.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RegisterText(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Register a correspondence between a text container and a workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.UnregisterText(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Unregister a correspondence between a text container and a workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetWorkspaceRegistration(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.WorkspaceRegistration" /> for a given text container.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspace._updateSourceGeneratorsQueue">
            <summary>
            Used for batching up a lot of events and only combining them into a single request to update generators.  The
            <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> represents the projects that have changed, and which need their source-generators
            re-run.  <see langword="null"/> in the list indicates the entire solution has changed and all generators need to
            be rerun.  The <see cref="T:System.Boolean"/> represents if source generators should be fully rerun for the requested
            project or solution.  If <see langword="false"/>, the existing generator driver will be used, which may result
            in no actual changes to emitted source (as the driver may decide no inputs changed, and thus all outputs should
            be reused).  If <see langword="true"/>, the existing driver will be dropped, forcing all generation to be redone.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs">
            <summary>
            The <see cref="T:System.EventArgs"/> describing any kind of workspace change.
            </summary>
            <remarks>
            When linked files are edited, one document change event is fired per linked file. All of
            these events contain the same <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/>, and they all contain the same
            <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/>. This is so that we can trigger document change events on all
            affected documents without reporting intermediate states in which the linked file contents
            do not match.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution">
            <remarks>
            If linked documents are being changed, there may be multiple events with the same <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/>
            and <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/>.  Note that the workspace starts with its solution set to an empty solution.
            <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionAdded"/> replaces the previous solution, which might be the empty
            one.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution">
            <remarks>
            If linked documents are being changed, there may be multiple events with the same <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/>
            and <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/>. Note <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionRemoved"/> replaces the previous
            solution with the empty one.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.ProjectId">
            <summary>
            The id of the affected <see cref="T:Microsoft.CodeAnalysis.Project"/>.  Can be <see langword="null"/> if this is an change unrelated
            to a project (for example <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionReloaded"/>.  Should be non-<see
            langword="null"/> for:
            <list type="bullet">
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectAdded"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectChanged"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectReloaded"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectRemoved"/></item>
            </list>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.DocumentId">
            <summary>
            The id of the affected <see cref="T:Microsoft.CodeAnalysis.Document"/>.  Can be <see langword="null"/> if this is an change unrelated
            to a document (for example <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectAdded"/>. Should be non-<see
            langword="null"/> for:
            <list type="bullet">
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentAdded"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentInfoChanged"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentReloaded"/></item>
            <item><see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentRemoved"/></item>
            </list>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionChanged">
            <summary>
            The current solution changed for an unspecified reason.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionAdded">
            <summary>
            A solution was added to the workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionRemoved">
            <summary>
            The current solution was removed from the workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionCleared">
            <summary>
            The current solution was cleared of all projects and documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionReloaded">
            <summary>
            The current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectAdded">
            <summary>
            A project was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectRemoved">
            <summary>
            A project was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectChanged">
            <summary>
            A project in the current solution was changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectReloaded">
            <summary>
            A project in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentAdded">
            <summary>
            A document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentRemoved">
            <summary>
            A document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentReloaded">
            <summary>
            A document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged">
            <summary>
            A document in the current solution was changed.
            <para>
            When linked files are edited, one <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged"/> event is fired per
            linked file. All of these events contain the same OldSolution, and they all contain
            the same NewSolution. This is so that we can trigger document change events on all
            affected documents without reporting intermediate states in which the linked file
            contents do not match. Each <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged"/> event does not represent
            an incremental update from the previous event in this special case.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentAdded">
            <summary>
            An additional document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentRemoved">
            <summary>
            An additional document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentReloaded">
            <summary>
            An additional document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentChanged">
            <summary>
            An additional document in the current solution was changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentInfoChanged">
            <summary>
            The document in the current solution had is info changed; name, folders, filepath
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentAdded">
            <summary>
            An analyzer config document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentRemoved">
            <summary>
            An analyzer config document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentReloaded">
            <summary>
            An analyzer config document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentChanged">
            <summary>
            An analyzer config document in the current solution was changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceFileTextLoader">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.FileTextLoader"/> that uses workspace services (i.e. <see cref="T:Microsoft.CodeAnalysis.Host.ITextFactoryService"/>) to load file content.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceKind">
            <summary>
             Known workspace kinds
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceKind.Custom">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.AdhocWorkspace"/> kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoaderInternal.IsHostAssembly(System.Reflection.Assembly)">
            <summary>
            Is this an <see cref="T:System.Reflection.Assembly"/> that the loader considers to be part of the hosting 
            process. Either part of the compiler itself or the process hosting the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoaderInternal.GetOriginalDependencyLocation(System.Reflection.AssemblyName)">
            <summary>
            For a given <see cref="T:System.Reflection.AssemblyName"/> return the location it was originally added 
            from. This will return null for any value that was not directly added through the 
            loader.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader">
            <summary>
            The base implementation for <see cref="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader"/>. This type provides caching and tracking of inputs given
            to <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.AddDependencyLocation(System.String)"/>.
            </summary>
            <remarks>
            This type generally assumes that files on disk aren't changing, since it ensure that two calls to <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.LoadFromPath(System.String)"/>
            will always return the same thing, per that interface's contract.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._analyzerAssemblyInfoMap">
            <summary>
            Set of analyzer dependencies original full paths to the data calculated for that path
            </summary>
            <remarks>
            Access must be guarded by <see cref="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._guard"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._analyzerSatelliteAssemblyRealPaths">
            <summary>
            Mapping of analyzer dependency original full path and culture to the real satellite
            assembly path. If the satellite assembly doesn't exist for the original analyzer and 
            culture, the real path value stored will be null.
            </summary>
            <remarks>
            Access must be guarded by <see cref="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._guard"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._knownAssemblyPathsBySimpleName">
            <summary>
            Maps analyzer dependency simple names to the set of original full paths it was loaded from. This _only_ 
            tracks the paths provided to the analyzer as it's a place to look for indirect loads. 
            </summary>
            <remarks>
            Access must be guarded by <see cref="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._guard"/>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._externalResolvers">
            <summary>
            A collection of <see cref="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyResolver"/>s that can be used to override the assembly resolution process.
            </summary>
            <remarks>
            When multiple resolvers are present they are consulted in-order, with the first resolver to return a non-null
            <see cref="T:System.Reflection.Assembly"/> winning.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._isDisposed">
            <summary>
            Whether or not we're disposed.  Once disposed, all functionality on this type should throw.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.Load(System.Reflection.AssemblyName,System.String)">
            <summary>
            The implementation needs to load an <see cref="T:System.Reflection.Assembly"/> with the specified <see cref="T:System.Reflection.AssemblyName"/>. The
            <paramref name="assemblyOriginalPath"/> parameter is the original path. It may be different than
            <see cref="P:System.Reflection.AssemblyName.CodeBase"/> as that is empty on .NET Core.
            </summary>
            <remarks>
            This method should return an <see cref="T:System.Reflection.Assembly"/> instance or throw.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.IsMatch(System.Reflection.AssemblyName,System.Reflection.AssemblyName)">
            <summary>
            Determines if the <paramref name="candidateName"/> satisfies the request for 
            <paramref name="requestedName"/>. This is partial'd out as each runtime has a different 
            definition of matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.GetAssemblyInfoForPath(System.String)">
            <summary>
            Get the <see cref="T:System.Reflection.AssemblyName"/> and the path it should be loaded from for the given original 
            analyzer path
            </summary>
            <remarks>
            This is used in the implementation of the loader instead of <see cref="M:System.Reflection.AssemblyName.GetAssemblyName(System.String)"/>
            because we only want information for registered paths. Using unregistered paths inside the
            implementation should result in errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.GetRealSatelliteLoadPath(System.String,System.Globalization.CultureInfo)">
            <summary>
            Get the path a satellite assembly should be loaded from for the given original 
            analyzer path and culture
            </summary>
            <remarks>
            This is used during assembly resolve for satellite assemblies to determine the
            path from where the satellite assembly should be loaded for the specified culture.
            This method calls <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.PrepareSatelliteAssemblyToLoad(System.String,System.String)"/> to ensure this path
            contains the satellite assembly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.GetBestPath(System.Reflection.AssemblyName)">
            <summary>
            Return the best (original, real) path information for loading an assembly with the specified <see cref="T:System.Reflection.AssemblyName"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.PreparePathToLoad(System.String)">
            <summary>
            When overridden in a derived class, allows substituting an assembly path after we've
            identified the context to load an assembly in, but before the assembly is actually
            loaded from disk. This is used to substitute out the original path with the shadow-copied version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.PrepareSatelliteAssemblyToLoad(System.String,System.String)">
            <summary>
            When overridden in a derived class, allows substituting a satellite assembly path after we've
            identified the context to load a satellite assembly in, but before the satellite assembly is actually
            loaded from disk. This is used to substitute out the original path with the shadow-copied version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.GetRealAnalyzerLoadPath(System.String)">
            <summary>
            When <see cref="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.PreparePathToLoad(System.String)"/> is overridden this returns the most recent
            real path calculated for the <paramref name="originalFullPath"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.ResolveAssemblyExternally(System.Reflection.AssemblyName)">
            <summary>
            Iterates the <see cref="F:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader._externalResolvers"/> if any, to see if any of them can resolve
            the given <see cref="T:System.Reflection.AssemblyName"/> to an <see cref="T:System.Reflection.Assembly"/>.
            </summary>
            <param name="assemblyName">The name of the assembly to resolve</param>
            <returns>An <see langword="assembly"/> if one of the resolvers is successful, or <see langword="null"/></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.CompilerAnalyzerAssemblyResolver">
            <summary>
            A resolver which allows a passed in <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> from the compiler 
            to control assembly resolution. This is important because there are many exchange types
            that need to unify across the multiple analyzer ALCs. These include common types from
            <c>Microsoft.CodeAnalysis.dll</c> etc, as well as platform assemblies provided by a 
            host such as visual studio.
            </summary>
            <remarks>
            This resolver essentially forces any assembly that was loaded as a 'core' part of the
            compiler to be shared across analyzers, and not loaded multiple times into each individual
            analyzer ALC, even if the analyzer itself shipped a copy of said assembly.
            </remarks>
            <param name="compilerContext">The <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> that the core
            compiler assemblies are already loaded into.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader.CompilerAnalyzerAssemblyResolver.#ctor(System.Runtime.Loader.AssemblyLoadContext)">
            <summary>
            A resolver which allows a passed in <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> from the compiler 
            to control assembly resolution. This is important because there are many exchange types
            that need to unify across the multiple analyzer ALCs. These include common types from
            <c>Microsoft.CodeAnalysis.dll</c> etc, as well as platform assemblies provided by a 
            host such as visual studio.
            </summary>
            <remarks>
            This resolver essentially forces any assembly that was loaded as a 'core' part of the
            compiler to be shared across analyzers, and not loaded multiple times into each individual
            analyzer ALC, even if the analyzer itself shipped a copy of said assembly.
            </remarks>
            <param name="compilerContext">The <see cref="T:System.Runtime.Loader.AssemblyLoadContext"/> that the core
            compiler assemblies are already loaded into.</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerLoadOption.LoadFromDisk">
            <summary>
            Once the assembly path is chosen, load it directly from disk at that location
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AnalyzerLoadOption.LoadFromStream">
            <summary>
            Once the assembly path is chosen, read the contents of disk and load from memory
            </summary>
            <remarks>
            While Windows supports this option it comes with a significant performance penalty due
            to anti virus scans. It can have a load time of 300-500ms while loading from disk 
            is generally 1-2ms. Use this with caution on Windows.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DefaultAnalyzerAssemblyLoader.PreparePathToLoad(System.String)">
            <summary>
            The default implementation is to simply load in place.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DefaultAnalyzerAssemblyLoader.PrepareSatelliteAssemblyToLoad(System.String,System.String)">
            <summary>
            The default implementation is to simply load in place.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DefaultAnalyzerAssemblyLoader.CreateNonLockingLoader(System.String,System.Nullable{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IAnalyzerAssemblyResolver}})">
            <summary>
            Return an <see cref="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader"/> which does not lock assemblies on disk that is
            most appropriate for the current platform.
            </summary>
            <param name="windowsShadowPath">A shadow copy path will be created on Windows and this value 
            will be the base directory where shadow copy assemblies are stored. </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader._baseDirectory">
            <summary>
            The base directory for shadow copies. Each instance of
            <see cref="T:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader"/> gets its own
            subdirectory under this directory. This is also the starting point
            for scavenge operations.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader._shadowCopyDirectoryAndMutex">
            <summary>
            The directory where this instance of <see cref="T:Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader"/>
            will shadow-copy assemblies, and the mutex created to mark that the owner of it is still active.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IAnalyzerAssemblyResolver">
            <summary>
            Allows a host to override how assembly resolution is performed by the <see cref="T:Microsoft.CodeAnalysis.AnalyzerAssemblyLoader"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IAnalyzerAssemblyResolver.ResolveAssembly(System.Reflection.AssemblyName)">
            <summary>
            Attempts to resolve an assembly by name.
            </summary>
            <param name="assemblyName">The assembly to resolve</param>
            <returns>The resolved assembly, or <see langword="null"/></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.PooledArrayLengthLimitExclusive">
            <summary>
            See <see cref="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Free"/> for an explanation of this constant value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndClear">
            <summary>
            Realizes the array and clears the collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates">
            <summary>
            Provides pooled delegate instances to help avoid closure allocations for delegates that require a state argument
            with APIs that do not provide appropriate overloads with state arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``1(System.Action{``0},``0,System.Action@)">
             <summary>
             Gets an <see cref="T:System.Action"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(() => this.DoSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction(arg => arg.self.DoSomething(arg.x), (self: this, x), out Action action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``2(System.Action{``0,``1},``1,System.Action{``0}@)">
             <summary>
             Gets an <see cref="T:System.Action`1"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback(a => this.DoSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, arg) => arg.self.DoSomething(a, arg.x), (self: this, x), out Action&lt;int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``3(System.Action{``0,``1,``2},``2,System.Action{``0,``1}@)">
             <summary>
             Gets an <see cref="T:System.Action`2"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b) => this.DoSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, arg) => arg.self.DoSomething(a, b, arg.x), (self: this, x), out Action&lt;int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledAction``4(System.Action{``0,``1,``2,``3},``3,System.Action{``0,``1,``2}@)">
             <summary>
             Gets an <see cref="T:System.Action`3"/> delegate, which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>. The resulting <paramref name="boundAction"/> may be called any number of times
             until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a callback action that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithActionCallback((a, b, c) => this.DoSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             callback action:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledAction((a, b, c, arg) => arg.self.DoSomething(a, b, c, arg.x), (self: this, x), out Action&lt;int, int, int&gt; action);
             RunWithActionCallback(action);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound action.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound action.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound action.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundAction"/>.</typeparam>
             <param name="unboundAction">The unbound action delegate.</param>
             <param name="argument">The argument to pass to the unbound action delegate.</param>
             <param name="boundAction">A delegate which calls <paramref name="unboundAction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``2(System.Func{``0,``1},``0,System.Func{``1}@)">
             <summary>
             Gets a <see cref="T:System.Func`1"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(() => this.IsSomething(x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction(arg => arg.self.IsSomething(arg.x), (self: this, x), out Func&lt;bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledCreateValueCallback``3(System.Func{``0,``1,``2},``1,System.Runtime.CompilerServices.ConditionalWeakTable{``0,``2}.CreateValueCallback@)">
            <summary>
            Equivalent to <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``2(System.Func{``0,``1},``0,System.Func{``1}@)"/>,
            except typed such that it can be used to create a pooled <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``3(System.Func{``0,``1,``2},``1,System.Func{``0,``2}@)">
             <summary>
             Gets a <see cref="T:System.Func`2"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate(a => this.IsSomething(a, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, arg) => arg.self.IsSomething(a, arg.x), (self: this, x), out Func&lt;int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``4(System.Func{``0,``1,``2,``3},``2,System.Func{``0,``1,``3}@)">
             <summary>
             Gets a <see cref="T:System.Func`3"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b) => this.IsSomething(a, b, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, arg) => arg.self.IsSomething(a, b, arg.x), (self: this, x), out Func&lt;int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.GetPooledFunction``5(System.Func{``0,``1,``2,``3,``4},``3,System.Func{``0,``1,``2,``4}@)">
             <summary>
             Gets a <see cref="T:System.Func`4"/> delegate, which calls <paramref name="unboundFunction"/> with the
             specified <paramref name="argument"/>. The resulting <paramref name="boundFunction"/> may be called any
             number of times until the returned <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> is disposed.
             </summary>
             <example>
             <para>The following example shows the use of a capturing delegate for a predicate that requires an
             argument:</para>
            
             <code>
             int x = 3;
             RunWithPredicate((a, b, c) => this.IsSomething(a, b, c, x));
             </code>
            
             <para>The following example shows the use of a pooled delegate to avoid capturing allocations for the same
             predicate:</para>
            
             <code>
             int x = 3;
             using var _ = GetPooledFunction((a, b, c, arg) => arg.self.IsSomething(a, b, c, arg.x), (self: this, x), out Func&lt;int, int, int, bool&gt; predicate);
             RunWithPredicate(predicate);
             </code>
             </example>
             <typeparam name="T1">The type of the first parameter of the bound function.</typeparam>
             <typeparam name="T2">The type of the second parameter of the bound function.</typeparam>
             <typeparam name="T3">The type of the third parameter of the bound function.</typeparam>
             <typeparam name="TArg">The type of argument to pass to <paramref name="unboundFunction"/>.</typeparam>
             <typeparam name="TResult">The type of the return value of the function.</typeparam>
             <param name="unboundFunction">The unbound function delegate.</param>
             <param name="argument">The argument to pass to the unbound function delegate.</param>
             <param name="boundFunction">A delegate which calls <paramref name="unboundFunction"/> with the specified
             <paramref name="argument"/>.</param>
             <returns>A disposable <see cref="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser"/> which returns the object to the delegate pool.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser">
             <summary>
             A releaser for a pooled delegate.
             </summary>
             <remarks>
             <para>This type is intended for use as the resource of a <c>using</c> statement. When used in this manner,
             <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> should not be called explicitly.</para>
            
             <para>If used without a <c>using</c> statement, calling <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is optional. If the call is
             omitted, the object will not be returned to the pool. The behavior of this type if <see cref="M:Microsoft.CodeAnalysis.PooledObjects.PooledDelegates.Releaser.Dispose"/> is
             called multiple times is undefined.</para>
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.CreatePool(System.Int32)">
            <summary>
            If someone need to create a private pool
            </summary>
            <param name="size">The size of the pool.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RoslynExperiments">
            <summary>
            Defines diagnostic info for Roslyn experimental APIs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmptyReadOnlyMemoryOfCharComparer">
            <summary>
            Very cheap trivial comparer that never matches the keys,
            should only be used in empty dictionaries.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.VerifySource(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Verify nodes match source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.FindFirstDifference(System.String,System.String)">
            <summary>
            Return the index of the first difference between
            the two strings, or -1 if the strings are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.IsHiddenPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if the provided position is in a hidden region inaccessible to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImmutableArrayExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">If items is null (default)</exception>
            <remarks>If the sequence is null, this will throw <see cref="T:System.ArgumentNullException"/></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return an empty array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])">
            <summary>
            Converts an array to an immutable array. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])">
            <summary>
            Converts a array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])">
            <summary>
            Converts an array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns>If the array is null, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1})">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
             Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Maps a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <typeparam name="TArg">Type of the extra argument</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <param name="arg">The extra input used by <paramref name="predicate"/> and <paramref name="selector"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectManyAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Maps and flattens a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>If the array's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectManyAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Collections.Immutable.ImmutableArray{``1}})">
            <summary>
            Maps and flattens a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="selector">A transform function to apply to each element.</param>
            <returns>If the array's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectManyAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Maps and flattens a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectManyAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Collections.Immutable.ImmutableArray{``1}})">
            <summary>
            Maps and flattens a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArrayAsync``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTasks, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArrayAsync``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``2}},``1,System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTasks, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ZipAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``1},System.Func{``0,``1,``2})">
            <summary>
            Zips two immutable arrays together through a mapping function, producing another immutable array.
            </summary>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,System.Boolean},``1)">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Casts the immutable array of a Type to an immutable array of its base type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether this instance and another immutable array are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <param name="comparer">The comparer to determine if the two arrays are equal.</param>
            <returns>True if the two arrays are equal</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an empty array if the input array is null (default)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Nullable{System.Collections.Immutable.ImmutableArray{``0}})">
            <summary>
            Returns an empty array if the input nullable value type is null or the underlying array is null (default)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an array of distinct elements, preserving the order in the original array.
            If the array has no duplicates, the original array is returned. The original array must not be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasDuplicates``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Determines whether duplicates exist using default equality comparer.
            </summary>
            <param name="array">Array to search for duplicates</param>
            <returns>Whether duplicates were found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.HasDuplicates``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether duplicates exist using <paramref name="comparer"/>. Use other override
            if you don't need a custom comparer.
            </summary>
            <param name="array">Array to search for duplicates</param>
            <param name="comparer">Comparer to use in search</param>
            <returns>Whether duplicates were found</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Clone">
            <summary>
            Make a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Invert">
            <summary>
            Invert all the bits in the vector.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BitVector.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.IntersectWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.UnionWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <returns>
            True if any bits were set as a result of the union.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2">
            <summary>
            A MultiDictionary that allows only adding, and preserves the order of values added to the 
            dictionary. Thread-safe for reading, but not for adding.
            </summary>
            <remarks>
            Always uses the default comparer.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Item(`0)">
            <summary>
            Get all values associated with K, in the order they were added.
            Returns empty read-only array if no values were present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Keys">
            <summary>
            Get a collection of all the keys.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.ValueSet._value">
            <summary>
            Each value is either a single V or an <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/>.
            Never null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary">
            <summary>
            Provides methods for creating a segmented dictionary that is immutable; meaning it cannot be changed once it is
            created.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2">
             <summary>
             Represents a segmented dictionary that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/>.</para>
            
             <para>In general, <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> is applicable in scenarios most like
             the scenarios where <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> is applicable, and
             <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> is applicable in scenarios most like the scenarios where
             <see cref="T:System.Collections.Immutable.ImmutableList`1"/> is applicable.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented dictionary</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented dictionary</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
             <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2._dictionary"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder.PrivateMarshal.FindValue(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{`0,`1}.Builder,`0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}.Builder,``0)"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder._builder">
            <summary>
            The private builder implementation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.KeyValuePair">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.Generic.KeyValuePair`2"/>. This is the return value for most instances of this
            enumerator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Enumerator.ReturnType.DictionaryEntry">
            <summary>
            The return value from the implementation of <see cref="M:System.Collections.IEnumerable.GetEnumerator"/> is
            <see cref="T:System.Collections.DictionaryEntry"/>. This is the return value for instances of this
            enumerator created by the <see cref="M:System.Collections.IDictionary.GetEnumerator"/> implementation in
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> and
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal.FindValue(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{`0,`1},`0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal.AsImmutableSegmentedDictionary(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{`0,`1})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.PrivateMarshal.AsSegmentedDictionary(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{`0,`1})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.ValueBuilder._dictionary">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.ValueBuilder._mutableDictionary">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.ValueBuilder._dictionary"/> the first time a change is made.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.Create``1(System.Collections.Generic.IEqualityComparer{``0},``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateBuilder``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateBuilder``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateBuilder``1(System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateBuilder``1(System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.CreateRange``1(System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.CreateRange``1(System.Collections.Generic.IEqualityComparer{``0},System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet.ToImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}.Builder)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet.ToImmutableHashSet``1(System.Collections.Immutable.ImmutableHashSet{``0}.Builder)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1">
             <summary>
             Represents a segmented hash set that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableHashSet`1"/>.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableHashSet`1"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Contains</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented list</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented hash set and cloning all impacted segments</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="T">The type of the value in the set.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1._set"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder._builder">
            <summary>
            The private builder implementation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.Count"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Builder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ToImmutable"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator">
            <inheritdoc cref="T:System.Collections.Immutable.ImmutableHashSet`1.Enumerator"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Current"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Dispose">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Dispose"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.MoveNext"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Enumerator.Reset"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> and
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateMarshal.AsImmutableSegmentedHashSet(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.PrivateMarshal.AsSegmentedHashSet(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder._set">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder._mutableSet">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder._set"/> the first time a change is made.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Builder.Count"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IntersectWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.UnionWith(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ValueBuilder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Builder.ToImmutable"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Empty">
            <inheritdoc cref="F:System.Collections.Immutable.ImmutableHashSet`1.Empty"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.KeyComparer">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.KeyComparer"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Count">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.Count"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsEmpty">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableHashSet`1.IsEmpty"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Contains(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Except(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.TryGetValue(`0,`0@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.TryGetValue(`0,`0@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.Union(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.ToBuilder">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.ToBuilder"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableHashSet`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1(``0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1(``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.Create``1(``0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.Create``1(``0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.CreateBuilder``1">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.CreateBuilder``1"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.ToImmutableSegmentedList``1(System.Collections.Generic.IEnumerable{``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Generic.IEnumerable{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList.ToImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}.Builder)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList.ToImmutableList``1(System.Collections.Immutable.ImmutableList{``0}.Builder)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1">
             <summary>
             Represents a segmented list that is immutable; meaning it cannot be changed once it is created.
             </summary>
             <remarks>
             <para>There are different scenarios best for <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> and others
             best for <see cref="T:System.Collections.Immutable.ImmutableList`1"/>.</para>
            
             <para>The following table summarizes the performance characteristics of
             <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/>:</para>
             
             <list type="table">
               <item>
                 <description>Operation</description>
                 <description><see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> Complexity</description>
                 <description><see cref="T:System.Collections.Immutable.ImmutableList`1"/> Complexity</description>
                 <description>Comments</description>
               </item>
               <item>
                 <description>Item</description>
                 <description>O(1)</description>
                 <description>O(log n)</description>
                 <description>Directly index into the underlying segmented list</description>
               </item>
               <item>
                 <description>Add()</description>
                 <description>Currently O(n), but could be O(1) with a relatively large constant</description>
                 <description>O(log n)</description>
                 <description>Currently requires creating a new segmented list, but could be modified to only clone the segments with changes</description>
               </item>
               <item>
                 <description>Insert()</description>
                 <description>O(n)</description>
                 <description>O(log n)</description>
                 <description>Requires creating a new segmented list and cloning all impacted segments</description>
               </item>
             </list>
             
             <para>This type is backed by segmented arrays to avoid using the Large Object Heap without impacting algorithmic
             complexity.</para>
             </remarks>
             <typeparam name="T">The type of the value in the list.</typeparam>
             <devremarks>
             <para>This type has a documented contract of being exactly one reference-type field in size. Our own
             <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> class depends on it, as well as others externally.</para>
            
             <para><strong>IMPORTANT NOTICE FOR MAINTAINERS AND REVIEWERS:</strong></para>
            
             <para>This type should be thread-safe. As a struct, it cannot protect its own fields from being changed from one
             thread while its members are executing on other threads because structs can change <em>in place</em> simply by
             reassigning the field containing this struct. Therefore it is extremely important that <strong> Every member
             should only dereference <c>this</c> ONCE </strong>. If a member needs to reference the
             <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1._list"/> field, that counts as a dereference of <c>this</c>. Calling other instance members
             (properties or methods) also counts as dereferencing <c>this</c>. Any member that needs to use <c>this</c> more
             than once must instead assign <c>this</c> to a local variable and use that for the rest of the code instead.
             This effectively copies the one field in the struct to a local variable so that it is insulated from other
             threads.</para>
             </devremarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder._builder">
            <summary>
            The private builder implementation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ItemRef(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ItemRef(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ConvertAll``1(System.Converter{`0,``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ConvertAll``1(System.Func{`0,``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.CopyTo(`0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.CopyTo(`0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Exists(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Find(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Find(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLast(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLast(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ForEach(System.Action{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ForEach(System.Action{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.GetRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.GetRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.RemoveAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.RemoveAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Reverse">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Reverse"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Reverse(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Reverse(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Comparison{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Comparison{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.ToImmutable">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.ToImmutable"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Builder.TrueForAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Builder.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked"/> and
            <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateMarshal.AsImmutableSegmentedList(Microsoft.CodeAnalysis.Collections.SegmentedList{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.SegmentedList{``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.PrivateMarshal.AsSegmentedList(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._list">
            <summary>
            The immutable collection this builder is based on.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._mutableList">
            <summary>
            The current mutable collection this builder is operating on. This field is initialized to a copy of
            <see cref="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ValueBuilder._list"/> the first time a change is made.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Empty">
            <inheritdoc cref="F:System.Collections.Immutable.ImmutableList`1.Empty"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsEmpty">
            <inheritdoc cref="P:System.Collections.Immutable.ImmutableList`1.IsEmpty"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ItemRef(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ItemRef(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Add(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Add(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.AddRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Clear">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Clear"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ConvertAll``1(System.Converter{`0,``0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ConvertAll``1(System.Func{`0,``0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.CopyTo(`0[])">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.CopyTo(`0[])"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Exists(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Exists(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Find(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Find(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLast(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLast(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ForEach(System.Action{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ForEach(System.Action{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.GetEnumerator">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.GetEnumerator"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.GetRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.GetRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Insert(System.Int32,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Insert(System.Int32,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Remove(`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Remove(`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveAt(System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveAt(System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.RemoveRange(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.RemoveRange(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Replace(`0,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Replace(`0,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Replace(`0,`0,System.Collections.Generic.IEqualityComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Reverse">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Reverse"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Reverse(System.Int32,System.Int32)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Reverse(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.SetItem(System.Int32,`0)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.SetItem(System.Int32,`0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Comparison{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Comparison{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.ToBuilder">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.ToBuilder"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.TrueForAll(System.Predicate{`0})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableList`1.TrueForAll(System.Predicate{`0})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1.SwapIfGreater(`0@,`0@)">
            <summary>Swaps the values in the two references if the first is greater than the second.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1.Swap(`0@,`0@)">
            <summary>Swaps the values in the two references, regardless of whether the two references are the same.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils">
            <summary>Helper methods for use in array/span sorting routines.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>How many ints must be allocated to represent n bits. Returns (n+31)/32, but avoids overflow.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)">
            <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
            <remarks>This should only be used on 64-bit.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.FastMod(System.UInt32,System.UInt32,System.UInt64)">
            <summary>Performs a mod operation using the multiplier pre-computed with <see cref="M:Microsoft.CodeAnalysis.Collections.Internal.HashHelpers.GetFastModMultiplier(System.UInt32)"/>.</summary>
            <remarks>
            PERF: This improves performance in 64-bit scenarios at the expense of performance in 32-bit scenarios. Since
            we only build a single AnyCPU binary, we opt for improved performance in the 64-bit scenario.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.ICollection"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.Generic.ICollection`1"/> members on value types that explicitly implement
            the member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IDictionaryCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IDictionary"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IEnumerable"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.Generic.IEnumerable`1"/> members on value types that explicitly implement
            the member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.IListCalls">
            <summary>
            Provides static methods to invoke <see cref="T:System.Collections.IList"/> members on value types that explicitly implement the
            member.
            </summary>
            <remarks>
            Normally, invocation of explicit interface members requires boxing or copying the value type, which is
            especially problematic for operations that mutate the value. Invocation through these helpers behaves like a
            normal call to an implicitly implemented member.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior">
            <summary>
            Used internally to control behavior of insertion into a <see cref="T:System.Collections.Generic.Dictionary`2"/> or <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.None">
            <summary>
            The default insertion behavior.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.OverwriteExisting">
            <summary>
            Specifies that an existing entry with the same key should be overwritten if encountered.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior.ThrowOnExisting">
            <summary>
            Specifies that if an existing entry with the same key is encountered, an exception should be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe.NullRef``1">
            <summary>
            Returns a by-ref to type <typeparamref name="T"/> that is a null reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe.IsNullRef``1(``0@)">
            <summary>
            Returns if a given by-ref to type <typeparamref name="T"/> is a null reference.
            </summary>
            <remarks>
            This check is conceptually similar to <c>(void*)(&amp;source) == nullptr</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentSize(System.Int32)">
            <summary>
            Calculates the maximum number of elements of size <paramref name="elementSize"/> which can fit into an array
            which has the following characteristics:
            <list type="bullet">
            <item><description>The array can be allocated in the small object heap.</description></item>
            <item><description>The array length is a power of 2.</description></item>
            </list>
            </summary>
            <param name="elementSize">The size of the elements in the array.</param>
            <returns>The segment size to use for small object heap segmented arrays.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateSegmentShift(System.Int32)">
            <summary>
            Calculates a shift which can be applied to an absolute index to get the page index within a segmented array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The shift to apply to the absolute index to get the page index within a segmented array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper.CalculateOffsetMask(System.Int32)">
            <summary>
            Calculates a mask, which can be applied to an absolute index to get the index within a page of a segmented
            array.
            </summary>
            <param name="segmentSize">The number of elements in each page of the segmented array. Must be a power of 2.</param>
            <returns>The bit mask to obtain the index within a page from an absolute index within a segmented array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.Internal.SegmentedHashSetEqualityComparer`1">
            <summary>Equality comparer for hashsets of hashsets</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_ArrayPlusOffTooSmall">
            <summary>Destination array is not long enough to copy all the items in the collection. Check array index and length.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_HTCapacityOverflow">
            <summary>Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_KeyNotFoundWithKey">
            <summary>The given key '{0}' was not present in the dictionary.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanDestArray">
            <summary>Destination array was not long enough. Check the destination index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_LongerThanSrcArray">
            <summary>Source array was not long enough. Check the source index, length, and the array's lower bounds.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_NonZeroLowerBound">
            <summary>The lower bound of target array must be zero.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_RankMultiDimNotSupported">
            <summary>Only single dimensional arrays are supported for the requested action.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_WrongType">
            <summary>The value "{0}" is not of type "{1}" and cannot be used in this generic collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_AddingDuplicateWithKey">
            <summary>An item with the same key has already been added. Key: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_IncompatibleArrayType">
            <summary>Target array type is not compatible with the type of items in the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Argument_InvalidOffLen">
            <summary>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ArrayLB">
            <summary>Number was less than the array's lower bound in the first dimension.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_BiggerThanCollection">
            <summary>Larger than collection size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_Count">
            <summary>Count must be positive and count must refer to a location within the string/array/collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_IndexMustBeLess">
            <summary>Index was out of range. Must be non-negative and less than the size of the collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_ListInsert">
            <summary>Index must be within the bounds of the List.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>Non-negative number required.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_SmallCapacity">
            <summary>capacity was less than the current size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_ConcurrentOperationsNotSupported">
            <summary>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumFailedVersion">
            <summary>Collection was modified; enumeration operation may not execute.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_EnumOpCantHappen">
            <summary>Enumeration has either not started or has already finished.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.InvalidOperation_IComparerFailed">
            <summary>Failed to compare two elements in the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_KeyCollectionSet">
            <summary>Mutating a key collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_ValueCollectionSet">
            <summary>Mutating a value collection derived from a dictionary is not allowed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Rank_MustMatch">
            <summary>The specified arrays must have the same number of dimensions.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.NotSupported_FixedSizeCollection">
            <summary>Collection was of a fixed size.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentException_OtherNotArrayOfCorrectLength">
            <summary>Object is not a array with the same number of elements as the array to compare it to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.Arg_BogusIComparer">
            <summary>Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.CannotFindOldValue">
            <summary>Cannot find the old value</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.Internal.SR.ArgumentOutOfRange_IndexMustBeLessOrEqual">
            <summary>Index was out of range. Must be non-negative and less than or equal to the size of the collection.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},``1,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}},``1)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value and returns the previous
            value.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value if it is currently equal to
            another specified value. Returns the previous value.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Assigns a field or variable containing an immutable list to the specified value if it is has not yet been
            initialized.
            </summary>
            <typeparam name="T">The type of value stored by the list.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},``1,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}},``1)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Assigns a field or variable containing an immutable set to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="T">The type of value stored by the set.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}})">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free,
            as it may run multiple times when races occur with other threads.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.Update``3(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``2,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}},``2)">
            <summary>
            Mutates a value in-place with optimistic locking transaction semantics via a specified transformation
            function. The transformation is retried as many times as necessary to win the optimistic locking race.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument passed to the <paramref name="transformer"/>.</typeparam>
            <param name="location">
            The variable or field to be changed, which may be accessed by multiple threads.
            </param>
            <param name="transformer">
            A function that mutates the value. This function should be side-effect free, as it may run multiple times
            when races occur with other threads.</param>
            <param name="transformerArgument">The argument to pass to <paramref name="transformer"/>.</param>
            <returns>
            <see langword="true"/> if the location's value is changed by applying the result of the
            <paramref name="transformer"/> function; otherwise, <see langword="false"/> if the location's value remained
            the same because the last invocation of <paramref name="transformer"/> returned the existing value.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedExchange``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value and returns the
            previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedCompareExchange``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is currently
            equal to another specified value. Returns the previous value.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <param name="comparand">The value to check equality for before assigning.</param>
            <returns>The prior value at the specified <paramref name="location"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.InterlockedInitialize``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Assigns a field or variable containing an immutable dictionary to the specified value if it is has not yet
            been initialized.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <param name="location">The field or local variable to change.</param>
            <param name="value">The new value to assign.</param>
            <returns><see langword="true"/> if the field was assigned the specified value; otherwise,
            <see langword="false"/> if it was previously initialized.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``3(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``3(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``2,``1},``2)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.GetOrAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.GetOrAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,System.Func{``0,``1},System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.AddOrUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.AddOrUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,System.Func{``0,``1,``1})"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryAdd``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryAdd``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryUpdate``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1,``1)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryUpdate``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1,``1)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked.TryRemove``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}@,``0,``1@)">
            <inheritdoc cref="M:System.Collections.Immutable.ImmutableInterlocked.TryRemove``2(System.Collections.Immutable.ImmutableDictionary{``0,``1}@,``0,``1@)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Clear``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0})">
            <seealso cref="M:System.Array.Clear(System.Array)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Clear``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32,System.Int32)">
            <seealso cref="M:System.Array.Clear(System.Array,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray.Copy``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},Microsoft.CodeAnalysis.Collections.SegmentedArray{``0},System.Int32)">
            <seealso cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1">
            <summary>
            Defines a fixed-size collection with the same API surface and behavior as an "SZArray", which is a
            single-dimensional zero-based array commonly represented in C# as <c>T[]</c>. The implementation of this
            collection uses segmented arrays to avoid placing objects on the Large Object Heap.
            </summary>
            <typeparam name="T">The type of elements stored in the array.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.PrivateMarshal.AsSegments(Microsoft.CodeAnalysis.Collections.SegmentedArray{`0})">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegments``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0})"/>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.SegmentSize">
             <summary>
             The number of elements in each page of the segmented array of type <typeparamref name="T"/>.
             </summary>
             <remarks>
             <para>The segment size is calculated according to <see cref="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1"/>, performs the IL operation
             defined by <see cref="F:System.Reflection.Emit.OpCodes.Sizeof"/>. ECMA-335 defines this operation with the following note:</para>
            
             <para><c>sizeof</c> returns the total size that would be occupied by each element in an array of this type 
             including any padding the implementation chooses to add. Specifically, array elements lie <c>sizeof</c>
             bytes apart.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.SegmentShift">
            <summary>
            The bit shift to apply to an array index to get the page index within <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedArray`1.OffsetMask">
            <summary>
            The bit mask to apply to an array index to get the index within a page of <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedArray`1._items"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal">
            <summary>
            An unsafe class that provides a set of methods to access the underlying data representations of immutable segmented
            collections.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegments``1(Microsoft.CodeAnalysis.Collections.SegmentedArray{``0})">
            <summary>
            Gets the backing storage array for a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/>.
            </summary>
            <typeparam name="T">The type of elements stored in the array.</typeparam>
            <param name="array">The segmented array.</param>
            <returns>The backing storage array for the segmented array. Note that replacing segments within the returned
            value will invalidate the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedArray`1"/> data structure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1},``0)">
            <summary>
            Gets either a ref to a <typeparamref name="TValue"/> in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> or a
            ref null if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary to get the ref to <typeparamref name="TValue"/> from.</param>
            <param name="key">The key used for lookup.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            Items should not be added or removed from the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> while the ref
            <typeparamref name="TValue"/> is in use. The ref null can be detected using <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1},``0)">
            <summary>
            Gets either a read-only ref to a <typeparamref name="TValue"/> in the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>
            or a ref null if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary to get the ref to <typeparamref name="TValue"/> from.</param>
            <param name="key">The key used for lookup.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            The ref null can be detected using <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1}.Builder,``0)">
            <summary>
            Gets either a ref to a <typeparamref name="TValue"/> in the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder"/>
            or a ref null if it does not exist in the <paramref name="dictionary"/>.
            </summary>
            <param name="dictionary">The dictionary to get the ref to <typeparamref name="TValue"/> from.</param>
            <param name="key">The key used for lookup.</param>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            Items should not be added or removed from the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.Builder"/>
            while the ref <typeparamref name="TValue"/> is in use. The ref null can be detected using
            <see cref="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedList``1(Microsoft.CodeAnalysis.Collections.SegmentedList{``0})">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value wrapping the input <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the input segmented list.</typeparam>
            <param name="list">The input segmented list to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value wrapping <paramref name="list"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            list, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value starts
            being used. Doing so might cause undefined behavior in code paths which don't expect the contents of a given
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> values to change after its creation.
            </para>
            <para>
            If <paramref name="list"/> is <see langword="null"/>, the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value
            will be uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsDefault"/> property will be
            <see langword="true"/>).
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedList``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{``0})">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> for an input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value.
            </summary>
            <typeparam name="T">The type of elements in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value.</typeparam>
            <param name="list">The input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value to get the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> for <paramref name="list"/>, if present; otherwise, <see langword="null"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should make sure to not pass the resulting underlying list to methods that
            might mutate it. Doing so might cause undefined behavior in code paths using <paramref name="list"/> which
            don't expect the contents of the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/> value to change.
            </para>
            <para>
            If <paramref name="list"/> is uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1.IsDefault"/> property is
            <see langword="true"/>), the resulting <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1"/> will be <see langword="null"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{``0})">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value wrapping the input <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/>.
            </summary>
            <typeparam name="T">The type of elements in the input segmented hash set.</typeparam>
            <param name="set">The input segmented hash set to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value wrapping <paramref name="set"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            set, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value starts
            being used. Doing so might cause undefined behavior in code paths which don't expect the contents of a given
            <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> values to change after its creation.
            </para>
            <para>
            If <paramref name="set"/> is <see langword="null"/>, the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/>
            value will be uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsDefault"/> property will be
            <see langword="true"/>).
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedHashSet``1(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet{``0})">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> for an input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value.
            </summary>
            <typeparam name="T">The type of elements in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value.</typeparam>
            <param name="set">The input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value to get the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> for <paramref name="set"/>, if present; otherwise, <see langword="null"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should make sure to not pass the resulting underlying hash set to methods that
            might mutate it. Doing so might cause undefined behavior in code paths using <paramref name="set"/> which
            don't expect the contents of the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1"/> value to change.
            </para>
            <para>
            If <paramref name="set"/> is uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1.IsDefault"/>
            property is <see langword="true"/>), the resulting <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> will be <see langword="null"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsImmutableSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1})">
            <summary>
            Gets an <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value wrapping the input <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the input segmented dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the input segmented dictionary.</typeparam>
            <param name="dictionary">The input segmented dictionary to wrap in the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value wrapping <paramref name="dictionary"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should take extra care to ensure that they're the sole owners of the input
            dictionary, and that it won't be modified once the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>
            value starts being used. Doing so might cause undefined behavior in code paths which don't expect the contents
            of a given <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> values to change after its creation.
            </para>
            <para>
            If <paramref name="dictionary"/> is <see langword="null"/>, the returned <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/>
            value will be uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.IsDefault"/>
            property will be <see langword="true"/>).
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.AsSegmentedDictionary``2(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary{``0,``1})">
            <summary>
            Gets the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> for an input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.
            </summary>
            <typeparam name="TKey">The type of keys in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.</typeparam>
            <typeparam name="TValue">The type of values in the input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value.</typeparam>
            <param name="dictionary">The input <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value to get the underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> from.</param>
            <returns>The underlying <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> for <paramref name="dictionary"/>, if present; otherwise, <see langword="null"/>.</returns>
            <remarks>
            <para>
            When using this method, callers should make sure to not pass the resulting underlying dictionary to methods that
            might mutate it. Doing so might cause undefined behavior in code paths using <paramref name="dictionary"/> which
            don't expect the contents of the <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2"/> value to change.
            </para>
            <para>
            If <paramref name="dictionary"/> is uninitialized (i.e. its <see cref="P:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2.IsDefault"/>
            property is <see langword="true"/>), the resulting <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2"/> will be <see langword="null"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2">
            <summary>
            Represents a collection of keys and values.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.Dictionary`2"/>, but
            uses segmented arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.PrivateMarshal">
            <summary>
            Private helper class for use only by <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.PrivateMarshal.FindValue(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{`0,`1},`0)">
            <inheritdoc cref="M:Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal.GetValueRefOrNullRef``2(Microsoft.CodeAnalysis.Collections.SegmentedDictionary{``0,``1},``0)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the dictionary can hold up to 'capacity' entries without any further expansion of its backing storage
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess">
             <summary>
             Sets the capacity of this dictionary to what it would be if it had been originally initialized with all its entries
             </summary>
             <remarks>
             This method can be used to minimize the memory overhead
             once it is known that no new elements will be added.
            
             To allocate minimum size storage array, execute the following statements:
            
             dictionary.Clear();
             dictionary.TrimExcess();
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.TrimExcess(System.Int32)">
            <summary>
            Sets the capacity of this dictionary to hold up 'capacity' entries without any further expansion of its backing storage
            </summary>
            <remarks>
            This method can be used to minimize the memory overhead
            once it is known that no new elements will be added.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.StackAllocThreshold">
            <summary>Cutoff point for stackallocs. This corresponds to the number of ints.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ShrinkThreshold">
            <summary>
            When constructing a hashset from an existing collection, it may contain duplicates,
            so this is used as the max acceptable excess ratio of capacity to count. Note that
            this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
            a lot of adds followed by removes. Users must explicitly shrink by calling TrimExcess.
            This is set to 3 because capacity is acceptable as 2x rounded up to nearest prime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ConstructFrom(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>Initializes the SegmentedHashSet from another SegmentedHashSet with the same element type and equality comparer.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Clear">
            <summary>Removes all elements from the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Contains(`0)">
            <summary>Determines whether the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> contains the specified element.</summary>
            <param name="item">The element to locate in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object contains the specified element; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.FindItemIndex(`0)">
            <summary>Gets the index of the item in <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/>, or -1 if it's not in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.GetBucketRef(System.Int32)">
            <summary>Gets a reference to the specified hashcode's bucket, containing an index into <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/>.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Count">
            <summary>Gets the number of elements that are contained in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Add(`0)">
            <summary>Adds the specified element to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/>.</summary>
            <param name="item">The element to add to the set.</param>
            <returns>true if the element is added to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.TryGetValue(`0,`0@)">
            <summary>Searches the set for a given value and returns the equal value it finds, if any.</summary>
            <param name="equalValue">The value to search for.</param>
            <param name="actualValue">The value from the set that the search found, or the default value of <typeparamref name="T"/> when the search yielded no match.</param>
            <returns>A value indicating whether the search was successful.</returns>
            <remarks>
            This can be useful when you want to reuse a previously stored reference instead of
            a newly constructed one (so that more sharing of references can occur) or to look up
            a value that has more complete data than the value you currently have, although their
            comparer functions indicate they are equal.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain all elements that are present in itself, the specified collection, or both.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain only elements that are present in that object and in the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Modifies the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to contain only elements that are present either in that object or in the specified collection, but not both.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a subset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a subset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper subset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper subset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a superset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of the specified collection.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is a proper superset of <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and a specified collection share common elements.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and <paramref name="other"/> share at least one common element; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</param>
            <returns>true if the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object is equal to <paramref name="other"/>; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the elements of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to an array, starting at the specified array index.</summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> collection.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Comparer">
            <summary>Gets the <see cref="T:System.Collections.IEqualityComparer"/> object that is used to determine equality for the values in the set.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.EnsureCapacity(System.Int32)">
            <summary>Ensures that this hash set can hold the specified number of elements without growing.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.TrimExcess">
            <summary>
            Sets the capacity of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object to the actual number of elements it contains,
            rounded up to a nearby, implementation-specific value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CreateSetComparer">
            <summary>Returns an <see cref="T:System.Collections.IEqualityComparer"/> object that can be used for equality testing of a <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.AddIfNotPresent(`0,System.Int32@)">
            <summary>Adds the specified element to the set if it's not already contained.</summary>
            <param name="value">The element to add to the set.</param>
            <param name="location">The index into <see cref="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1._entries"/> of the element.</param>
            <returns>true if the element is added to the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IsSubsetOfHashSetWithSameComparer(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is
             faster. Simply check that each element in this is in other.
            
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
            
             If callers are concerned about whether this is a proper subset, they take care of that.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWithHashSetWithSameComparer(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster
            because we can use other's Contains
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Iterate over other. If contained in this, mark an element in bit array corresponding to
             its position in _slots. If anything is unmarked (in bit array), remove it.
            
             This attempts to allocate on the stack, if below StackAllocThreshold.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWithUniqueHashSet(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
             <summary>
             if other is a set, we can assume it doesn't have duplicate elements, so use this
             technique: if can't remove, then it wasn't present in this set, so add.
            
             As with other methods, callers take care of ensuring that other is a hashset using the
             same equality comparer.
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
            
             Used for symmetric except when other isn't a SegmentedHashSet. This is more tedious because
             other may contain duplicates. SegmentedHashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: SegmentedHashSet technique would add then
             remove it.
             2. Other has a duplicate that's in this: SegmentedHashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other.
            
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
             <summary>
             Determines counts that can be used to determine equality, subset, and superset. This
             is only used when other is an IEnumerable and not a SegmentedHashSet. If other is a SegmentedHashSet
             these properties can be checked faster without use of marking because we can assume
             other has no duplicates.
            
             The following count checks are performed by callers:
             1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything
             in other is in this and everything in this is in other
             2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
             have elements not in this and everything in this is in other
             3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
             other must have at least one element not in this and everything in this is in other
             4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
             than _count; i.e. everything in other was in this and this had at least one element
             not contained in other.
            
             An earlier implementation used delegates to perform these checks rather than returning
             an ElementCount struct; however this was changed due to the perf overhead of delegates.
             </summary>
             <param name="other"></param>
             <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
             because unfoundCount must be 0.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.EqualityComparersAreEqual(Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0},Microsoft.CodeAnalysis.Collections.SegmentedHashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1.Entry._next">
            <summary>
            0-based index of next entry in chain: -1 means end of chain
            also encodes whether this entry _itself_ is part of the free list by changing sign and subtracting 3,
            so -2 means end of free list, -3 means index 0 but on free list, -4 means index 1 but on free list, etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1">
            <summary>
            Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and
            manipulate lists.
            </summary>
            <remarks>
            <para>This collection has the same performance characteristics as <see cref="T:System.Collections.Generic.List`1"/>, but uses segmented
            arrays to avoid allocations in the Large Object Heap.</para>
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
            If the current capacity of the list is less than specified <paramref name="capacity"/>,
            the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
            <returns>The new capacity of this list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedList`1.Grow(System.Int32)">
            <summary>
            Increase the capacity of this list to at least the specified <paramref name="capacity"/>.
            </summary>
            <param name="capacity">The minimum capacity to ensure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.SegmentedList`1.Slice(System.Int32,System.Int32)">
            <summary>
            Creates a shallow copy of a range of elements in the source <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" />.
            </summary>
            <param name="start">The zero-based <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" /> index at which the range starts.</param>
            <param name="length">The length of the range.</param>
            <returns>A shallow copy of a range of elements in the source <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" />.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start" /> is less than 0.
            -or-
            <paramref name="length" /> is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="start" /> and <paramref name="length" /> do not denote a valid range of elements in the <see cref="T:Microsoft.CodeAnalysis.Collections.SegmentedList`1" />.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsClrInteger(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsBlittable(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is a primitive of a fixed size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsPrimitiveRecursiveStruct(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. System.Int32 contains a field of type System.Int32).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.IsIntegralType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.VBForToShiftBits(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            For signed integer types return number of bits for their representation minus 1. 
            I.e. 7 for Int8, 31 for Int32, etc.
            Used for checking loop end condition for VB for loop.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.CanOptimizeBehavior(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Tells whether a different code path can be taken based on the fact, that a given type is a special type.
            This method is called in places where conditions like <c>specialType != SpecialType.None</c> were previously used.
            The main reason for this method to exist is to prevent such conditions, which introduce silent code changes every time a new special type is added.
            This doesn't mean the checked special type range of this method cannot be modified,
            but rather that each usage of this method needs to be reviewed to make sure everything works as expected in such cases
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SpecialTypeExtensions.ConvertUnderlyingValueToUInt64(Microsoft.CodeAnalysis.SpecialType,System.Object)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``2(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1})">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArrayWithIndex``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DictionaryExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Generic.Dictionary`2"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            If the given key is not found in the dictionary, add it with the given value and return the value.
            Otherwise return the existing value associated with that key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            If the given key is not found in the dictionary, add it with the result of invoking getValue and return the value.
            Otherwise return the existing value associated with that key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RelativePathResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.RelativePathResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FailFast.Handler">
            <summary>
            A pre-created delegate to assign to <see cref="T:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ErrorReporterHandler" /> if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.DumpStackTrace(System.Exception,System.String)">
            <summary>
            Dumps the stack trace of the exception and the handler to the console. This is useful
            for debugging unit tests that hit a fatal exception
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.Assert(System.Boolean,System.String)">
            <summary>
            Checks for the given <paramref name="condition"/>; if the <paramref name="condition"/> is <c>true</c>, 
            immediately terminates the process without running any pending <c>finally</c> blocks or finalizers
            and causes a crash dump to be collected (if the system is configured to do so). 
            Otherwise, the process continues normally.
            </summary>
            <param name="condition">The conditional expression to evaluate.</param>
            <param name="message">An optional message to be recorded in the dump in case of failure. Can be <c>null</c>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackGuard.EnsureSufficientExecutionStack(System.Int32)">
            <summary>
                Ensures that the remaining stack space is large enough to execute
                the average function.
            </summary>
            <param name="recursionDepth">how many times the calling function has recursed</param>
            <exception cref="T:System.InsufficientExecutionStackException">
                The available stack space is insufficient to execute
                the average function.
            </exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions.UsingDirectivePlacement">
            <summary>
            Where to place C# usings relative to namespace declaration, ignored by VB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AddImport.AddImportPlacement">
            <summary>
            Specifies the desired placement of added imports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportPlacement.InsideNamespace">
            <summary>
            Place imports inside the namespace definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImport.AddImportPlacement.OutsideNamespace">
            <summary>
            Place imports outside the namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportsService.HasExistingImport(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxGenerator)">
            <summary>
            Returns true if the tree already has an existing import syntactically equivalent to
            <paramref name="import"/> in scope at <paramref name="contextLocation"/>.  This includes
            global imports for VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImport.IAddImportsService.GetImportContainer(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions)">
            <summary>
            Given a context location in a provided syntax tree, returns the appropriate container
            that <paramref name="import"/> should be added to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions">
            <summary>
            Document-specific options for controlling the code produced by code generation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.CommonDefaults">
            <summary>
            Language agnostic defaults.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1.FindMostRelevantNameSpaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.Location,System.Threading.CancellationToken)">
            <summary>
            Return the most relevant declaration to namespaceOrType,
            it will first search the context node contained within,
            then the declaration in the same file, then non auto-generated file,
            then all the potential location. Return null if no declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext">
            <summary>
            General options for controlling the code produced by the <see cref="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator"/> that apply to all documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.ContextLocation">
            <summary>
            A location used to determine the best place to generate a member.  This is only used for
            determining which part of a partial type to generate in.  If a type only has one part, or
            an API is used that specifies the type, then this is not used.  A part is preferred if
            it surrounds this context location. If no part surrounds this location then a part is
            preferred if it comes from the same SyntaxTree as this location.  If there is no
            such part, then any part may be used for generation.
            
            This option is not necessary if <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AfterThisLocation"/> or <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.BeforeThisLocation"/> are
            provided.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AfterThisLocation">
            <summary>
            A hint to the code generation service to specify where the generated code should be
            placed.  Code will be generated after this location if the location is valid in the type
            or symbol being generated into, and it is possible to generate the code after it.
            
            If this option is provided, neither <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.ContextLocation"/> nor <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.BeforeThisLocation"/> are
            needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.BeforeThisLocation">
            <summary>
            A hint to the code generation service to specify where the generated code should be
            placed.  Code will be generated before this location if the location is valid in the type
            or symbol being generated into, and it is possible to generate the code after it. 
            
            If this option is provided, neither <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.ContextLocation"/> nor <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AfterThisLocation"/> are
            needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AddImports">
            <summary>
            True if the code generation service should add <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.AddImportsAnnotation"/>,
            and when not generating directly into a declaration, should try to automatically add imports to the file
            for any generated code.
            Defaults to true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AdditionalImports">
            <summary>
            Contains additional imports to be automatically added.  This is useful for adding
            imports that are part of a list of statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.GenerateMembers">
            <summary>
            True if members of a symbol should also be generated along with the declaration.  If
            false, only the symbol's declaration will be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.MergeNestedNamespaces">
            <summary>
            True if the code generator should merge namespaces which only contain other namespaces
            into a single declaration with a dotted name.  False if the nesting should be preserved
            and each namespace declaration should be nested and should only have a single non-dotted
            name.
            
            Merging can only occur if the namespace only contains a single member that is also a
            namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.MergeAttributes">
            <summary>
            True if the code generation should put multiple attributes in a single attribute
            declaration, or if should have a separate attribute declaration for each attribute.  For
            example, in C# setting this to True this would produce "[Goo, Bar]" while setting it to
            False would produce "[Goo][Bar]"
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.GenerateDefaultAccessibility">
            <summary>
            True if the code generator should always generate accessibility modifiers, even if they
            are the same as the defaults for that symbol.  For example, a private field in C# does
            not need its accessibility specified as it will be private by default.  However, if this
            option is set to true 'private' will still be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.GenerateMethodBodies">
            <summary>
            True if the code generator should generate empty bodies for methods along with the
            method declaration.  If false, only method declarations will be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.GenerateDocumentationComments">
            <summary>
            True if the code generator should generate documentation comments where available
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AutoInsertionLocation">
            <summary>
            True if the code generator should automatically attempt to choose the appropriate location
            to insert members.  If false and a generation location is not specified by AfterThisLocation,
            or BeforeThisLocation, members will be inserted at the end of the destination definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.SortMembers">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.AutoInsertionLocation"/> is <see langword="false"/>, determines if members will be
            sorted before being added to the end of the list of members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext.ReuseSyntax">
            <summary>
            True if the code generator should attempt to reuse the syntax of the constituent entities, such as members, access modifier tokens, etc. while attempting to generate code.
            If any of the member symbols have zero declaring syntax references (non-source symbols) OR two or more declaring syntax references (partial definitions), then syntax is not reused.
            If false, then the code generator will always synthesize a new syntax node and ignore the declaring syntax references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo">
            <summary>
            Context and preferences.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory">
            <summary>
            Generates symbols that describe declarations to be generated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.IsCodeGenerationSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is purely a code generation symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateEventSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IEventSymbol},System.String,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Creates an event symbol that can be used to describe an event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreatePropertySymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol},System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Boolean)">
            <summary>
            Creates a property symbol that can be used to describe a property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateFieldSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Boolean,System.Object,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field symbol that can be used to describe a field declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConstructorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Boolean)">
            <summary>
            Creates a constructor symbol that can be used to describe a constructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateDestructorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a destructor symbol that can be used to describe a destructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateMethodSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IMethodSymbol},System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.MethodKind,System.Boolean)">
            <summary>
            Creates a method symbol that can be used to describe a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateOperatorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},System.String)">
            <summary>
            Creates a method symbol that can be used to describe an operator declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConversionSymbol(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},System.String)">
            <summary>
            Creates a method symbol that can be used to describe a conversion declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConversionSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},System.String)">
            <summary>
            Creates a method symbol that can be used to describe a conversion declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.RefKind,System.Boolean,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Boolean,System.Boolean,System.Object)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(Microsoft.CodeAnalysis.IParameterSymbol,System.Nullable{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData}},System.Nullable{Microsoft.CodeAnalysis.RefKind},System.Nullable{System.Boolean},Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.Optional{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateTypeParameterSymbol(System.String,System.Int32)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateTypeParameter(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.VarianceKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},Microsoft.CodeAnalysis.NullableAnnotation,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a type parameter symbol that can be used to describe a type parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates a pointer type symbol that can be used to describe a pointer type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32,Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Creates an array type symbol that can be used to describe an array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateAccessorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an method type symbol that can be used to describe an accessor method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateAttributeData(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.TypedConstant}})">
            <summary>
            Create attribute data that can be used in describing an attribute declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamedTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.TypeKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamedTypeSymbol},Microsoft.CodeAnalysis.SpecialType,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.NullableAnnotation,Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Creates a named type symbol that can be used to describe a named type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamedTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Boolean,Microsoft.CodeAnalysis.TypeKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamedTypeSymbol},Microsoft.CodeAnalysis.SpecialType,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.NullableAnnotation,Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Creates a named type symbol that can be used to describe a named type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateDelegateTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Creates a method type symbol that can be used to describe a delegate type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamespaceSymbol(System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.INamespaceOrTypeSymbol})">
            <summary>
            Creates a namespace symbol that can be used to describe a namespace declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator">
            <summary>
            A generator used for creating or modifying member declarations in source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.Annotation">
            <summary>
            Annotation placed on generated syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddEventDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional event of the same signature as the specified event symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddFieldDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IFieldSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional field of the same signature as the specified field symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMethodDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional method of the same signature as the specified method symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddPropertyDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional property of the same signature as the specified property symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional named type of the same signature as the specified named type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional named type of the same signature as the specified named type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamespaceDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional namespace of the same signature as the specified namespace symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamespaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional namespace or type of the same signature as the specified namespace or type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMemberDeclarationsAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has additional members of the same signature as the specified member symbols.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CanAdd(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if additional declarations can be added to the destination symbol's declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created event declaration node from the provided event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateFieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created field declaration node from the provided field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateMethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created method declaration node from the provided method.
            TODO: do not return null (https://github.com/dotnet/roslyn/issues/58243)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreatePropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created property declaration node from the provided property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateNamedTypeDeclaration(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created named type declaration node from the provided named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateNamespaceDeclaration(Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created namespace declaration node from the provided namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddEvent``1(``0,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds an event into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddField``1(``0,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds a field into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMethod``1(``0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds a method into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddProperty``1(``0,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds a property into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedType``1(``0,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespace``1(``0,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMembers``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds members into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddParameters``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds the parameters to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddAttributes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.AttributeData},System.Nullable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds the attributes to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Remove the given attribute from destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.AttributeData,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Remove the given attribute from destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationModifiers``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Update the modifiers list for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationAccessibility``1(``0,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Update the accessibility modifiers for the given declaration node, retaining the trivia of the existing modifiers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationType``1(``0,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Update the type for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationMembers``1(``0,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Replace the existing members with the given newMembers for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddStatements``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo,System.Threading.CancellationToken)">
            <summary>
            Adds the statements to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddEventAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a field with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddFieldAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IFieldSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a field with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMethodAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a method with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddPropertyAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a property with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedTypeAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedTypeAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespaceAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespaceOrTypeAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace or type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMembersAsync(Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},System.Threading.CancellationToken)">
            <summary>
            Adds all the provided members into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.FindMostRelevantNameSpaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.Location,System.Threading.CancellationToken)">
            <summary>
            Return the most relevant declaration to namespaceOrType,
            it will first search the context node contained within,
            then the declaration in the same file, then non auto-generated file,
            then all the potential location. Return null if no declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.LiteralSpecialValues">
            <summary>
            When we are generating literals, we sometimes want to emit code vs. the numeric literal. This class
            gives the constants for all ones we want to convert
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.NullableSyntaxAnnotation">
            <summary>
            Annotation placed on <see cref="T:Microsoft.CodeAnalysis.ITypeSymbol"/>s that the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> converts to a node. This
            information tracks the original nullable state of the symbol and is used by metadata-as-source to determine if
            it needs to add <c>#nullable</c> directives in the file.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGeneration.NullableSyntaxAnnotation.Oblivious">
            <summary>
            For <c>string~</c> types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGeneration.NullableSyntaxAnnotation.AnnotatedOrNotAnnotated">
            <summary>
            For <c>string!</c> or <c>string?</c> types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1">
            <summary>
            Base representation of an editorconfig file that has been parsed
            </summary>
            <typeparam name="T">The kind of options that we expect to encounter in the editorconfig file.</typeparam>
            <param name="FilePath">The full path to the editorconfig file on disk. Optional if not doing pathwise comparisons</param>
            <param name="Options">The set of options that were discovered in the file.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.#ctor(System.String,System.Collections.Immutable.ImmutableArray{`0})">
            <summary>
            Base representation of an editorconfig file that has been parsed
            </summary>
            <typeparam name="T">The kind of options that we expect to encounter in the editorconfig file.</typeparam>
            <param name="FilePath">The full path to the editorconfig file on disk. Optional if not doing pathwise comparisons</param>
            <param name="Options">The set of options that were discovered in the file.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.FilePath">
            <summary>The full path to the editorconfig file on disk. Optional if not doing pathwise comparisons</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.Options">
            <summary>The set of options that were discovered in the file.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.TryGetSectionForLanguage(Microsoft.CodeAnalysis.EditorConfig.Language,Microsoft.CodeAnalysis.EditorConfig.Parsing.Section@)">
            <summary>
            Attempts to find a section of the editorconfig file that is an exact match for the given language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.TryGetSectionForLanguage(Microsoft.CodeAnalysis.EditorConfig.Language,Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch,Microsoft.CodeAnalysis.EditorConfig.Parsing.Section@)">
            <summary>
            Attempts to find a section of the editorconfig file that applies to the given language for the given criteria.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.TryGetSectionForFilePath(System.String,Microsoft.CodeAnalysis.EditorConfig.Parsing.Section@)">
            <summary>
            Attempts to find a section of the editorconfig file that applies to the given file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1.TryGetSectionForFilePath(System.String,Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch,Microsoft.CodeAnalysis.EditorConfig.Parsing.Section@)">
            <summary>
            Attempts to find a section of the editorconfig file that applies to the given file for the given criteria.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption">
            <summary>
            Base option that all editorconfig option inherit from.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption.#ctor(Microsoft.CodeAnalysis.EditorConfig.Parsing.Section,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Base option that all editorconfig option inherit from.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption`1">
            <summary>
            An abstraction over an editorconfig option that reprsents some type <typeparamref name="T"/> and the span in which that option was defined.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption`1.#ctor(Microsoft.CodeAnalysis.EditorConfig.Parsing.Section,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},`0)">
            <summary>
            An abstraction over an editorconfig option that reprsents some type <typeparamref name="T"/> and the span in which that option was defined.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStyles">
            <summary>
            Represents a completed parse of a single editorconfig document
            </summary>
            <param name="FileName">The full file path to the file on disk. Can be null if you never need to compare if a section is valid for pathing reasons</param>
            <param name="Rules">The set of naming style options that were parsed in the file</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStyles.#ctor(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption})">
            <summary>
            Represents a completed parse of a single editorconfig document
            </summary>
            <param name="FileName">The full file path to the file on disk. Can be null if you never need to compare if a section is valid for pathing reasons</param>
            <param name="Rules">The set of naming style options that were parsed in the file</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStyles.FileName">
            <summary>The full file path to the file on disk. Can be null if you never need to compare if a section is valid for pathing reasons</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStyles.Rules">
            <summary>The set of naming style options that were parsed in the file</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStylesParser.Parse(System.String,System.String)">
            <summary>
            Parses a string and returns all discovered naming style options and their locations
            </summary>
            <param name="editorConfigText">The text contents of the editorconfig file.</param>
            <param name="pathToEditorConfigFile">The full path to the editorconfig file on disk.</param>
            <returns>A type that represents all discovered naming style options in the given string.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStylesParser.Parse(Microsoft.CodeAnalysis.Text.SourceText,System.String)">
            <summary>
            Parses a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> and returns all discovered naming style options and their locations
            </summary>
            <param name="editorConfigText">The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> contents of the editorconfig file.</param>
            <param name="pathToEditorConfigFile">The full path to the editorconfig file on disk.</param>
            <returns>A type that represents all discovered naming style options in the given <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption">
            <summary>
            The root naming style option composed of several settings as well as a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>s describing where they were all defined. 
            </summary>
            <param name="Section">The section of the editorconfig file this option applies to.</param>
            <param name="RuleName">The name given to thie option in the file.</param>
            <param name="ApplicableSymbolInfo">The kinds of symbols this option applies to.</param>
            <param name="NamingScheme">The rules about how the specified symbols must be named.</param>
            <param name="Severity">The keve of build error that should be produced when a matching symbol does not meetthe naming requirements.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption.#ctor(Microsoft.CodeAnalysis.EditorConfig.Parsing.Section,Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.String},Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo,Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme,Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            The root naming style option composed of several settings as well as a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>s describing where they were all defined. 
            </summary>
            <param name="Section">The section of the editorconfig file this option applies to.</param>
            <param name="RuleName">The name given to thie option in the file.</param>
            <param name="ApplicableSymbolInfo">The kinds of symbols this option applies to.</param>
            <param name="NamingScheme">The rules about how the specified symbols must be named.</param>
            <param name="Severity">The keve of build error that should be produced when a matching symbol does not meetthe naming requirements.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption.RuleName">
            <summary>The name given to thie option in the file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption.ApplicableSymbolInfo">
            <summary>The kinds of symbols this option applies to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption.NamingScheme">
            <summary>The rules about how the specified symbols must be named.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption.Severity">
            <summary>The keve of build error that should be produced when a matching symbol does not meetthe naming requirements.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo">
            <summary>
            A description of the kinds of symbols a rule should apply to as well as a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>s describing where they were all defined. 
            </summary>
            <param name="OptionName">The name given to thie option in the file.</param>
            <param name="SymbolKinds">The kinds of symbols this option applies to.</param>
            <param name="Accessibilities">The accessibilities of symbols this option applies to.</param>
            <param name="Modifiers">The required modifier that must be present on symbols this option applies to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo.#ctor(Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.String},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SymbolSpecification.SymbolKindOrTypeKind}},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Accessibility}},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SymbolSpecification.ModifierKind}})">
            <summary>
            A description of the kinds of symbols a rule should apply to as well as a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>s describing where they were all defined. 
            </summary>
            <param name="OptionName">The name given to thie option in the file.</param>
            <param name="SymbolKinds">The kinds of symbols this option applies to.</param>
            <param name="Accessibilities">The accessibilities of symbols this option applies to.</param>
            <param name="Modifiers">The required modifier that must be present on symbols this option applies to.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo.OptionName">
            <summary>The name given to thie option in the file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo.SymbolKinds">
            <summary>The kinds of symbols this option applies to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo.Accessibilities">
            <summary>The accessibilities of symbols this option applies to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo.Modifiers">
            <summary>The required modifier that must be present on symbols this option applies to.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme">
            <summary>
            The rules about how the specified symbols must be named as well as a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>s describing where they were all defined. 
            </summary>
            <param name="OptionName">The name given to thie option in the file.</param>
            <param name="Prefix">Required suffix</param>
            <param name="Suffix">Required prefix</param>
            <param name="WordSeparator">Required word separator characters</param>
            <param name="Capitalization">The capitalization scheme</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme.#ctor(Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.String},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.String},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.String},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{System.String},Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption{Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization})">
            <summary>
            The rules about how the specified symbols must be named as well as a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>s describing where they were all defined. 
            </summary>
            <param name="OptionName">The name given to thie option in the file.</param>
            <param name="Prefix">Required suffix</param>
            <param name="Suffix">Required prefix</param>
            <param name="WordSeparator">Required word separator characters</param>
            <param name="Capitalization">The capitalization scheme</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme.OptionName">
            <summary>The name given to thie option in the file.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme.Prefix">
            <summary>Required suffix</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme.Suffix">
            <summary>Required prefix</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme.WordSeparator">
            <summary>Required word separator characters</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme.Capitalization">
            <summary>The capitalization scheme</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.Section.GetHeaderTextForLanguage(Microsoft.CodeAnalysis.EditorConfig.Language)">
            <summary>
            Returns the default section header text for the given language combination
            </summary>
            <param name="language">The language combination to find the default header text for.</param>
            <returns>the default header text.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.Section.SupportsLanguage(Microsoft.CodeAnalysis.EditorConfig.Language,Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch)">
            <summary>
            Checks where this header supports the given language for the given match criteria
            </summary>
            <param name="language">The language to check support for.</param>
            <param name="matchKind">The criteria for which we consider a language a mache the default is <see cref="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.ExactLanguageMatch"/>.</param>
            <returns>If this section is a match for the given language, meaning options can be added here.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EditorConfig.Parsing.Section.SupportsFilePath(System.String,Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch)">
            <summary>
            Checks where this header supports the given file path for the given match criteria
            </summary>
            <param name="codeFilePath">full path to a file</param>
            <param name="matchKind">The criteria for which we consider a language a mache the default is <see cref="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.ExactLanguageMatch"/>.</param>
            <remarks>
            If the section header cannot be parsed because it it invalid this method will always return no match.
            If no file path was given in the operation that produces this section and a relative path comparison is required to check for support this method will return no match.
            </remarks>
            <returns>If this section is a match for the given file, meaning options can be added here.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.ExactLanguageMatch">
            <summary>
            Most exact section match for a language. Will always match all files for the given language.
            </summary>
            <remarks>
            - for C# this is [*.cs]
            - for Visual Basic it is [*.vb].
            - If both language are specified it is [*.{cs,vb}]
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.ExactLanguageMatchWithOthers">
            <summary>
            Exact section match for a language with unknown file patterns. Will always match all files for the given language.
            </summary>
            <remarks>
            An exact match but with some unknown file patterns also matching
            example for C#: [*.{cs,csx}] 
            This will not be the case if only C# was specified and a VB pattern is found
            (or vice versa)
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.AnyLanguageMatch">
            <summary>
            An exact section match for a language with other known language patterns. Will match all files for the given language as well as other known languages.
            </summary>
            <remarks>
            Given this pattern [*.{cs,vb}] for C# this is considered a match (since it matches all C# files).
            Even though it also matches for Visual Basic.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.SupersetFilePatternMatch">
            <summary>
            Matches the file pattern according to the editorconfig specification but is a superset of an exact language match.
            </summary>
            <remarks>
            Patterns such as [*c*] or [*s] would match for C# in this case (being a superset of *.cs)
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.FilePatternMatch">
            <summary>
            Matches the file pattern according to the editorconfig specification but is a supset of an exact language match.
            </summary>
            <remarks>
            Patterns such as [*.Tests.cs] would match for C# if the file being considered is UnitTests.cs
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.SplatMatch">
            <summary>
            Matches [*].
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.GlobalSectionMatch">
            <summary>
            Matched because section is global and therefore always matches.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.AnyButGlobal">
            <summary>
            Matches any valid pattern except for global section.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.Any">
            <summary>
            Matches any valid pattern.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch.NoMatch">
            <summary>
            Section did not match and is not applicable to the file or language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic">
            <summary>
            Represents an error in a embedded language snippet.  The error contains the message to show 
            a user as well as the span of the error.  This span is in actual user character coordinates.
            For example, if the user has the string "...\\p{0}..." then the span of the error would be 
            for the range of characters for '\\p{0}' (even though the regex engine would only see the \\ 
            translated as a virtual char to the single \ character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSeparatedSyntaxNodeList`3.Item(System.Int32)">
            <summary>
            Retrieves only nodes, skipping the separator tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2">
            <summary>
            Root of the embedded language syntax hierarchy.  EmbeddedSyntaxNodes are very similar to 
            Roslyn Red-Nodes in concept, though there are differences for ease of implementation.
            
            Similarities:
            1. Fully representative of the original source.  All source VirtualChars are contained
               in the Regex nodes.
            2. Specific types for Nodes, Tokens and Trivia.
            3. Uniform ways of deconstructing Nodes (i.e. ChildCount + ChildAt).
            
            Differences:
            Note: these differences are not required, and can be changed if felt to be valuable.
            1. No parent pointers.  These have not been needed yet.
            2. No Update methods.  These have not been needed yet.
            3. No direct ways to get Positions/Spans of node/token/trivia.  Instead, that information can
               be acquired from the VirtualChars contained within those constructs.  This does mean that
               an empty node (for example, an empty RegexSequenceNode) effect has no way to simply ascertain
               its location.  So far that hasn't been a problem.
            4. No null nodes.  Haven't been needed so far, and it keeps things extremely simple.  For 
               example where Roslyn might have chosen an optional null child, the Regex hierarchy just
               has multiple nodes.  For example there are distinct nodes to represent the very similar
               {a}   {a,}    {a,b}    constructs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2.WriteTo(System.Text.StringBuilder,System.Boolean,System.Boolean)">
            <summary>
            Writes the node to a stringbuilder.
            </summary>
            <param name="leading">If false, leading trivia will not be added</param>
            <param name="trailing">If false, trailing trivia will not be added</param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer capture,
            then this property would return the actual integer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1.WriteTo(System.Text.StringBuilder,System.Boolean,System.Boolean)">
            <summary>
            Writes the token to a stringbuilder.
            </summary>
            <param name="leading">If false, leading trivia will not be added</param>
            <param name="trailing">If false, trailing trivia will not be added</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1">
            <summary>
            Trivia on an <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1.Diagnostics">
            <summary>
            A place for diagnostics to be stored during parsing.  Not intended to be accessed 
            directly.  These will be collected and aggregated into <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTree`3.Diagnostics"/>
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.IsLegalBraceEscape(System.String,System.Int32,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Returns <see langword="true"/> if the next two characters at <c>tokenText[index]</c> are <c>{{</c> or
            <c>}}</c>.  If so, <paramref name="span"/> will contain the span of those two characters (based on <paramref
            name="tokenText"/> starting at <paramref name="offset"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.TryConvertSimpleDoubleQuoteString(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)">
            <summary>
            Helper to convert simple string literals that escape quotes by doubling them.  This is 
            how normal VB literals and c# verbatim string literals work.
            </summary>
            <param name="startDelimiter">The start characters string.  " in VB and @" in C#</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.ConvertTextAtIndexToRune(System.String,System.Int32,Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar}.Builder,System.Int32)">
            <summary>
            Returns the number of characters to jump forward (either 1 or 2);
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.ITextInfo`1">
            <summary>
            Abstraction to allow generic algorithms to run over a string or <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> without any
            overhead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService">
             <summary>
             Helper service that takes the raw text of a string token and produces the individual
             characters that raw string token represents (i.e. with escapes collapsed).  The difference
             between this and the result from token.ValueText is that for each collapsed character
             returned the original span of text in the original token can be found.  i.e. if you had the
             following in C#:
            
             "G\u006fo"
            
             Then you'd get back:
            
             'G' -> [0, 1) 'o' -> [1, 7) 'o' -> [7, 1)
            
             This allows for embedded language processing that can refer back to the users' original code
             instead of the escaped value we're processing.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService.TryConvertToVirtualChars(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            <para>
            Takes in a string token and return the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s corresponding to each
            char of the tokens <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText"/>.  In other words, for each char
            in ValueText there will be a VirtualChar in the resultant array.  Each VirtualChar will
            specify what char the language considers them to represent, as well as the span of text
            in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that the language created that char from. 
            </para>
            <para>
            For most chars this will be a single character span.  i.e. 'c' -> 'c'.  However, for
            escapes this may be a multi character span.  i.e. 'c' -> '\u0063'
            </para>
            <para>
            If the token is not a string literal token, or the string literal has any diagnostics on
            it, then <see langword="default"/> will be returned.   Additionally, because a
            VirtualChar can only represent a single char, while some escape sequences represent
            multiple chars, <see langword="default"/> will also be returned in those cases. All
            these cases could be relaxed in the future.  But they greatly simplify the
            implementation.
            </para>
            <para>
            If this function succeeds, certain invariants will hold.  First, each character in the
            sequence of characters in <paramref name="token"/>.ValueText will become a single
            VirtualChar in the result array with a matching <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/> property.
            Similarly, each VirtualChar's <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Span"/> will abut each other, and
            the union of all of them will cover the span of the token's <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.Text"/>
            *not* including the start and quotes.
            </para>
            <para>
            In essence the VirtualChar array acts as the information explaining how the <see
            cref="P:Microsoft.CodeAnalysis.SyntaxToken.Text"/> of the token between the quotes maps to each character in the
            token's <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText"/>.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService.TryGetEscapeCharacter(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar,System.Char@)">
            <summary>
            Produces the appropriate escape version of <paramref name="ch"/> to be placed in a
            normal string literal.  For example if <paramref name="ch"/> is the <c>tab</c>
            character, then this would produce <c>t</c> as <c>\t</c> is what would go into a string
            literal.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> provides a uniform view of a language's string token characters regardless if they
            were written raw in source, or are the production of a language escape sequence.  For example, in C#, in a
            normal <c>""</c> string a <c>Tab</c> character can be written either as the raw tab character (value <c>9</c> in
            ASCII),  or as <c>\t</c>.  The format is a single character in the source, while the latter is two characters
            (<c>\</c> and <c>t</c>).  <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> will represent both, providing the raw <see cref="T:System.Char"/>
            value of <c>9</c> as well as what <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> they occupied.
            </summary>
            <remarks>
            A core consumer of this system is the Regex parser.  That parser wants to work over an array of characters,
            however this array of characters is not the same as the array of characters a user types into a string in C# or
            VB. For example In C# someone may write: @"\z".  This should appear to the user the same as if they wrote "\\z"
            and the same as "\\\u007a".  However, as these all have wildly different presentations for the user, there needs
            to be a way to map back the characters it sees ( '\' and 'z' ) back to the  ranges of characters the user wrote.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune">
            <summary>
            The value of this <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> as a <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/> if such a representation is possible.
            <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>s can represent Unicode codepoints that can appear in a <see cref="T:System.String"/> except for
            unpaired surrogates.  If an unpaired high or low surrogate character is present, this value will be <see
            cref="P:System.Text.Rune.ReplacementChar"/>.  The value of this character can be retrieved from
            <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.SurrogateChar"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.SurrogateChar">
            <summary>
            The unpaired high or low surrogate character that was encountered that could not be represented in <see
            cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>.  If <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/> is not <see cref="P:System.Text.Rune.ReplacementChar"/>, this will be <c>0</c>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Span">
            <summary>
            The span of characters in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that represent this <see
            cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Create(System.Text.Rune,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> from the provided <paramref name="rune"/>.  This operation cannot
            fail.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Create(System.Char,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> from an unpaired high or low surrogate character.  This will throw
            if <paramref name="surrogateChar"/> is not actually a surrogate character. The resultant <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>
            value will be <see cref="P:System.Text.Rune.ReplacementChar"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Value">
            <summary>
            Retrieves the scaler value of this character as an <see cref="T:System.Int32"/>.  If this is an unpaired surrogate
            character, this will be the value of that surrogate.  Otherwise, this will be the value of our <see
            cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Rune"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Utf16SequenceLength">
            <inheritdoc cref="P:System.Text.Rune.Utf16SequenceLength" />
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence">
            <summary>
            Represents the individual characters that raw string token represents (i.e. with escapes collapsed).  
            The difference between this and the result from token.ValueText is that for each collapsed character
            returned the original span of text in the original token can be found.  i.e. if you had the
            following in C#:
            <para/>
            <c>"G\u006fo"</c>
            <para/>
            Then you'd get back:
            <para/>
            <c>'G' -> [0, 1) 'o' -> [1, 7) 'o' -> [7, 1)</c>
            <para/>
            This allows for embedded language processing that can refer back to the user's original code
            instead of the escaped value we're processing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk">
            <summary>
            Abstraction over a contiguous chunk of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s.  This
            is used so we can expose <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s over an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            or over a <see cref="T:System.String"/>.  The latter is especially useful for reducing
            memory usage in common cases of string tokens without escapes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.ImmutableSegmentedListChunk">
            <summary>
            Thin wrapper over an actual <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/>.
            This will be the common construct we generate when getting the
            <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> for a string token that has escapes in it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.ImmutableSegmentedListChunk.#ctor(Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar})">
            <summary>
            Thin wrapper over an actual <see cref="T:Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1"/>.
            This will be the common construct we generate when getting the
            <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> for a string token that has escapes in it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.StringChunk">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> on top of a normal
            string.  This is the common case of the type of the sequence we would
            create for a normal string token without any escapes in it.
            </summary>
            <param name="data">
            The underlying string that we're returning virtual chars from.  Note:
            this will commonly include things like quote characters.  Clients who
            do not want that should then ask for an appropriate <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.GetSubSequence(Microsoft.CodeAnalysis.Text.TextSpan)"/>
            back that does not include those characters.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.StringChunk.#ctor(System.Int32,System.String)">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> on top of a normal
            string.  This is the common case of the type of the sequence we would
            create for a normal string token without any escapes in it.
            </summary>
            <param name="data">
            The underlying string that we're returning virtual chars from.  Note:
            this will commonly include things like quote characters.  Clients who
            do not want that should then ask for an appropriate <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.GetSubSequence(Microsoft.CodeAnalysis.Text.TextSpan)"/>
            back that does not include those characters.
            </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._leafCharacters">
            <summary>
            The actual characters that this <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/> is a portion of.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._span">
            <summary>
            The portion of <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._leafCharacters"/> that is being exposed.  This span 
            is `[inclusive, exclusive)`.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Length">
            <summary>
            Gets the number of elements contained in the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> at the specified index.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.IsDefault">
            <summary>
            Gets a value indicating whether the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/> was declared but not initialized.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.GetSubSequence(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Retreives a sub-sequence from this <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Find(System.Int32)">
            <summary>
            Finds the virtual char in this sequence that contains the position.  Will return null if this position is not
            in the span of this sequence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.CreateString">
            <summary>
            Create a <see cref="T:System.String"/> from the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.FromBounds(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence)">
            <summary>
            Combines two <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>s, producing a final
            sequence that points at the same underlying data, but spans from the 
            start of <paramref name="chars1"/> to the end of <paramref name="chars2"/>.
            </summary>  
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeLocation(Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext,Microsoft.CodeAnalysis.Location)">
            <summary>
            Returns true if the given <paramref name="location"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="location"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeLocation(Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext,Microsoft.CodeAnalysis.Location)">
            <summary>
            Returns true if the given <paramref name="location"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="location"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire file)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalFileAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan``1(Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0},Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.ShouldAnalyzeSpan(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the given <paramref name="span"/> should be analyzed for the given <paramref name="context"/>,
            i.e. either of the following is true:
             - <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.FilterSpan"/> is <see langword="null"/> (we are analyzing the entire tree)
             OR
             - <paramref name="span"/> intersects with <see cref="P:Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext.FilterSpan"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            NOTE: This method expects <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.FilterTree"/>
            and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolStartAnalysisContext.FilterSpan"/> to be non-null. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            NOTE: This method expects <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.FilterTree"/>
            and <see cref="P:Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext.FilterSpan"/> to be non-null. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext,Microsoft.CodeAnalysis.IOperation,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext,Microsoft.CodeAnalysis.IOperation,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot``1(Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0},System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AnalysisContextExtensions.GetAnalysisRoot(Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext,System.Boolean,System.Boolean)">
            <summary>
            Gets the root node in the analysis span for the given <paramref name="context"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Indentation.AbstractIndentation`1.ShouldUseTokenIndenter(Microsoft.CodeAnalysis.Indentation.AbstractIndentation{`0}.Indenter,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            Returns <see langword="true"/> if the language specific <see
            cref="T:Microsoft.CodeAnalysis.Indentation.ISmartTokenFormatter"/> should be deferred to figure out indentation.  If so, it
            will be asked to <see cref="M:Microsoft.CodeAnalysis.Indentation.ISmartTokenFormatter.FormatToken(Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)"/> the resultant
            <paramref name="token"/> provided by this method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Indentation.IndentationResult">
            <summary>
            An indentation result represents where the indent should be placed.  It conveys this through
            a pair of values.  A position in the existing document where the indent should be relative,
            and the number of columns after that the indent should be placed at.  
            
            This pairing provides flexibility to the implementor to compute the indentation results in
            a variety of ways.  For example, one implementation may wish to express indentation of a 
            newline as being four columns past the start of the first token on a previous line.  Another
            may wish to simply express the indentation as an absolute amount from the start of the 
            current line.  With this tuple, both forms can be expressed, and the implementor does not
            have to convert from one to the other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Indentation.IndentationResult.#ctor(System.Int32,System.Int32)">
            <summary>
            An indentation result represents where the indent should be placed.  It conveys this through
            a pair of values.  A position in the existing document where the indent should be relative,
            and the number of columns after that the indent should be placed at.  
            
            This pairing provides flexibility to the implementor to compute the indentation results in
            a variety of ways.  For example, one implementation may wish to express indentation of a 
            newline as being four columns past the start of the first token on a previous line.  Another
            may wish to simply express the indentation as an absolute amount from the start of the 
            current line.  With this tuple, both forms can be expressed, and the implementor does not
            have to convert from one to the other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Indentation.IndentationResult.BasePosition">
            <summary>
            The base position in the document that the indent should be relative to.  This position
            can occur on any line (including the current line, or a previous line).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Indentation.IndentationResult.Offset">
            <summary>
            The number of columns the indent should be at relative to the BasePosition's column.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Indentation.IIndentationService.GetIndentation(Microsoft.CodeAnalysis.ParsedDocument,System.Int32,Microsoft.CodeAnalysis.Indentation.IndentationOptions,System.Threading.CancellationToken)">
            <summary>
            Determines the desired indentation of a given line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Indentation.IIndentationServiceExtensions.GetPreferredIndentation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.ParsedDocument,Microsoft.CodeAnalysis.Indentation.IndentationOptions,System.Threading.CancellationToken)">
            <summary>
            Get's the preferred indentation for <paramref name="token"/> if that token were on its own line.  This
            effectively simulates where the token would be if the user hit enter at the start of the token.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextEncodingKind">
            <summary>
            Well known encodings. Used to distinguish serialized encodings with BOM and without BOM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetPrecedenceKind(System.Int32)">
            <summary>
            Returns the precedence of the given expression, mapped down to one of the 
            <see cref="T:Microsoft.CodeAnalysis.Precedence.PrecedenceKind"/> values.  The mapping is language specific.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetOperatorPrecedence(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the precedence of this expression in a scale specific to a particular
            language.  These values cannot be compared across languages, but relates the 
            precedence of expressions in the same language.  A smaller value means lower
            precedence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.CustomDataFlowAnalysis`1.Run(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer{`0},System.Threading.CancellationToken)">
            <summary>
            Runs dataflow analysis for the given <paramref name="analyzer"/> on the given <paramref name="controlFlowGraph"/>.
            </summary>
            <param name="controlFlowGraph">Control flow graph on which to execute analysis.</param>
            <param name="analyzer">Dataflow analyzer.</param>
            <returns>Block analysis data at the end of the exit block.</returns>
            <remarks>
            Algorithm for this CFG walker has been forked from <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder"/>'s internal
            implementation for basic block reachability computation: "MarkReachableBlocks",
            we should keep them in sync as much as possible.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1">
            <summary>
            Analyzer to execute custom dataflow analysis on a control flow graph.
            </summary>
            <typeparam name="TBlockAnalysisData">Custom data tracked for each basic block with values at start of the block.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.GetCurrentAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock)">
            <summary>
            Gets current analysis data for the given basic block, or an empty analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.GetEmptyAnalysisData">
            <summary>
            Gets empty analysis data for first analysis pass on a basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.SetCurrentAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Updates the current analysis data for the given basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeBlock(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,System.Threading.CancellationToken)">
            <summary>
            Analyze the given basic block and return the block analysis data at the end of the block for its successors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeNonConditionalBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Analyze the non-conditional fallthrough successor branch for the given basic block
            and return the block analysis data for the branch destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeConditionalBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Analyze the given conditional branch for the given basic block and return the
            block analysis data for the branch destinations for the fallthrough and
            conditional successor branches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.Merge(`0,`0,System.Threading.CancellationToken)">
            <summary>
            Merge the given block analysis data instances to produce the resultant merge data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.IsEqual(`0,`0)">
            <summary>
            Returns true if both the given block analysis data instances should be considered equivalent by analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeUnreachableBlocks">
            <summary>
            Flag indicating if the dataflow analysis should run on unreachable blocks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind">
            <summary>
            Indicates the kind of flow capture in an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.RValueCapture">
            <summary>
            Indicates an R-Value flow capture, i.e. capture of a symbol's value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.LValueCapture">
            <summary>
            Indicates an L-Value flow capture, i.e. captures of a symbol's location/address.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.LValueAndRValueCapture">
            <summary>
            Indicates both an R-Value and an L-Value flow capture, i.e. captures of a symbol's value and location/address.
            These are generated for left of a compound assignment operation, such that there is conditional code on the right side of the compound assignment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.LValueFlowCapturesProvider">
            <summary>
            Helper class to detect <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>s that are l-value captures.
            L-value captures are essentially captures of a symbol's location/address.
            Corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation"/>s which share the same
            <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId"/> as this flow capture, dereferences and writes to this location
            subsequently in the flow graph.
            For example, consider the below code:
                a[i] = x ?? a[j];
            The control flow graph contains an initial flow capture of "a[i]" to capture the l-value
            of this array element:
                FC0 (a[i])
            Then it evaluates the right hand side, which can have different
            values on different control flow paths, and the resultant value is then written
            to the captured location:
                FCR0 = result
            </summary>
            <remarks>
            NOTE: This type is a workaround for https://github.com/dotnet/roslyn/issues/31007
            and it can be deleted once that feature is implemented.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis">
            <summary>
            Analysis to compute all the symbol writes for local and parameter
            symbols in an executable code block, along with the information of whether or not the definition
            may be read on some control flow path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData">
            <summary>
            Core analysis data to drive the operation <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Walker"/>
            for operation tree based analysis OR control flow graph based analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData._allocatedBasicBlockAnalysisDatas">
            <summary>
            Pooled <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData"/> allocated during analysis with the
            current <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData"/> instance, which will be freed during <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.Dispose"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData._referenceTakenSymbolsBuilder">
            <summary>
            Set of locals/parameters which are passed by reference to other method calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.SymbolsWriteBuilder">
            <summary>
            Map from each (symbol, write) to a boolean indicating if the value assigned
            at the write is read on some control flow path.
            For example, consider the following code:
            <code>
                int x = 0;
                x = 1;
                Console.WriteLine(x);
            </code>
            This map will have two entries for 'x':
                1. Key = (symbol: x, write: 'int x = 0')
                   Value = 'false', because value assigned to 'x' here **is never** read. 
                2. Key = (symbol: x, write: 'x = 1')
                   Value = 'true', because value assigned to 'x' here **may be** read on
                   some control flow path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.SymbolsReadBuilder">
            <summary>
            Set of locals/parameters that are read at least once.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.LambdaOrLocalFunctionsBeingAnalyzed">
            <summary>
            Set of lambda/local functions whose invocations are currently being analyzed to prevent
            infinite recursion for analyzing code with recursive lambda/local function calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.CurrentBlockAnalysisData">
            <summary>
            Current block analysis data used for analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.AdditionalConditionalBranchAnalysisData">
            <summary>
            Block analysis data used for an additional conditional branch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.ToResult">
            <summary>
            Creates an immutable <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult"/> for the current analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.ResetState">
            <summary>
            Resets all the currently tracked symbol writes to be conservatively marked as read.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData">
            <summary>
            Analysis data for a particular <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/> for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>
            based dataflow analysis OR for the entire executable code block for high level operation
            tree based analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData._reachingWrites">
            <summary>
            Map from each symbol to possible set of reachable write operations that are live at current program point.
            A write is live if there is no intermediate write operation that overwrites it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.ForEachCurrentWrite``1(Microsoft.CodeAnalysis.ISymbol,System.Action{Microsoft.CodeAnalysis.IOperation,``0},``0)">
            <summary>
            Gets the currently reachable writes for the given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.OnWriteReferenceFound(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IOperation,System.Boolean)">
            <summary>
            Marks the given symbol write as a new unread write operation,
            potentially clearing out the prior write operations if <paramref name="maybeWritten"/> is <code>false</code>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.SetEquals``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.HashSet{``0})">
            <summary>
            Same as <see cref="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/>, except this avoids allocations by
            enumerating the set directly with a no-alloc enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Run(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Runs dataflow analysis on the given control flow graph to compute symbol usage results
            for symbol read/writes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Run(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Runs a fast, non-precise operation tree based analysis to compute symbol usage results
            for symbol read/writes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer">
            <summary>
            Dataflow analysis to compute symbol usage information (i.e. reads/writes) for locals/parameters
            in a given control flow graph, along with the information of whether or not the writes
            may be read on some control flow path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._analysisDataByBasicBlockMap">
            <summary>
            Map from basic block to current <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData"/> for dataflow analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._analyzeLocalFunctionOrLambdaInvocation">
            <summary>
            Callback to analyze lambda/local function invocations and return new block analysis data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._lValueFlowCapturesMap">
            <summary>
            Map from flow capture ID to set of captured symbol addresses along all possible control flow paths.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._reachingDelegateCreationTargets">
            <summary>
            Map from operations to potential delegate creation targets that could be invoked via delegate invocation
            on the operation.
            Used to analyze delegate creations/invocations of lambdas and local/functions defined in a method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._localFunctionTargetsToAccessingCfgMap">
            <summary>
            Map from local functions to the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.ControlFlowGraph"/> where the local function was accessed
            to create an invocable delegate. This control flow graph is required to lazily get or create the
            control flow graph for this local function at delegate invocation callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._lambdaTargetsToAccessingCfgMap">
            <summary>
            Map from lambdas to the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.ControlFlowGraph"/> where the lambda was defined
            to create an invocable delegate. This control flow graph is required to lazily get or create the
            control flow graph for this lambda at delegate invocation callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._symbolWritesInsideBlockRangeMap">
            <summary>
            Map from basic block range to set of writes within this block range.
            Used for try-catch-finally analysis, where start of catch/finally blocks should
            consider all writes in the corresponding try block as reachable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.LValueFlowCapturesInGraph">
            <summary>
            Flow captures for l-value or address captures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.GetCapturedLocals(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.HandleCatchOrFilterOrFinallyInitialization(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,System.Threading.CancellationToken)">
            <summary>
            Special handling to ensure that at start of catch/filter/finally region analysis,
            we mark all symbol writes from the corresponding try region as reachable in the
            catch/filter/finally region.
            </summary>
            <param name="basicBlock"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Walker">
            <summary>
            Operations walker used for walking high-level operation tree
            as well as control flow graph based operations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.SymbolWritesMap">
            <summary>
            Map from each symbol write to a boolean indicating if the value assinged
            at write is used/read on some control flow path.
            For example, consider the following code:
            <code>
                int x = 0;
                x = 1;
                Console.WriteLine(x);
            </code>
            This map will have two entries for 'x':
                1. Key = (symbol: x, write: 'int x = 0')
                   Value = 'false', because value assigned to 'x' here **is never** read. 
                2. Key = (symbol: x, write: 'x = 1')
                   Value = 'true', because value assigned to 'x' here **may be** read on
                   some control flow path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.SymbolsRead">
            <summary>
            Set of locals/parameters that are read at least once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.GetUnreadSymbolWrites">
            <summary>
            Gets symbol writes that have are never read.
            WriteOperation will be null for the initial value write to parameter symbols from the callsite.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.IsInitialParameterValueUsed(Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            Returns true if the initial value of the parameter from the caller is used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.GetSymbolWriteCount(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the write count for a given local/parameter symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKey">
            <summary>
            <para>
            A <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> is a lightweight identifier for a symbol that can be used to 
            resolve the "same" symbol across compilations.  Different symbols have different concepts 
            of "same-ness". Same-ness is recursively defined as follows:
            <list type="number">
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IArrayTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementType"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>s are the "same" if 
                    they have equal <see cref="P:Microsoft.CodeAnalysis.IAssemblySymbol.Identity"/>.Name</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IEventSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.Arity"/>, 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments"/>, and have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.Type"/>s and  
                    equal <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>s.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingAssembly"/>.
                    <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/> is not used because module identity is not important in practice.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.
                If the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/> is the global namespace for a
                compilation, then it will only match another
                global namespace of another compilation.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IParameterSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IPointerTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/>s are the "same" if they have 
                    the "same" the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/>, 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>, and have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.Type"/>s and  
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>s.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.ITypeParameterSymbol"/> are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IFieldSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
            </list>
            </para>
            <para>
            Interior-method-level symbols (i.e. <see cref="T:Microsoft.CodeAnalysis.ILabelSymbol"/>, <see cref="T:Microsoft.CodeAnalysis.ILocalSymbol"/>, <see
            cref="T:Microsoft.CodeAnalysis.IRangeVariableSymbol"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s can also
            be represented and restored in a different compilation.  To resolve these the destination compilation's <see
            cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> is enumerated to list all the symbols with the same <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/> and <see
            cref="P:Microsoft.CodeAnalysis.ISymbol.Kind"/> as the original symbol.  The symbol with the same index in the destination tree as the
            symbol in the original tree is returned.  This allows these sorts of symbols to be resolved in a way that is
            resilient to basic forms of edits.  For example, adding whitespace edits, or adding removing symbols with
            different names and types.  However, it may not find a matching symbol in the face of other sorts of edits.
            </para>
            <para>
            Symbol keys cannot be created for interior-method symbols that were created in a speculative semantic model.
            </para>
            <para>
                Due to issues arising from errors and ambiguity, it's possible for a SymbolKey to resolve to
                multiple symbols. For example, in the following type:
                <code>
                class C
                {
                   int M();
                   bool M();
                }
                </code>
                The SymbolKey for both 'M' methods will be the same.  The SymbolKey will then resolve to both methods.
            </para>
            <para>
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s are not guaranteed to work across different versions of Roslyn. They can be persisted
            in their <see cref="M:Microsoft.CodeAnalysis.SymbolKey.ToString"/> form and used across sessions with the same version of Roslyn. However, future
            versions may change the encoded format and may no longer be able to <see cref="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)"/> previous keys.  As
            such, only persist if using for a cache that can be regenerated if necessary.
            </para>
            <para>
            The string values produced by <see cref="M:Microsoft.CodeAnalysis.SymbolKey.CreateString(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)"/> (or <see cref="M:Microsoft.CodeAnalysis.SymbolKey.ToString"/>) should not be
            directly compared for equality or used in hashing scenarios.  Specifically, two symbol keys which represent the
            'same' symbol might produce different strings.  Instead, to compare keys use <see cref="M:Microsoft.CodeAnalysis.SymbolKey.GetComparer(System.Boolean,System.Boolean)"/>
            to get a suitable comparer that exposes the desired semantics.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKey.AnonymousFunctionOrDelegateSymbolKey">
            <summary>
            Anonymous functions and anonymous-delegates (the special VB synthesized delegate types),
            only come into existence when someone has explicitly written a lambda in their source 
            code. So to appropriately round-trip this symbol we store the location that the lambda
            was at so that we can find the symbol again when we resolve the key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.#ctor(System.String)">
            <summary>
            <para>
            A <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> is a lightweight identifier for a symbol that can be used to 
            resolve the "same" symbol across compilations.  Different symbols have different concepts 
            of "same-ness". Same-ness is recursively defined as follows:
            <list type="number">
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IArrayTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementType"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>s are the "same" if 
                    they have equal <see cref="P:Microsoft.CodeAnalysis.IAssemblySymbol.Identity"/>.Name</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IEventSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.Arity"/>, 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments"/>, and have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.Type"/>s and  
                    equal <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>s.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingAssembly"/>.
                    <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/> is not used because module identity is not important in practice.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.
                If the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/> is the global namespace for a
                compilation, then it will only match another
                global namespace of another compilation.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IParameterSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IPointerTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/>s are the "same" if they have 
                    the "same" the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/>, 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>, and have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.Type"/>s and  
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>s.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.ITypeParameterSymbol"/> are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IFieldSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
            </list>
            </para>
            <para>
            Interior-method-level symbols (i.e. <see cref="T:Microsoft.CodeAnalysis.ILabelSymbol"/>, <see cref="T:Microsoft.CodeAnalysis.ILocalSymbol"/>, <see
            cref="T:Microsoft.CodeAnalysis.IRangeVariableSymbol"/> and <see cref="F:Microsoft.CodeAnalysis.MethodKind.LocalFunction"/> <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s can also
            be represented and restored in a different compilation.  To resolve these the destination compilation's <see
            cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> is enumerated to list all the symbols with the same <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/> and <see
            cref="P:Microsoft.CodeAnalysis.ISymbol.Kind"/> as the original symbol.  The symbol with the same index in the destination tree as the
            symbol in the original tree is returned.  This allows these sorts of symbols to be resolved in a way that is
            resilient to basic forms of edits.  For example, adding whitespace edits, or adding removing symbols with
            different names and types.  However, it may not find a matching symbol in the face of other sorts of edits.
            </para>
            <para>
            Symbol keys cannot be created for interior-method symbols that were created in a speculative semantic model.
            </para>
            <para>
                Due to issues arising from errors and ambiguity, it's possible for a SymbolKey to resolve to
                multiple symbols. For example, in the following type:
                <code>
                class C
                {
                   int M();
                   bool M();
                }
                </code>
                The SymbolKey for both 'M' methods will be the same.  The SymbolKey will then resolve to both methods.
            </para>
            <para>
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s are not guaranteed to work across different versions of Roslyn. They can be persisted
            in their <see cref="M:Microsoft.CodeAnalysis.SymbolKey.ToString"/> form and used across sessions with the same version of Roslyn. However, future
            versions may change the encoded format and may no longer be able to <see cref="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)"/> previous keys.  As
            such, only persist if using for a cache that can be regenerated if necessary.
            </para>
            <para>
            The string values produced by <see cref="M:Microsoft.CodeAnalysis.SymbolKey.CreateString(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)"/> (or <see cref="M:Microsoft.CodeAnalysis.SymbolKey.ToString"/>) should not be
            directly compared for equality or used in hashing scenarios.  Specifically, two symbol keys which represent the
            'same' symbol might produce different strings.  Instead, to compare keys use <see cref="M:Microsoft.CodeAnalysis.SymbolKey.GetComparer(System.Boolean,System.Boolean)"/>
            to get a suitable comparer that exposes the desired semantics.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKey.FormatVersion">
            <summary>
            Current format version.  Any time we change anything about our format, we should
            change this.  This will help us detect and reject any cases where a person serializes
            out a SymbolKey from a previous version of Roslyn and then attempt to use it in a 
            newer version where the encoding has changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.Create(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Constructs a new <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> representing the provided <paramref name="symbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.GetComparer(System.Boolean,System.Boolean)">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> that determines if two <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s
            represent the same effective symbol.
            </summary>
            <param name="ignoreCase">Whether or not casing should be considered when comparing keys. 
            For example, with <c>ignoreCase=true</c> then <c>X.SomeClass</c> and <c>X.Someclass</c> would be 
            considered the same effective symbol</param>
            <param name="ignoreAssemblyKeys">Whether or not the originating assembly of referenced
            symbols should be compared when determining if two symbols are effectively the same.
            For example, with <c>ignoreAssemblyKeys=true</c> then an <c>X.SomeClass</c> from assembly 
            <c>A</c> and <c>X.SomeClass</c> from assembly <c>B</c> will be considered the same
            effective symbol.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Tries to resolve this <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> in the given 
            <paramref name="compilation"/> to a matching symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.ToString">
            <summary>
            Returns this <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> encoded as a string.  This can be persisted
            and used later with <see cref="M:Microsoft.CodeAnalysis.SymbolKey.#ctor(System.String)"/> to then try to resolve back
            to the corresponding <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> in a future <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            
            This string form is not guaranteed to be reusable across all future versions of 
            Roslyn.  As such it should only be used for caching data, with the knowledge that
            the data may need to be recomputed if the cached data can no longer be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.ErrorTypeSymbolKey.GetContainingNamespaceNamesInReverse(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            For a symbol like <c>System.Collections.Generic.IEnumerable</c>, this would produce <c>"Generic",
            "Collections", "System"</c>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.SymbolKeyReader.ReadSymbolKeyArray``2(``0,System.Func{``0,System.Int32,Microsoft.CodeAnalysis.ISymbol},System.String@)">
            <summary>
            Reads an array of symbols out from the key.  Note: the number of symbols returned will either be the
            same as the original amount written, or <c>default</c> will be returned. It will never be less or more.
            <c>default</c> will be returned if any elements could not be resolved to the requested <typeparamref
            name="TSymbol"/> type in the provided <see cref="P:Microsoft.CodeAnalysis.SymbolKey.SymbolKeyReader.Compilation"/>.
            <para>
            Callers should <see cref="M:System.IDisposable.Dispose"/> the instance returned.  No check is necessary if
            <c>default</c> was returned before calling <see cref="M:System.IDisposable.Dispose"/>
            </para>
            </summary>
            <remarks>
            If <c>default</c> is returned then <paramref name="failureReason"/> will be non-null.  Similarly, if
            <paramref name="failureReason"/> is non-null, then only <c>default</c> will be returned.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.SymbolKeyWriter.WriteSymbolKeyArray``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Writes out the provided symbols to the key.  The array provided must not
            be <c>default</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKeyResolution">
            <summary>
            The result of <see cref="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Threading.CancellationToken)"/>. If the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> could be uniquely mapped to a
            single <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> then that will be returned in <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.Symbol"/>.  Otherwise, if the key resolves
            to multiple symbols (which can happen in error scenarios), then <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.CandidateSymbols"/> and <see
            cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.CandidateReason"/> will be returned.
            
            If no symbol can be found <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.Symbol"/> will be <c>null</c> and <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.CandidateSymbols"/>
            will be empty.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PublicContract">
            <summary>
            Helpers used for public API argument validation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PublicContract.ToBoxedImmutableArrayWithNonNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Use to validate public API input for properties that are exposed as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PublicContract.ToBoxedImmutableArrayWithDistinctNonNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Use to validate public API input for properties that are exposed as <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> and 
            whose items should be unique.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SerializableBytes">
            <summary>
            Helpers to create temporary streams backed by pooled memory
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SerializableBytes.ReadWriteStream.SetLength(System.Int64,System.Boolean)">
            <summary>
            Sets the length of this stream (see <see cref="M:Microsoft.CodeAnalysis.SerializableBytes.ReadWriteStream.SetLength(System.Int64)"/>.  If <paramref name="truncate"/> is <see
            langword="false"/>, the internal buffers will be left as is, and the data in them will be left as garbage.
            If it is <see langword="true"/> then any fully unused chunks will be discarded.  If there is a final chunk
            the stream is partway through, the remainder of that chunk will be zeroed out.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WeakEvent`1">
            <summary>
            Implements an event that can be subscribed to without keeping the subscriber alive for the lifespan of 
            the object that declares <see cref="T:Microsoft.CodeAnalysis.WeakEvent`1"/>.
            
            Unlike handler created via <see cref="M:Roslyn.Utilities.EventHandlerFactory`1.CreateWeakHandler``1(``0,System.Action{``0,System.Object,`0})"/> the handlers may capture state, which makes the subscribers simpler
            and doesn't risk accidental leaks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.WeakEvent`1.#ctor">
            <summary>
            Implements an event that can be subscribed to without keeping the subscriber alive for the lifespan of 
            the object that declares <see cref="T:Microsoft.CodeAnalysis.WeakEvent`1"/>.
            
            Unlike handler created via <see cref="M:Roslyn.Utilities.EventHandlerFactory`1.CreateWeakHandler``1(``0,System.Action{``0,System.Object,`0})"/> the handlers may capture state, which makes the subscribers simpler
            and doesn't risk accidental leaks.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WeakEvent`1._handlers">
            <summary>
            Each registered event handler has the lifetime of an associated owning object. This table ensures the weak
            references to the event handlers are not cleaned up while the owning object is still alive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.GetValueUsageInfo(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.ValueUsageInfo"/> for the given operation.
            This extension can be removed once https://github.com/dotnet/roslyn/issues/25057 is implemented.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.IsAnyCompoundAssignment(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns true if the given operation is a regular compound assignment,
            i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/> such as <code>a += b</code>,
            or a special null coalescing compound assignment, i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation"/>
            such as <code>a ??= b</code>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.WalkDownConversion(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Walks down consecutive conversion operations until an operand is reached that isn't a conversion operation.
            </summary>
            <param name="operation">The starting operation.</param>
            <returns>The inner non conversion operation or the starting operation if it wasn't a conversion operation.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolUsageInfo">
            <summary>
            Provides information about the way a particular symbol is being used at a symbol reference node.
            For namespaces and types, this corresponds to values from <see cref="T:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo"/>.
            For methods, fields, properties, events, locals and parameters, this corresponds to values from <see cref="T:Microsoft.CodeAnalysis.ValueUsageInfo"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Qualified">
            <summary>
            Represents a reference to a namespace or type on the left side of a dotted name (qualified name or member access).
            For example, 'NS' in <code>NS.Type x = new NS.Type();</code> or <code>NS.Type.StaticMethod();</code> or 
            'Type' in <code>Type.NestedType x = new Type.NestedType();</code> or <code>Type.StaticMethod();</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.TypeArgument">
            <summary>
            Represents a generic type argument reference.
            For example, 'Type' in <code>Generic{Type} x = ...;</code> or <code>class Derived : Base{Type} { }</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.TypeConstraint">
            <summary>
            Represents a type parameter constraint that is a type.
            For example, 'Type' in <code>class Derived{T} where T : Type { }</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Base">
            <summary>
            Represents a base type or interface reference in the base list of a named type.
            For example, 'Base' in <code>class Derived : Base { }</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.ObjectCreation">
            <summary>
            Represents a reference to a type whose instance is being created.
            For example, 'C' in <code>var x = new C();</code>, where 'C' is a named type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Import">
            <summary>
            Represents a reference to a namespace or type within a using or imports directive.
            For example, <code>using NS;</code> or <code>using static NS.Extensions</code> or <code>using Alias = MyType</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.NamespaceDeclaration">
            <summary>
            Represents a reference to a namespace name in a namespace declaration context.
            For example, 'N1' or <code>namespaces N1.N2 { }</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Read">
            <summary>
            Represents a value read.
            For example, reading the value of a local/field/parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Write">
            <summary>
            Represents a value write.
            For example, assigning a value to a local/field/parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Reference">
            <summary>
            Represents a reference being taken for the symbol.
            For example, passing an argument to an "in", "ref" or "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Name">
            <summary>
            Represents a name-only reference that neither reads nor writes the underlying value.
            For example, 'nameof(x)' or reference to a symbol 'x' in a documentation comment
            does not read or write the underlying value stored in 'x'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadWrite">
            <summary>
            Represents a value read and/or write.
            For example, an increment or compound assignment operation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "in" or "ref readonly" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.WritableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadableWritableReference">
            <summary>
            Represents a value read or write.
            For example, passing an argument to a "ref" parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SharedPools">
            <summary>
            Shared object pool for Roslyn
            
            Use this shared pool if only concern is reducing object allocations.
            if perf of an object pool itself is also a concern, use ObjectPool directly.
            
            For example, if you want to create a million of small objects within a second, 
            use the ObjectPool directly. it should have much less overhead than using this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.StringIgnoreCaseDictionary``1">
            <summary>
            pool that uses string as key with StringComparer.OrdinalIgnoreCase as key comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.StringIgnoreCaseHashSet">
            <summary>
            pool that uses string as element with StringComparer.OrdinalIgnoreCase as element comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.StringHashSet">
            <summary>
            pool that uses string as element with StringComparer.Ordinal as element comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.ByteArray">
            <summary>
            Used to reduce the # of temporary byte[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactoringHelpers.IsNodeUnderselected(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            <para>
            Determines if a <paramref name="node"/> is under-selected given <paramref name="selection"/>.
            </para>
            <para>
            Under-selection is defined as omitting whole nodes from either the beginning or the end. It can be used e.g. to
            detect that following selection `1 + [|2 + 3|]` is under-selecting the whole expression node tree.
            </para>
            <para>
            Returns false if only and precisely one <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/> is selected. In that case the <paramref
            name="selection"/> is treated more as a caret location.
            </para>
            <para>
            It's intended to be used in conjunction with <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService.AddRelevantNodes``1(Microsoft.CodeAnalysis.ParsedDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Int32,Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray{``0}@,System.Threading.CancellationToken)"/> that, for
            non-empty selections, returns the smallest encompassing node. A node that can, for certain refactorings, be too
            large given user-selection even though it is the smallest that can be retrieved.
            </para>
            <para>
            When <paramref name="selection"/> doesn't intersect the node in any way it's not considered to be
            under-selected.
            </para>
            <para>
            Null node is always considered under-selected.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactoringHelpers.GetTrimmedTextSpan(Microsoft.CodeAnalysis.ParsedDocument,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Trims leading and trailing whitespace from <paramref name="span"/>.
            </summary>
            <remarks>
            Returns unchanged <paramref name="span"/> in case <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.IsEmpty"/>.
            Returns empty Span with original <see cref="P:Microsoft.CodeAnalysis.Text.TextSpan.Start"/> in case it contains only whitespace.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.MemberDisplayOptionsStorage">
            <summary>
            Options customizing member display. Used by multiple features.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MemberDisplayOptionsStorage.EditorConfigOptions">
            <summary>
            Options that we expect the user to set in editorconfig.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeAnalysisProgressExtensions.ItemCompletedScope(System.IProgress{Microsoft.CodeAnalysis.CodeAnalysisProgress},System.String)">
            <summary>
            Opens a scope that will call <see cref="M:System.IProgress`1.Report(`0)"/> with an instance of <see
            cref="M:Microsoft.CodeAnalysis.CodeAnalysisProgress.AddCompleteItems(System.Int32,System.String)"/> on <paramref name="progress"/> once disposed. This is useful to
            easily wrap a series of operations and now that progress will be reported no matter how it completes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService.CanMoveDeclarationNearReferenceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Returns true if <paramref name="localDeclarationStatement"/> is local declaration statement
            that can be moved forward to be closer to its first reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService.MoveDeclarationNearReferenceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Moves <paramref name="localDeclarationStatement"/> closer to its first reference. Only
            applicable if <see cref="M:Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService.CanMoveDeclarationNearReferenceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> returned
            <code>true</code>.  If not, then the original document will be returned unchanged.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService.ReplaceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Returns an updated <paramref name="memberDeclaration"/> with all the
            local declarations named '_' replaced with simple assignments to discard.
            For example,
             1. <code>int _ = M();</code> is replaced with <code>_ = M();</code>
             2. <code>int x = 1, _ = M(), y = 2;</code> is replaced with following statements:
             <code>
                     int x = 1;
                     _ = M();
                     int y = 2;
             </code>
            This is normally done in context of a code transformation that generates new discard assignment(s),
            such as <code>_ = M();</code>, and wants to prevent compiler errors where the containing method already
            has a discard variable declaration, say <code>var _ = M2();</code> at some line after the one
            where the code transformation wants to generate new discard assignment(s), which would be a compiler error.
            This method replaces such discard variable declarations with discard assignments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ParsedDocument">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Document"/> content that has been parsed.
            </summary>
            <remarks>
            Used to front-load <see cref="P:Microsoft.CodeAnalysis.ParsedDocument.SyntaxTree"/> parsing and <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> retrieval to a caller that has knowledge of whether or not these operations
            should be performed synchronously or asynchronously. The <see cref="T:Microsoft.CodeAnalysis.ParsedDocument"/> is then passed to a feature whose implementation is entirely synchronous.
            In general, any feature API that accepts <see cref="T:Microsoft.CodeAnalysis.ParsedDocument"/> should be synchronous and not access <see cref="T:Microsoft.CodeAnalysis.Document"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshots.
            In exceptional cases such API may be asynchronous as long as it completes synchronously in most common cases and async completion is rare. It is still desirable to improve the design
            of such feature to either not be invoked on a UI thread or be entirely synchronous.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParsedDocument.#ctor(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Host.HostLanguageServices)">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.Document"/> content that has been parsed.
            </summary>
            <remarks>
            Used to front-load <see cref="P:Microsoft.CodeAnalysis.ParsedDocument.SyntaxTree"/> parsing and <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> retrieval to a caller that has knowledge of whether or not these operations
            should be performed synchronously or asynchronously. The <see cref="T:Microsoft.CodeAnalysis.ParsedDocument"/> is then passed to a feature whose implementation is entirely synchronous.
            In general, any feature API that accepts <see cref="T:Microsoft.CodeAnalysis.ParsedDocument"/> should be synchronous and not access <see cref="T:Microsoft.CodeAnalysis.Document"/> or <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshots.
            In exceptional cases such API may be asynchronous as long as it completes synchronously in most common cases and async completion is rare. It is still desirable to improve the design
            of such feature to either not be invoked on a UI thread or be entirely synchronous.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ParsedDocument.GetChanges(Microsoft.CodeAnalysis.ParsedDocument@)">
            <summary>
            Equivalent semantics to <see cref="M:Microsoft.CodeAnalysis.Document.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.An_error_occurred_while_reading_the_specified_configuration_file_colon_0">
            <summary>An error occurred while reading the specified configuration file: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Symbol_0_is_not_from_source">
            <summary>Symbol "{0}" is not from source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cycle_detected_in_extensions">
            <summary>Cycle detected in extensions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Duplicate_source_file_0_in_project_1">
            <summary>Duplicate source file '{0}' in project '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_projects_is_not_supported">
            <summary>Removing projects is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_projects_is_not_supported">
            <summary>Adding projects is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Workspace_error">
            <summary>Workspace error</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Error_reading_content_of_source_file_0_1">
            <summary>Error reading content of source file '{0}' -- '{1}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Workspace_is_not_empty">
            <summary>Workspace is not empty.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_part_of_the_workspace">
            <summary>'{0}' is not part of the workspace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_already_part_of_the_workspace">
            <summary>'{0}' is already part of the workspace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_referenced">
            <summary>'{0}' is not referenced.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_already_referenced">
            <summary>'{0}' is already referenced.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_project_reference_from_0_to_1_will_cause_a_circular_reference">
            <summary>Adding project reference from '{0}' to '{1}' will cause a circular reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Metadata_is_not_referenced">
            <summary>Metadata is not referenced.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Metadata_is_already_referenced">
            <summary>Metadata is already referenced.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_present">
            <summary>{0} is not present.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_already_present">
            <summary>{0} is already present.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_specified_document_is_not_a_version_of_this_document">
            <summary>The specified document is not a version of this document.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_language_0_is_not_supported">
            <summary>The language '{0}' is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_already_contains_the_specified_project">
            <summary>The solution already contains the specified project.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_does_not_contain_the_specified_project">
            <summary>The solution does not contain the specified project.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_project_already_references_the_target_project">
            <summary>The project already references the target project.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_project_already_contains_the_specified_reference">
            <summary>The project already contains the specified reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.A_project_may_not_reference_itself">
            <summary>A project may not reference itself.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_already_contains_the_specified_reference">
            <summary>The solution already contains the specified reference.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Temporary_storage_cannot_be_written_more_than_once">
            <summary>Temporary storage cannot be written more than once.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_open">
            <summary>'{0}' is not open.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.A_language_name_cannot_be_specified_for_this_option">
            <summary>A language name cannot be specified for this option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.A_language_name_must_be_specified_for_this_option">
            <summary>A language name must be specified for this option.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.File_was_externally_modified_colon_0">
            <summary>File was externally modified: {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unrecognized_language_name">
            <summary>Unrecognized language name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Can_t_resolve_metadata_reference_colon_0">
            <summary>Can't resolve metadata reference: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Can_t_resolve_analyzer_reference_colon_0">
            <summary>Can't resolve analyzer reference: '{0}'.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Expected_0">
            <summary>Expected {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_must_be_a_non_null_and_non_empty_string">
            <summary>"{0}" must be a non-null and non-empty string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.This_submission_already_references_another_submission_project">
            <summary>This submission already references another submission project.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Only_submission_project_can_reference_submission_projects">
            <summary>Only submission project can reference submission projects.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_still_contains_open_documents">
            <summary>{0} still contains open documents.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_still_open">
            <summary>{0} is still open.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
            <summary>Value too large to be represented as a 30 bit unsigned integer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language">
            <summary>Cannot open project '{0}' because the file extension '{1}' is not associated with a language.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_open_project_0_because_the_language_1_is_not_supported">
            <summary>Cannot open project '{0}' because the language '{1}' is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_project_file_path_colon_0">
            <summary>Invalid project file path: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_solution_file_path_colon_0">
            <summary>Invalid solution file path: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Project_file_not_found_colon_0">
            <summary>Project file not found: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Solution_file_not_found_colon_0">
            <summary>Solution file not found: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unmerged_change_from_project_0">
            <summary>Unmerged change from project '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Added_colon">
            <summary>Added:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.After_colon">
            <summary>After:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Before_colon">
            <summary>Before:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removed_colon">
            <summary>Removed:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_additional_documents_is_not_supported">
            <summary>Adding additional documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_analyzer_config_documents_is_not_supported">
            <summary>Adding analyzer config documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_analyzer_references_is_not_supported">
            <summary>Adding analyzer references is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_documents_is_not_supported">
            <summary>Adding documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_project_references_is_not_supported">
            <summary>Adding project references is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_additional_documents_is_not_supported">
            <summary>Changing additional documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_analyzer_config_documents_is_not_supported">
            <summary>Changing analyzer config documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_documents_is_not_supported">
            <summary>Changing documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_additional_documents_is_not_supported">
            <summary>Removing additional documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_analyzer_config_documents_is_not_supported">
            <summary>Removing analyzer config documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_analyzer_references_is_not_supported">
            <summary>Removing analyzer references is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_documents_is_not_supported">
            <summary>Removing documents is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_project_references_is_not_supported">
            <summary>Removing project references is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_1_workspace">
            <summary>Service of type '{0}' is required to accomplish the task but is not available from '{1}' workspace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.At_least_one_diagnostic_must_be_supplied">
            <summary>At least one diagnostic must be supplied.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Diagnostic_must_have_span_0">
            <summary>Diagnostic must have span '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1">
            <summary>Label for node '{0}' is invalid, it must be within [0, {1}).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Matching_nodes_0_and_1_must_have_the_same_label">
            <summary>Matching nodes '{0}' and '{1}' must have the same label.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Node_0_must_be_contained_in_the_new_tree">
            <summary>Node '{0}' must be contained in the new tree.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Node_0_must_be_contained_in_the_old_tree">
            <summary>Node '{0}' must be contained in the old tree.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_member_0_is_not_declared_within_the_declaration_of_the_symbol">
            <summary>The member '{0}' is not declared within the declaration of the symbol.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_position_is_not_within_the_symbol_s_declaration">
            <summary>The position is not within the symbol's declaration</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_symbol_0_cannot_be_located_within_the_current_solution">
            <summary>The symbol '{0}' cannot be located within the current solution.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_compilation_options_is_not_supported">
            <summary>Changing compilation options is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_parse_options_is_not_supported">
            <summary>Changing parse options is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_node_is_not_part_of_the_tree">
            <summary>The node is not part of the tree.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.This_workspace_does_not_support_opening_and_closing_documents">
            <summary>This workspace does not support opening and closing documents.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Exceptions_colon">
            <summary>Exceptions:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_returned_an_uninitialized_ImmutableArray">
            <summary>'{0}' returned an uninitialized ImmutableArray</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Failure">
            <summary>Failure</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Warning">
            <summary>Warning</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Options_did_not_come_from_specified_Solution">
            <summary>Options did not come from specified Solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Enable">
            <summary>Enable</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Enable_and_ignore_future_errors">
            <summary>Enable and ignore future errors</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_encountered_an_error_and_has_been_disabled">
            <summary>'{0}' encountered an error and has been disabled.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Show_Stack_Trace">
            <summary>Show Stack Trace</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Stream_is_too_long">
            <summary>Stream is too long.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Async_Method">
            <summary>Async Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Error">
            <summary>Error</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.None">
            <summary>None</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Suggestion">
            <summary>Suggestion</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.File_0_size_of_1_exceeds_maximum_allowed_size_of_2">
            <summary>File '{0}' size of {1} exceeds maximum allowed size of {2}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_document_property_is_not_supported">
            <summary>Changing document properties is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Variables_captured_colon">
            <summary>Variables captured:</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Refactoring_Only">
            <summary>Refactoring Only</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories">
            <summary>Remove the line below if you want to inherit .editorconfig settings from higher directories</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Core_EditorConfig_Options">
            <summary>Core EditorConfig Options</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CSharp_files">
            <summary>C# files</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.dot_NET_Coding_Conventions">
            <summary>.NET Coding Conventions</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Indentation_and_spacing">
            <summary>Indentation and spacing</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.New_line_preferences">
            <summary>New line preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Visual_Basic_files">
            <summary>Visual Basic files</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_document_0_is_not_supported">
            <summary>Changing document '{0}' is not supported.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DateTimeKind_must_be_Utc">
            <summary>DateTimeKind must be Utc</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access">
            <summary>Adding imports will bring an extension method into scope with the same name as '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_in_a_different_project">
            <summary>{0} is in a different project.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Project_does_not_contain_specified_reference">
            <summary>Project does not contain specified reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Solution_does_not_contain_specified_reference">
            <summary>Solution does not contain specified reference</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_apply_action_that_is_not_in_0">
            <summary>Cannot apply action that is not in '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Symbols_project_could_not_be_found_in_the_provided_solution">
            <summary>Symbol's project could not be found in the provided solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_contents_of_a_SourceGeneratedDocument_may_not_be_changed">
            <summary>The contents of a SourceGeneratedDocument may not be changed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Rename_0_to_1">
            <summary>Rename '{0}' to '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Sync_namespace_to_folder_structure">
            <summary>Sync namespace to folder structure</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CodeAction_0_did_not_produce_a_changed_solution">
            <summary>CodeAction '{0}' did not produce a changed solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Predefined_conversion_from_0_to_1">
            <summary>Predefined conversion from {0} to {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.FixAllScope_ContainingType_and_FixAllScope_ContainingMember_are_not_supported_with_this_constructor">
            <summary>'FixAllScope.ContainingType' and 'FixAllScope.ContainingMember' are not supported with this constructor</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.FixAllScope_Custom_is_not_supported_with_this_API">
            <summary>'FixAllScope.Custom' is not supported with this API</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Failed_to_resolve_rename_conflicts">
            <summary>Failed to resolve rename conflicts</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Use_TextDocument_property_instead_of_Document_property_as_the_provider_supports_non_source_text_documents">
            <summary>Use 'TextDocument' property instead of 'Document' property as the provider supports non-source text documents.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unexpected_value_0_in_DocumentKinds_array">
            <summary>Unexpected value '{0}' in DocumentKinds array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Running_code_cleanup_on_fixed_documents">
            <summary>Running code cleanup on fixed documents</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Applying_changes_to_0">
            <summary>Applying changes to {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_compilation_options_is_not_supported">
            <summary>Removing compilation options is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_parse_options_is_not_supported">
            <summary>Removing parse options is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_project_language_is_not_supported">
            <summary>Changing project language is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_project_between_ordinary_and_interactive_submission_is_not_supported">
            <summary>Changing project between ordinary and interactive submission is not supported</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Absolute_path_expected">
            <summary>Absolute path expected.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Organize_usings">
            <summary>Organize usings</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.this_dot_and_Me_dot_preferences">
            <summary>this. and Me. preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Language_keywords_vs_BCL_types_preferences">
            <summary>Language keywords vs BCL types preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Parentheses_preferences">
            <summary>Parentheses preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Modifier_preferences">
            <summary>Modifier preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Expression_level_preferences">
            <summary>Expression-level preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Field_preferences">
            <summary>Field preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Parameter_preferences">
            <summary>Parameter preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Suppression_preferences">
            <summary>Suppression preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Pascal_Case">
            <summary>Pascal Case</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Abstract_Method">
            <summary>Abstract Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Begins_with_I">
            <summary>Begins with I</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Class">
            <summary>Class</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Delegate">
            <summary>Delegate</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Enum">
            <summary>Enum</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Event">
            <summary>Event</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Interface">
            <summary>Interface</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Non_Field_Members">
            <summary>Non-Field Members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Private_Method">
            <summary>Private Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Private_or_Internal_Field">
            <summary>Private or Internal Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Private_or_Internal_Static_Field">
            <summary>Private or Internal Static Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Property">
            <summary>Property</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Public_or_Protected_Field">
            <summary>Public or Protected Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Static_Field">
            <summary>Static Field</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Static_Method">
            <summary>Static Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Struct">
            <summary>Struct</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Types">
            <summary>Types</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Method">
            <summary>Method</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Missing_prefix_colon_0">
            <summary>Missing prefix: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Missing_suffix_colon_0">
            <summary>Missing suffix: '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Prefix_0_does_not_match_expected_prefix_1">
            <summary>Prefix '{0}' does not match expected prefix '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Prefix_0_is_not_expected">
            <summary>Prefix '{0}' is not expected</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
            <summary>These non-leading words must begin with an upper case letter: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
            <summary>These non-leading words must begin with a lowercase letter: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_words_cannot_contain_lower_case_characters_colon_0">
            <summary>These words cannot contain lower case characters: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_words_cannot_contain_upper_case_characters_colon_0">
            <summary>These words cannot contain upper case characters: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.These_words_must_begin_with_upper_case_characters_colon_0">
            <summary>These words must begin with upper case characters: {0}</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.The_first_word_0_must_begin_with_an_upper_case_character">
            <summary>The first word, '{0}', must begin with an upper case character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.The_first_word_0_must_begin_with_a_lower_case_character">
            <summary>The first word, '{0}', must begin with a lower case character</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Cast_is_redundant">
            <summary>Cast is redundant.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Naming_styles">
            <summary>Naming styles</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Naming_rules">
            <summary>Naming rules</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Symbol_specifications">
            <summary>Symbol specifications</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Specified_sequence_has_duplicate_items">
            <summary>Specified sequence has duplicate items</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.New_line_preferences">
            <summary>New line preferences</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CompilerExtensionsResources.Instantiated_parts_threw_exceptions_from_IDisposable_Dispose">
            <summary>Instantiated part(s) threw exception(s) from IDisposable.Dispose().</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Supplied_diagnostic_cannot_be_null">
            <summary>Supplied diagnostic cannot be null.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0">
            <summary>Fix all '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0_in_1">
            <summary>Fix all '{0}' in '{1}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0_in_Solution">
            <summary>Fix all '{0}' in Solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0_in_Containing_member">
            <summary>Fix all '{0}' in Containing member</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Fix_all_0_in_Containing_type">
            <summary>Fix all '{0}' in Containing type</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0">
            <summary>Compilation is required to accomplish the task but is not supported by project {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0">
            <summary>Syntax tree is required to accomplish the task but is not supported by document {0}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution">
            <summary>Project of ID {0} is required to accomplish the task but is not available from the solution</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.The_solution_does_not_contain_the_specified_document">
            <summary>The solution does not contain the specified document.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Warning_colon_Declaration_changes_scope_and_may_change_meaning">
            <summary>Warning: Declaration changes scope and may change meaning.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Could_not_find_location_to_generation_symbol_into">
            <summary>Could not find location to generation symbol into.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Destination_location_was_from_a_different_tree">
            <summary>Destination location was from a different tree.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Destination_location_was_not_in_source">
            <summary>Destination location was not in source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4">
            <summary>Destination type must be a {0}, {1}, {2} or {3}, but given one is {4}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Destination_type_must_be_a_0_1_or_2_but_given_one_is_3">
            <summary>Destination type must be a {0}, {1} or {2}, but given one is {3}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Destination_type_must_be_a_0_but_given_one_is_1">
            <summary>Destination type must be a {0}, but given one is {1}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Destination_type_must_be_a_0_or_a_1_but_given_one_is_2">
            <summary>Destination type must be a {0} or a {1}, but given one is {2}.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Invalid_number_of_parameters_for_binary_operator">
            <summary>Invalid number of parameters for binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Invalid_number_of_parameters_for_unary_operator">
            <summary>Invalid number of parameters for unary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Location_must_be_null_or_from_source">
            <summary>Location must be null or from source.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.No_available_location_found_to_add_statements_to">
            <summary>No available location found to add statements to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.No_location_provided_to_add_statements_to">
            <summary>No location provided to add statements to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Cannot_generate_code_for_unsupported_operator_0">
            <summary>Cannot generate code for unsupported operator '{0}'</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Namespace_can_not_be_added_in_this_destination">
            <summary>Namespace can not be added in this destination.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Type_members">
            <summary>Type members</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceExtensionsResources.Document_does_not_support_syntax_trees">
            <summary>Document does not support syntax trees</summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncBatchingWorkQueue">
            <inheritdoc cref="T:Roslyn.Utilities.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="M:Roslyn.Utilities.AsyncBatchingWorkQueue.#ctor(System.TimeSpan,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,System.Threading.CancellationToken)">
            <inheritdoc cref="T:Roslyn.Utilities.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="T:Roslyn.Utilities.AsyncBatchingWorkQueue`1">
            <inheritdoc cref="T:Roslyn.Utilities.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="M:Roslyn.Utilities.AsyncBatchingWorkQueue`1.#ctor(System.TimeSpan,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{`0},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask},System.Collections.Generic.IEqualityComparer{`0},Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,System.Threading.CancellationToken)">
            <inheritdoc cref="T:Roslyn.Utilities.AsyncBatchingWorkQueue`2"/>
        </member>
        <member name="T:Roslyn.Utilities.AsyncBatchingWorkQueue`2">
            <summary>
            A queue where items can be added to to be processed in batches after some delay has passed. When processing
            happens, all the items added since the last processing point will be passed along to be worked on.  Rounds of
            processing happen serially, only starting up after a previous round has completed.
            <para>
            Failure to complete a particular batch (either due to cancellation or some faulting error) will not prevent
            further batches from executing. The only thing that will permenantly stop this queue from processing items is if
            the <see cref="T:System.Threading.CancellationToken"/> passed to the constructor switches to <see
            cref="P:System.Threading.CancellationToken.IsCancellationRequested"/>.
            </para>
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._delay">
            <summary>
            Delay we wait after finishing the processing of one batch and starting up on then.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._equalityComparer">
            <summary>
            Equality comparer uses to dedupe items if present.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._processBatchAsync">
            <summary>
            Callback to actually perform the processing of the next batch of work.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._entireQueueCancellationToken">
            <summary>
            Cancellation token controlling the entire queue.  Once this is triggered, we don't want to do any more work
            at all.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._cancellationSeries">
            <summary>
            Cancellation series we use so we can cancel individual batches of work if requested.  The client of the
            queue can cancel existing work by either calling <see cref="M:Roslyn.Utilities.AsyncBatchingWorkQueue`2.CancelExistingWork"/> directly, or passing <see
            langword="true"/> to <see cref="M:Roslyn.Utilities.AsyncBatchingWorkQueue`2.AddWork(`0,System.Boolean)"/>.  Work in the queue that has not started will be
            immediately discarded. The cancellation token passed to <see cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._processBatchAsync"/> will be triggered
            allowing the client callback to cooperatively cancel the current batch of work it is performing.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._gate">
            <summary>
            Lock we will use to ensure the remainder of these fields can be accessed in a threadsafe
            manner.  When work is added we'll place the data into <see cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._nextBatch"/>.
            We'll then kick of a task to process this in the future if we don't already have an
            existing task in flight for that.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._nextBatch">
            <summary>
            Data added that we want to process in our next update task.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._nextBatchCancellationToken">
            <summary>
            CancellationToken controlling the next batch of items to execute.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._uniqueItems">
            <summary>
            Used if <see cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._equalityComparer"/> is present to ensure only unique items are added to <see
            cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._nextBatch"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._updateTask">
            <summary>
            Task kicked off to do the next batch of processing of <see cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._nextBatch"/>. These
            tasks form a chain so that the next task only processes when the previous one completes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._taskInFlight">
            <summary>
            Whether or not there is an existing task in flight that will process the current batch
            of <see cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._nextBatch"/>.  If there is an existing in flight task, we don't need to
            kick off a new one if we receive more work before it runs.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncBatchingWorkQueue`2.#ctor(System.TimeSpan,System.Func{Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList{`0},System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{`1}},System.Collections.Generic.IEqualityComparer{`0},Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener,System.Threading.CancellationToken)">
            <param name="processBatchAsync">Callback to process queued work items.  The list of items passed in is
            guaranteed to always be non-empty.</param>
        </member>
        <member name="M:Roslyn.Utilities.AsyncBatchingWorkQueue`2.CancelExistingWork">
            <summary>
            Cancels any outstanding work in this queue.  Work that has not yet started will never run. Work that is in
            progress will request cancellation in a standard best effort fashion.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncBatchingWorkQueue`2.WaitUntilCurrentBatchCompletesAsync">
            <summary>
            Waits until the current batch of work completes and returns the last value successfully computed from <see
            cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._processBatchAsync"/>.  If the last <see cref="F:Roslyn.Utilities.AsyncBatchingWorkQueue`2._processBatchAsync"/> canceled or failed, then a
            corresponding canceled or faulted task will be returned that propagates that outwards.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.CancellationSeries">
            <summary>
            Produces a series of <see cref="T:System.Threading.CancellationToken"/> objects such that requesting a new token
            causes the previously issued token to be cancelled.
            </summary>
            <remarks>
            <para>Consuming code is responsible for managing overlapping asynchronous operations.</para>
            <para>This class has a lock-free implementation to minimise latency and contention.</para>
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.CancellationSeries.#ctor(System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of <see cref="T:Roslyn.Utilities.CancellationSeries"/>.
            </summary>
            <param name="token">An optional cancellation token that, when cancelled, cancels the last
            issued token and causes any subsequent tokens to be issued in a cancelled state.</param>
        </member>
        <member name="P:Roslyn.Utilities.CancellationSeries.HasActiveToken">
            <summary>
            Determines if the cancellation series has an active token which has not been cancelled.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.CancellationSeries.CreateNext(System.Threading.CancellationToken)">
            <summary>
            Creates the next <see cref="T:System.Threading.CancellationToken"/> in the series, ensuring the last issued
            token (if any) is cancelled first.
            </summary>
            <param name="token">An optional cancellation token that, when cancelled, cancels the
            returned token.</param>
            <returns>
            A cancellation token that will be cancelled when either:
            <list type="bullet">
            <item><see cref="M:Roslyn.Utilities.CancellationSeries.CreateNext(System.Threading.CancellationToken)"/> is called again</item>
            <item>The token passed to this method (if any) is cancelled</item>
            <item>The token passed to the constructor (if any) is cancelled</item>
            <item><see cref="M:Roslyn.Utilities.CancellationSeries.Dispose"/> is called</item>
            </list>
            </returns>
            <exception cref="T:System.ObjectDisposedException">This object has been disposed.</exception>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceHolder`1.TestAccessor.ReleasedWeak(System.Int32)">
            <summary>
            Creates a <see cref="T:Roslyn.Utilities.ReferenceHolder`1"/> for a weakly-held reference that has since been collected.
            </summary>
            <param name="hashCode">The hash code of the collected value.</param>
            <returns>A weak <see cref="T:Roslyn.Utilities.ReferenceHolder`1"/> which was already collected.</returns>
        </member>
        <member name="T:Roslyn.Utilities.SpellChecker">
            <summary>
            Explicitly a reference type so that the consumer of this in <see cref="T:Roslyn.Utilities.BKTree"/> can safely operate on an
            instance without having to lock to ensure it sees the entirety of the value written out.
            </summary>>
        </member>
        <member name="M:Roslyn.Utilities.SpellChecker.#ctor(Roslyn.Utilities.BKTree)">
            <summary>
            Explicitly a reference type so that the consumer of this in <see cref="T:Roslyn.Utilities.BKTree"/> can safely operate on an
            instance without having to lock to ensure it sees the entirety of the value written out.
            </summary>>
        </member>
        <member name="T:Roslyn.Utilities.TaskQueue">
            <summary>
            Implements a queue of asynchronously executed tasks.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTask(System.String,System.Action,System.Threading.CancellationToken)">
            <summary>
            Enqueue specified <paramref name="operation"/> and notify <see cref="P:Roslyn.Utilities.TaskQueue.Listener"/> of its start and completion.
            </summary>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> that executes the operation.</returns>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTask``1(System.String,System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Roslyn.Utilities.TaskQueue.ScheduleTask(System.String,System.Action,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTask(System.String,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Roslyn.Utilities.TaskQueue.ScheduleTask(System.String,System.Action,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTask``1(System.String,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Roslyn.Utilities.TaskQueue.ScheduleTask(System.String,System.Action,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress(System.Action,System.Threading.CancellationToken)">
            <summary>
            Enqueue specified <paramref name="operation"/>.
            Assumes <see cref="P:Roslyn.Utilities.TaskQueue.Listener"/> has already been notified of its start and will be notified when it completes.
            </summary>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> that executes the operation.</returns>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress``1(System.Func{``0},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress(System.Action,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress(System.Action,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <inheritdoc cref="M:Roslyn.Utilities.TaskQueue.ScheduleTaskInProgress(System.Action,System.Threading.CancellationToken)"/>
        </member>
        <member name="T:Roslyn.Utilities.WeakSet`1">
            <summary>
            A simple collection of values held as weak references. Objects in the set are compared by reference equality.
            </summary>
            <typeparam name="T">The type of object stored in the set.</typeparam>
        </member>
        <member name="T:Roslyn.Utilities.AssemblyUtilities">
            <summary>
            This partial contains methods that must be shared by source with the workspaces layer
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AssemblyUtilities.ReadMvid(System.String)">
            <summary>
            Given a path to an assembly, returns its MVID (Module Version ID).
            May throw.
            </summary>
            <exception cref="T:System.IO.IOException">If the file at <paramref name="filePath"/> does not exist or cannot be accessed.</exception>
            <exception cref="T:System.BadImageFormatException">If the file is not an assembly or is somehow corrupted.</exception>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentDictionaryExtensions.Add``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            NOTE!!! adding duplicates will result in exceptions. 
            Being concurrent only allows accessing the dictionary without taking locks.
            Duplicate keys are still not allowed in the hashtable.
            If unsure about adding unique items use APIs such as TryAdd, GetOrAdd, etc...
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConfiguredYieldAwaitable">
            <summary>
            A custom awaiter that supports <see cref="M:Roslyn.Utilities.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)"/> for
            <see cref="M:System.Threading.Tasks.Task.Yield"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,Roslyn.Utilities.RoslynDebug.AssertInterpolatedStringHandler@)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.AssertOrFailFast(System.Boolean,System.String)">
            <summary>
            Generally <see cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/> is a sufficient method for enforcing DEBUG 
            only invariants in our code. When it triggers that provides a nice stack trace for 
            investigation. Generally that is enough.
            
            <para>There are cases for which a stack is not enough and we need a full heap dump to 
            investigate the failure. This method takes care of that. The behavior is that when running
            in our CI environment if the assert triggers we will rudely crash the process and 
            produce a heap dump for investigation.</para>
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.SelectAsArrayAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.ValueTask{``1}})">
            <summary>
            Maps an immutable array through a function that returns ValueTask, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.SelectAsArrayAsync``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTask, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.SelectAsArrayAsync``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``2}},``1,System.Threading.CancellationToken)">
            <summary>
            Maps an immutable array through a function that returns ValueTask, returning the new ImmutableArray.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exactly one, and default(TSource) otherwise.
            Unlike <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.Functions`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Roslyn.Utilities.Predicates`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(System.Object)">
            <summary>
            Creates an <see cref="T:System.InvalidOperationException"/> with information about an unexpected value.
            </summary>
            <param name="o">The unexpected value.</param>
            <returns>The <see cref="T:System.InvalidOperationException"/>, which should be thrown by the caller.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ExceptionUtilities.IsCurrentOperationBeingCancelled(System.Exception,System.Threading.CancellationToken)">
            <summary>
            Determine if an exception was an <see cref="T:System.OperationCanceledException"/>, and that the provided token caused the cancellation.
            </summary>
            <param name="exception">The exception to test.</param>
            <param name="cancellationToken">Checked to see if the provided token was cancelled.</param>
            <returns><see langword="true"/> if the exception was an <see cref="T:System.OperationCanceledException" /> and the token was canceled.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(``0@,System.Func{``0})">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``2(``0@,System.Func{``1,``0},``1)">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <typeparam name="TArg">The type of the <paramref name="arg"/> argument passed to the value factory.</typeparam>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <param name="arg">An argument passed to the value factory.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(System.Int32@,System.Int32,System.Func{``0,System.Int32},``0)">
            <summary>
            Ensure that the given target value is initialized in a thread-safe manner.
            </summary>
            <param name="target">The target to initialize.</param>
            <param name="uninitializedValue">The value indicating <paramref name="target"/> is not yet initialized.</param>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <param name="arg">An argument passed to the value factory.</param>
            <typeparam name="TArg">The type of the <paramref name="arg"/> argument passed to the value factory.</typeparam>
            <remarks>
            If <paramref name="valueFactory"/> returns a value equal to <paramref name="uninitializedValue"/>, future
            calls to the same method may recalculate the target value.
            </remarks>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(System.Runtime.CompilerServices.StrongBox{``0}@,System.Func{``0})">
            <summary>
            Ensure that the given target value is initialized in a thread-safe manner. This overload supports the
            initialization of value types, and reference type fields where <see langword="null"/> is considered an
            initialized value.
            </summary>
            <typeparam name="T">The type of the target value.</typeparam>
            <param name="target">A target value box to initialize.</param>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``2(System.Runtime.CompilerServices.StrongBox{``0}@,System.Func{``1,``0},``1)">
            <summary>
            Ensure that the given target value is initialized in a thread-safe manner. This overload supports the
            initialization of value types, and reference type fields where <see langword="null"/> is considered an
            initialized value.
            </summary>
            <typeparam name="T">The type of the target value.</typeparam>
            <param name="target">A target value box to initialize.</param>
            <typeparam name="TArg">The type of the <paramref name="arg"/> argument passed to the value factory.</typeparam>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <param name="arg">An argument passed to the value factory.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(``0@,``0)">
            <summary>
            Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
            The value is changed to <paramref name="value"/> only if the current value is null.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="target">Reference to the target location.</param>
            <param name="value">The value to use if the target is currently null.</param>
            <returns>The new value referenced by <paramref name="target"/>. Note that this is
            nearly always more useful than the usual return from <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            because it saves another read to <paramref name="target"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(``0@,``0,``0)">
            <summary>
            Initialize the value referenced by <paramref name="target"/> in a thread-safe manner.
            The value is changed to <paramref name="initializedValue"/> only if the current value
            is <paramref name="uninitializedValue"/>.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="target">Reference to the target location.</param>
            <param name="initializedValue">The value to use if the target is currently uninitialized.</param>
            <param name="uninitializedValue">The uninitialized value.</param>
            <returns>The new value referenced by <paramref name="target"/>. Note that this is
            nearly always more useful than the usual return from <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            because it saves another read to <paramref name="target"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Initialize the immutable array referenced by <paramref name="target"/> in a thread-safe manner.
            </summary>
            <typeparam name="T">Elemental type of the array.</typeparam>
            <param name="target">Reference to the target location.</param>
            <param name="initializedValue">The value to use if the target is currently uninitialized (default).</param>
            <returns>The new value referenced by <paramref name="target"/>. Note that this is
            nearly always more useful than the usual return from <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            because it saves another read to <paramref name="target"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``1(System.Collections.Immutable.ImmutableArray{``0}@,System.Func{System.Collections.Immutable.ImmutableArray{``0}})">
            <summary>
            Initialize the immutable array referenced by <paramref name="target"/> in a thread-safe manner.
            </summary>
            <typeparam name="T">Elemental type of the array.</typeparam>
            <param name="createArray">Callback to produce the array if <paramref name="target"/> is 'default'.  May be
            called multiple times in the event of concurrent initialization of <paramref name="target"/>.  Will not be
            called if 'target' is already not 'default' at the time this is called.</param>
            <returns>The value of <paramref name="target"/> after initialization.  If <paramref name="target"/> is
            already initialized, that value value will be returned.</returns>
        </member>
        <member name="M:Roslyn.Utilities.InterlockedOperations.Initialize``2(System.Collections.Immutable.ImmutableArray{``0}@,System.Func{``1,System.Collections.Immutable.ImmutableArray{``0}},``1)">
            <summary>
            Initialize the immutable array referenced by <paramref name="target"/> in a thread-safe manner.
            </summary>
            <typeparam name="T">Elemental type of the array.</typeparam>
            <typeparam name="TArg">The type of the <paramref name="arg"/> argument passed to the value factory.</typeparam>
            <param name="createArray">Callback to produce the array if <paramref name="target"/> is 'default'.  May be
            called multiple times in the event of concurrent initialization of <paramref name="target"/>.  Will not be
            called if 'target' is already not 'default' at the time this is called.</param>
            <returns>The value of <paramref name="target"/> after initialization.  If <paramref name="target"/> is
            already initialized, that value value will be returned.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="T:Roslyn.Utilities.SingleInitNullable`1">
            <summary>
            A lazily initialized version of <see cref="T:System.Nullable`1"/> which uses the same space as a <see cref="T:System.Nullable`1"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SingleInitNullable`1._initialized">
            <summary>
            One of three values:
            <list type="bullet">
            <item>0. <see cref="F:Roslyn.Utilities.SingleInitNullable`1._value"/> is not initialized yet.</item>
            <item>1. <see cref="F:Roslyn.Utilities.SingleInitNullable`1._value"/> is currently being initialized by some thread.</item>
            <item>2. <see cref="F:Roslyn.Utilities.SingleInitNullable`1._value"/> has been initialized.</item>
            </list>
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SingleInitNullable`1._value">
            <summary>
            Actual stored value.  Only safe to read once <see cref="F:Roslyn.Utilities.SingleInitNullable`1._initialized"/> is set to 2.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SingleInitNullable`1.Initialize``1(System.Func{``0,`0},``0)">
            <summary>
            Ensure that the given target value is initialized in a thread-safe manner.
            </summary>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this
            delegate may be called more than once by multiple threads, but only one of those values will successfully be
            written to the target.</param>
            <returns>The target value.</returns>
            <remarks>
            An alternative approach here would be to pass <paramref name="valueFactory"/> and <paramref name="arg"/> into
            <see cref="M:Roslyn.Utilities.SingleInitNullable`1.GetOrStore(`0)"/>, and to only compute the value if the winning thread.  However, this has two potential
            downsides.  First, the computation of the value might take an indeterminate amount of time.  This would require
            other threads to then busy-spin for that same amount of time.  Second, we would have to make the code very
            resilient to failure paths (including cancellation), ensuring that the type reset itself <em>safely</em> to the
            initial state so that other threads were not perpetually stuck in the busy state.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ValueTaskFactory">
            <summary>
            Implements <see cref="T:System.Threading.Tasks.ValueTask"/> and <see cref="T:System.Threading.Tasks.ValueTask`1"/> static members that are only available in .NET 5.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.VoidResult">
            <summary>
            Explicitly indicates result is void
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.YieldAwaitableExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)">
            <summary>
            Implements <c>ConfigureAwait(bool)</c> for <see cref="M:System.Threading.Tasks.Task.Yield"/>. The resulting behavior in asynchronous code
            is the same as one would expect for <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/>.
            </summary>
            <param name="awaitable">The awaitable provided by <see cref="M:System.Threading.Tasks.Task.Yield"/>.</param>
            <param name="continueOnCapturedContext"><inheritdoc cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/></param>
            <returns>An object used to await this yield.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.ReadOnlySpan{System.Char})">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="data">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="data"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.ArrayExtensions.BinarySearchUpperBound(System.Int32[],System.Int32)">
            <summary>
            Search a sorted integer array for the target value in O(log N) time.
            </summary>
            <param name="array">The array of integers which must be sorted in ascending order.</param>
            <param name="value">The target value.</param>
            <returns>An index in the array pointing to the position where <paramref name="value"/> should be
            inserted in order to maintain the sorted order. All values to the right of this position will be
            strictly greater than <paramref name="value"/>. Note that this may return a position off the end
            of the array if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.CompilerOptionParseUtilities.ParseFeatureFromMSBuild(System.String)">
            <summary>
            Parse the value provided to an MSBuild Feature option into a list of entries.  This will 
            leave name=value in their raw form.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConcurrentSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultConcurrencyLevel">
            <summary>
            The default concurrency level is 2. That means the collection can cope with up to two
            threads making simultaneous modifications without blocking.
            Note ConcurrentDictionary's default concurrency level is dynamic, scaling according to
            the number of processors.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultCapacity">
            <summary>
            Taken from ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1._dictionary">
            <summary>
            The backing dictionary. The values are never used; just the keys.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor">
            <summary>
            Construct a concurrent set with the default concurrency level.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct a concurrent set using the specified equality comparer.
            </summary>
            <param name="equalityComparer">The equality comparer for values in the set.</param>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Contains(`0)">
            <summary>
            Determine whether the given value is in the set.
            </summary>
            <param name="value">The value to test.</param>
            <returns>true if the set contains the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a value to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Clear">
            <summary>
            Clear the set
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.DocumentationCommentXmlNames">
            <summary>
            Names of well-known XML attributes and elements.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.FileNameUtilities">
            <summary>
            Implements a few file name utilities that are needed by the compiler.
            In general the compiler is not supposed to understand the format of the paths.
            In rare cases it needs to check if a string is a valid file name or change the extension 
            (embedded resources, netmodules, output name).
            The APIs are intentionally limited to cover just these rare cases. Do not add more APIs.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name. 
            The name may contain any characters but directory and volume separators.
            </summary>
            <param name="path">Path.</param>
            <returns>
            True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".goo".
            Returns -1 for path "goo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "goo" for path "goo.".
            Returns "goo.." for path "goo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extension changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetFileName(System.String,System.Boolean)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="T:Roslyn.Utilities.SetWithInsertionOrder`1">
            <summary>
            A set that returns the inserted values in insertion order.
            The mutation operations are not thread-safe.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.OneOrMany`1">
            <summary>
            Represents a single item or many items (including none).
            </summary>
            <remarks>
            Used when a collection usually contains a single item but sometimes might contain multiple.
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.OneOrMany`1.HasOneItem">
            <summary>
            True if the collection has a single item. This item is stored in <see cref="F:Roslyn.Utilities.OneOrMany`1._one"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.PlatformInformation">
            <summary>
            This class provides simple properties for determining whether the current platform is Windows or Unix-based.
            We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
            it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PlatformInformation.IsUsingMonoRuntime">
            <summary>
            Are we running on .NET 5 or later using the Mono runtime?
            Will also return true when running on Mono itself; if necessary
            we can use IsRunningOnMono to distinguish.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads all bytes from the current position of the given stream to its end.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringTable">
            <summary>
            This is basically a lossy cache of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange})">
             <summary>
             Merges the new change ranges into the old change ranges, adjusting the new ranges to be with respect to the original text
             (with neither old or new changes applied) instead of with respect to the original text after "old changes" are applied.
            
             This may require splitting, concatenation, etc. of individual change ranges.
             </summary>
             <remarks>
             Both `oldChanges` and `newChanges` must contain non-overlapping spans in ascending order.
             </remarks>
        </member>
        <member name="T:Roslyn.Utilities.TextChangeRangeExtensions.UnadjustedNewChange">
            <summary>
            Represents a new change being processed by <see cref="M:Roslyn.Utilities.TextChangeRangeExtensions.Merge(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextChangeRange})"/>.
            Such a new change must be adjusted before being added to the result list.
            </summary>
            <remarks>
            A value of this type may represent the intermediate state of merging of an old change into an unadjusted new change,
            resulting in a temporary unadjusted new change whose <see cref="P:Roslyn.Utilities.TextChangeRangeExtensions.UnadjustedNewChange.SpanStart"/> is negative (not valid) until it is adjusted.
            This tends to happen when we need to merge an old change deletion into a new change near the beginning of the text. (see TextChangeTests.Fuzz_4)
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved or does not exist.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.Stream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLength(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLengthAndTimeStamp(System.String,System.Int64@,System.DateTime@)">
            <exception cref="T:System.IO.IOException"/>
            <summary>
            Preferred mechanism to obtain both length and last write time of a file. Querying independently
            requires multiple i/o hits which are expensive, even if cached.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDirectorySeparator(System.Char)">
            <summary>
            True if the character is the platform directory separator character or the alternate directory separator.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(System.Char)">
            <summary>
            True if the character is any recognized directory separator character.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.TrimTrailingSeparators(System.String)">
            <summary>
            Removes trailing directory separator characters
            </summary>
            <remarks>
            This will trim the root directory separator:
            "C:\" maps to "C:", and "/" maps to ""
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.EnsureTrailingSeparator(System.String)">
            <summary>
            Ensures a trailing directory separator character
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it doesn't check for invalid path characters
            </remarks>
            <returns>Prefix of path that represents a directory</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Gets the root part of the path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathKind(System.String)">
            <summary>
            Gets the specific kind of relative or absolute path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAbsolute(System.String)">
            <summary>
            True if the path is an absolute path (rooted to drive or network share)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="root"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePaths(System.String,System.String)">
            <summary>
            Combines paths with the same semantics as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>
            but does not throw on null paths or paths with invalid characters.
            </summary>
            <param name="root">First path: absolute, relative, or null.</param>
            <param name="path">Second path: absolute, relative, or null.</param>
            <returns>
            The combined paths. If <paramref name="path"/> contains an absolute path, returns <paramref name="path"/>.
            </returns>
            <remarks>
            Relative and absolute paths treated the same as <see cref="M:System.IO.Path.Combine(System.String,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ContainsPathComponent(System.String,System.String,System.Boolean)">
            <summary>
            Determines if "path" contains 'component' within itself.
            i.e. asking if the path "c:\goo\bar\baz" has component "bar" would return 'true'.
            On the other hand, if you had "c:\goo\bar1\baz" then it would not have "bar" as a
            component.
            
            A path contains a component if any file name or directory name in the path
            matches 'component'.  As such, if you had something like "\\goo" then that would
            not have "goo" as a component. That's because here "goo" is the server name portion
            of the UNC path, and not an actual directory or file name.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetRelativePath(System.String,System.String)">
            <summary>
            Gets a path relative to a directory.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsChildPath(System.String,System.String)">
            <summary>
            True if the child path is a child of the parent path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String)">
            <summary>
            True if the two paths are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String,System.Int32)">
            <summary>
            True if the two paths are the same.  (but only up to the specified length)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsValidFilePath(System.String)">
            <summary>
            Unfortunately, we cannot depend on Path.GetInvalidPathChars() or Path.GetInvalidFileNameChars()
            From MSDN: The array returned from this method is not guaranteed to contain the complete set of characters
            that are invalid in file and directory names. The full set of invalid characters can vary by file system.
            https://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx
            
            Additionally, Path.GetInvalidPathChars() doesn't include "?" or "*" which are invalid characters,
            and Path.GetInvalidFileNameChars() includes ":" and "\" which are valid characters.
            
            The more accurate way is to let the framework parse the path and throw on any errors.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.NormalizeWithForwardSlash(System.String)">
            <summary>
            If the current environment uses the '\' directory separator, replaces all uses of '\'
            in the given string with '/'. Otherwise, returns the string.
            </summary>
            <remarks>
            This method is equivalent to Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig.NormalizeWithForwardSlash
            Both methods should be kept in sync.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CollapseWithForwardSlash(System.ReadOnlySpan{System.Char})">
            <summary>
            Replaces all sequences of '\' or '/' with a single '/' but preserves UNC prefix '//'.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ExpandAbsolutePathWithRelativeParts(System.String)">
            <summary>
            Takes an absolute path and attempts to expand any '..' or '.' into their equivalent representation.
            </summary>
            <returns>An equivalent path that does not contain any '..' or '.' path parts, or the original path.</returns>
            <remarks>
            This method handles unix and windows drive rooted absolute paths only (i.e /a/b or x:\a\b). Passing any other kind of path
            including relative, drive relative, unc, or windows device paths will simply return the original input. 
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ReflectionUtilities.GetTypeFromEither(System.String,System.String)">
            <summary>
            Find a <see cref="T:System.Type"/> instance by first probing the contract name and then the name as it
            would exist in mscorlib.  This helps satisfy both the CoreCLR and Desktop scenarios. 
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.UnicodeCharacterUtilities">
            <summary>
            Defines a set of helper methods to classify Unicode characters.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid Unicode identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectReader"/> that deserializes objects from a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader.VersionByte1">
            <summary>
            We start the version at something reasonably random.  That way an older file, with 
            some random start-bytes, has little chance of matching our version.  When incrementing
            this version, just change VersionByte2.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._stringReferenceMap">
            <summary>
            Map of reference id's to deserialized strings.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
            <param name="stream">The stream to read objects from.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean)">
            <summary>
            Attempts to create a <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            If the <paramref name="stream"/> does not start with a valid header, then <see langword="null"/> will
            be returned.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.GetReader(System.IO.Stream,System.Boolean)">
            <summary> 
            Creates an <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>. Unlike <see
            cref="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean)"/>, it requires the version of the data in the stream to
            exactly match the current format version. Should only be used to read data written by the same version of
            Roslyn.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.GetReader(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary> 
            <inheritdoc cref="M:Roslyn.Utilities.ObjectReader.GetReader(System.IO.Stream,System.Boolean)"/>
            <param name="checkValidationBytes">Whether or not the validation bytes (see <see
            cref="M:Roslyn.Utilities.ObjectWriter.WriteValidationBytes"/> should be checked immediately at the stream's current
            position.</param>
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader.ReaderReferenceMap">
            <summary>
            A reference-id to object map, that can share base data efficiently.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectWriter"/> that serializes objects to a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.ByteMarkerMask">
            <summary>
            byte marker mask for encoding compressed uint
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte1Marker">
            <summary>
            byte marker bits for uint encoded in 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte2Marker">
            <summary>
            byte marker bits for uint encoded in 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte4Marker">
            <summary>
            byte marker bits for uint encoded in 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._stringReferenceMap">
             <summary>
             Map of serialized string reference ids.  The string-reference-map uses value-equality for greater cache hits
             and reuse.
            
             This is a mutable struct, and as such is not readonly.
            
             When we write out strings we give each successive, unique, item a monotonically increasing integral ID
             starting at 0.  I.e. the first string gets ID-0, the next gets ID-1 and so on and so forth.  We do *not*
             include these IDs with the object when it is written out.  We only include the ID if we hit the object
             *again* while writing.
            
             During reading, the reader knows to give each string it reads the same monotonically increasing integral
             value.  i.e. the first string it reads is put into an array at position 0, the next at position 1, and so
             on.  Then, when the reader reads in a string-reference it can just retrieved it directly from that array.
            
             In other words, writing and reading take advantage of the fact that they know they will write and read
             strings in the exact same order.  So they only need the IDs for references and not the strings themselves
             because the ID is inferred from the order the object is written or read in.
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectWriter"/>.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <inheritdoc cref="M:Roslyn.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean)"/>
            <param name="writeValidationBytes">Whether or not the validation bytes (see <see cref="M:Roslyn.Utilities.ObjectWriter.WriteValidationBytes"/>)
            should be immediately written into the stream.</param>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteValidationBytes">
            <summary>
            Writes out a special sequence of bytes indicating that the stream is a serialized object stream.  Used by the
            <see cref="T:Roslyn.Utilities.ObjectReader"/> to be able to easily detect if it is being improperly used, or if the stream is
            corrupt.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.GuidAccessor">
            <summary>
            Used so we can easily grab the low/high 64bits of a guid for serialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteScalarValue(System.Object)">
            <summary>
            Only supports values of primitive scaler types.  This really should only be used to emit VB preprocessor
            symbol values (which are scaler, but untyped as 'object').  Callers which know their value's type should
            call into that directly.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.WriteSpan(System.ReadOnlySpan{System.Byte})">
            <summary>
            Write an array of bytes. The array data is provided as a <see
            cref="T:System.ReadOnlySpan`1">ReadOnlySpan</see>&lt;<see cref="T:System.Byte"/>&gt;, and deserialized to a byte array.
            </summary>
            <param name="span">The array data.</param>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Null">
            <summary>
            The null value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.StringUtf8">
            <summary>
            A string encoded as UTF-8 (using BinaryWriter.Write(string))
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.StringUtf16">
            <summary>
            A string encoded as UTF16 (as array of UInt16 values)
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.StringRef_1Byte">
            <summary>
            A reference to a string with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.StringRef_2Bytes">
            <summary>
            A reference to a string with the id encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.StringRef_4Bytes">
            <summary>
            A reference to a string with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Boolean_True">
            <summary>
            The boolean value true.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Boolean_False">
            <summary>
            The boolean value char.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Char">
            <summary>
            A character value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int8">
            <summary>
            An Int8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int16">
            <summary>
            An Int16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32">
            <summary>
            An Int32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_1Byte">
            <summary>
            An Int32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_2Bytes">
            <summary>
            An Int32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_0">
            <summary>
            The Int32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_1">
            <summary>
            The Int32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_2">
            <summary>
            The Int32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_3">
            <summary>
            The Int32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_4">
            <summary>
            The Int32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_5">
            <summary>
            The Int32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_6">
            <summary>
            The Int32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_7">
            <summary>
            The Int32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_8">
            <summary>
            The Int32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_9">
            <summary>
            The Int32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int32_10">
            <summary>
            The Int32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Int64">
            <summary>
            An Int64 value encoded as 8 bytes
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt8">
            <summary>
            A UInt8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt16">
            <summary>
            A UIn16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32">
            <summary>
            A UInt32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_1Byte">
            <summary>
            A UInt32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_2Bytes">
            <summary>
            A UInt32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_0">
            <summary>
            The UInt32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_1">
            <summary>
            The UInt32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_2">
            <summary>
            The UInt32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_3">
            <summary>
            The UInt32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_4">
            <summary>
            The UInt32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_5">
            <summary>
            The UInt32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_6">
            <summary>
            The UInt32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_7">
            <summary>
            The UInt32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_8">
            <summary>
            The UInt32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_9">
            <summary>
            The UInt32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt32_10">
            <summary>
            The UInt32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.UInt64">
            <summary>
            A UInt64 value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Float4">
            <summary>
            A float value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Float8">
            <summary>
            A double value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Decimal">
            <summary>
            A decimal value encoded as 12 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.DateTime">
            <summary>
            A DateTime value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Array">
            <summary>
            An array with length encoded as compressed uint
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Array_0">
            <summary>
            An array with zero elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Array_1">
            <summary>
            An array with one element
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Array_2">
            <summary>
            An array with 2 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.Array_3">
            <summary>
            An array with 3 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.EncodingName">
            <summary>
            Encoding serialized as <see cref="P:System.Text.Encoding.WebName"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.FirstWellKnownTextEncoding">
            <summary>
            Encoding serialized as <see cref="T:Microsoft.CodeAnalysis.TextEncodingKind"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.TypeCode.EncodingCodePage">
            <summary>
            Encoding serialized as <see cref="P:System.Text.Encoding.CodePage"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.WriterReferenceMap">
            <summary>
            An object reference to reference-id map, that can share base data efficiently.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AnnotationTable`1">
            <summary>
            An AnnotationTable helps you attach your own annotation types/instances to syntax.  
            
            It maintains a map between your instances and actual SyntaxAnnotation's used to annotate the nodes
            and offers an API that matches the true annotation API on SyntaxNode.
            
            The table controls the lifetime of when you can find and retrieve your annotations. You won't be able to 
            find your annotations via HasAnnotations/GetAnnotations unless you use the same annotation table for these operations
            that you used for the WithAdditionalAnnotations operation.  
            
            Your custom annotations are not serialized with the syntax tree, so they won't move across boundaries unless the 
            same AnnotationTable is available on both ends.
            
            also, note that this table is not thread safe.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AnnotationTable`1.#ctor(System.String)">
            <summary>
            An AnnotationTable helps you attach your own annotation types/instances to syntax.  
            
            It maintains a map between your instances and actual SyntaxAnnotation's used to annotate the nodes
            and offers an API that matches the true annotation API on SyntaxNode.
            
            The table controls the lifetime of when you can find and retrieve your annotations. You won't be able to 
            find your annotations via HasAnnotations/GetAnnotations unless you use the same annotation table for these operations
            that you used for the WithAdditionalAnnotations operation.  
            
            Your custom annotations are not serialized with the syntax tree, so they won't move across boundaries unless the 
            same AnnotationTable is available on both ends.
            
            also, note that this table is not thread safe.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1">
            <summary>
            Represents a value that can be retrieved synchronously or asynchronously by many clients.
            The value will be computed on-demand the moment the first client asks for it. While being
            computed, more clients can request the value. As long as there are outstanding clients the
            underlying computation will proceed.  If all outstanding clients cancel their request then
            the underlying value computation will be cancelled as well.
            
            Creators of an <see cref="T:Roslyn.Utilities.AsyncLazy`1" /> can specify whether the result of the computation is
            cached for future requests or not. Choosing to not cache means the computation functions are kept
            alive, whereas caching means the value (but not functions) are kept alive once complete.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._asynchronousComputeFunction">
            <summary>
            The underlying function that starts an asynchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it.  Otherwise,
            it is kept around in case the value needs to be computed again.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._synchronousComputeFunction">
            <summary>
            The underlying function that starts a synchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it, or if we
            didn't get any synchronous function given to us in the first place.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._cachedResult">
            <summary>
            The Task that holds the cached result.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.SyncObject">
            <summary>
            Mutex used to protect reading and writing to all mutable objects and fields.  Traces indicate that there's
            negligible contention on this lock (and on any particular async-lazy in general), hence we can save some
            memory by using ourselves as the lock, even though this may inhibit cancellation.  Work done while holding
            the lock should be kept to a minimum.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._requests">
            <summary>
            The hash set of all currently outstanding asynchronous requests. Null if there are no requests,
            and will never be empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._asynchronousComputationCancellationSource">
            <summary>
            If an asynchronous request is active, the CancellationTokenSource that allows for
            cancelling the underlying computation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1._computationActive">
            <summary>
            Whether a computation is active or queued on any thread, whether synchronous or
            asynchronous.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.#ctor(`0)">
            <summary>
            Creates an AsyncLazy that always returns the value, analogous to <see cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.#ctor(System.Func{`1,System.Threading.CancellationToken,System.Threading.Tasks.Task{`0}},System.Func{`1,System.Threading.CancellationToken,`0},`1)">
            <summary>
            Creates an AsyncLazy that supports both asynchronous computation and inline synchronous
            computation.
            </summary>
            <param name="asynchronousComputeFunction">A function called to start the asynchronous
            computation. This function should be cheap and non-blocking.</param>
            <param name="synchronousComputeFunction">A function to do the work synchronously, which
            is allowed to block. This function should not be implemented by a simple Wait on the
            asynchronous value. If that's all you are doing, just don't pass a synchronous function
            in the first place.</param>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.TakeLock(System.Threading.CancellationToken)">
            <summary>
            Takes the lock for this object and if acquired validates the invariants of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.Request">
            <remarks>
            This inherits from <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> to avoid allocating two objects when we can just use one.
            The public surface area of <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> should probably be avoided in favor of the public
            methods on this class for correct behavior.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.AsyncLazyImpl`1.Request._cancellationToken">
            <summary>
            The <see cref="T:System.Threading.CancellationToken"/> associated with this request. This field will be initialized before
            any cancellation is observed from the token.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.BKTree">
            <summary>
            NOTE: Only use if you truly need a BK-tree.  If you just want to compare words, use the 'SpellChecker' type
            instead.
            <para/>
            An implementation of a Burkhard-Keller tree.  Introduced in:
            <para/>
            'Some approaches to best-match file searching.' Communications of the ACM CACM Volume 16 Issue 4, April 1973
            Pages 230-236 http://dl.acm.org/citation.cfm?doid=362003.362025.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree._concatenatedLowerCaseWords">
            <summary>
            We have three completely flat arrays of structs.  These arrays fully represent the BK tree.  The structure
            is as follows:
            <para/>
            The root node is in _nodes[0].
            <para/>
            It lists the count of edges it has.  These edges are in _edges in the range [0*, childCount).  Each edge has
            the index of the child node it points to, and the edit distance between the parent and the child.
            <para/>
            * of course '0' is only for the root case.
            <para/>
            All nodes state where in _edges their child edges range starts, so the children for any node are in the
            range[node.FirstEdgeIndex, node.FirstEdgeIndex + node.EdgeCount).
            <para/>
            Each node also has an associated string.  These strings are concatenated and stored in
            _concatenatedLowerCaseWords.  Each node has a TextSpan that indicates which portion of the character array
            is their string.  Note: i'd like to use an immutable array for the characters as well.  However, we need to
            create slices, and they need to work on top of an ArraySlice (which needs a char[]).  The edit distance code
            also wants to work on top of raw char[]s (both for speed, and so it can pool arrays to prevent lots of
            garbage).  Because of that we just keep this as a char[].
            </summary> 
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Edge.ChildNodeIndex">
            <summary>Where the child node can be found in <see cref="F:Roslyn.Utilities.BKTree._nodes"/>.</summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.WordSpan">
            <summary>
            The string this node corresponds to.  Specifically, this span is the range of
            <see cref="F:Roslyn.Utilities.BKTree._concatenatedLowerCaseWords"/> for that string.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.EdgeCount">
            <summary>How many child edges this node has.</summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.FirstEdgeIndex">
            <summary>Where the first edge can be found in <see cref="F:Roslyn.Utilities.BKTree._edges"/>.  The edges 
            are in the range _edges[FirstEdgeIndex, FirstEdgeIndex + EdgeCount)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(System.Nullable{``0},System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,System.String,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,Roslyn.Utilities.Contract.ThrowIfNullInterpolatedStringHandler{``0},System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.String,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,Roslyn.Utilities.Contract.ThrowIfFalseInterpolatedStringHandler,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,System.String,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,Roslyn.Utilities.Contract.ThrowIfTrueInterpolatedStringHandler,System.Int32,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.EditDistance">
            <summary>
             NOTE: Only use if you truly need an edit distance.  If you just want to compare words, use
             the 'SpellChecker' type instead.
            
             Implementation of the Damerau-Levenshtein edit distance algorithm from:
             An Extension of the String-to-String Correction Problem:
             Published in Journal of the ACM (JACM)
             Volume 22 Issue 2, April 1975.
            
             Important, unlike many edit distance algorithms out there, this one implements a true metric
             that satisfies the triangle inequality.  (Unlike the "Optimal String Alignment" or "Restricted
             string edit distance" solutions which do not).  This means this edit distance can be used in
             other domains that require the triangle inequality (like BKTrees).
            
             Specifically, this implementation satisfies the following inequality: D(x, y) + D(y, z) >= D(x, z)
             (where D is the edit distance).
            </summary> 
        </member>
        <member name="M:Roslyn.Utilities.EditDistance.#ctor(System.String)">
            <summary>
             NOTE: Only use if you truly need an edit distance.  If you just want to compare words, use
             the 'SpellChecker' type instead.
            
             Implementation of the Damerau-Levenshtein edit distance algorithm from:
             An Extension of the String-to-String Correction Problem:
             Published in Journal of the ACM (JACM)
             Volume 22 Issue 2, April 1975.
            
             Important, unlike many edit distance algorithms out there, this one implements a true metric
             that satisfies the triangle inequality.  (Unlike the "Optimal String Alignment" or "Restricted
             string edit distance" solutions which do not).  This means this edit distance can be used in
             other domains that require the triangle inequality (like BKTrees).
            
             Specifically, this implementation satisfies the following inequality: D(x, y) + D(y, z) >= D(x, z)
             (where D is the edit distance).
            </summary> 
        </member>
        <member name="M:Roslyn.Utilities.IDictionaryExtensions.MultiRemoveSet``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)">
            <summary>
            Private implementation we can delegate to for sets.
            This must be a different name as overloads are not resolved based on constraints
            and would conflict with <see cref="M:Roslyn.Utilities.IDictionaryExtensions.MultiRemove``3(System.Collections.Generic.IDictionary{``0,``2},``0,``1)"/>
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.IReferenceCountedDisposable`1">
            <summary>
            A covariant interface form of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> that lets you re-cast an <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/>
            to a more base type. This can include types that do not implement <see cref="T:System.IDisposable"/> if you want to prevent a caller from accidentally
            disposing <see cref="P:Roslyn.Utilities.IReferenceCountedDisposable`1.Target"/> directly.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Roslyn.Utilities.IReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:System.IDisposable.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:System.IDisposable.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:System.IDisposable.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:System.IDisposable.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Roslyn.Utilities.IReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock">
            <summary>
            A lightweight mutual exclusion object which supports waiting with cancellation and prevents
            recursion (i.e. you may not call Wait if you already hold the lock)
            </summary>
            <remarks>
            <para>
            The <see cref="T:Roslyn.Utilities.NonReentrantLock"/> provides a lightweight mutual exclusion class that doesn't
            use Windows kernel synchronization primitives.
            </para>
            <para>
            The implementation is distilled from the workings of <see cref="T:System.Threading.SemaphoreSlim"/>
            The basic idea is that we use a regular sync object (Monitor.Enter/Exit) to guard the setting
            of an 'owning thread' field. If, during the Wait, we find the lock is held by someone else
            then we register a cancellation callback and enter a "Monitor.Wait" loop. If the cancellation
            callback fires, then it "pulses" all the waiters to wake them up and check for cancellation.
            Waiters are also "pulsed" when leaving the lock.
            </para>
            <para>
            All public members of <see cref="T:Roslyn.Utilities.NonReentrantLock"/> are thread-safe and may be used concurrently
            from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._syncLock">
            <summary>
            A synchronization object to protect access to the <see cref="F:Roslyn.Utilities.NonReentrantLock._owningThreadId"/> field and to be pulsed
            when <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/> is called and during cancellation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._owningThreadId">
            <summary>
            The <see cref="P:System.Environment.CurrentManagedThreadId" /> of the thread that holds the lock. Zero if no thread is holding
            the lock.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="useThisInstanceForSynchronization">If false (the default), then the class
            allocates an internal object to be used as a sync lock.
            If true, then the sync lock object will be the NonReentrantLock instance itself. This
            saves an allocation but a client may not safely further use this instance in a call to
            Monitor.Enter/Exit or in a "lock" statement.
            </param>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.Factory">
            <summary>
            Shared factory for use in lazy initialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:Roslyn.Utilities.NonReentrantLock"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <remarks>
            Recursive locking is not supported. i.e. A thread may not call Wait successfully twice without an
            intervening <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/>.
            </remarks>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <exception cref="T:System.Threading.LockRecursionException">The caller already holds the lock</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Release">
            <summary>
            Exit the mutual exclusion.
            </summary>
            <remarks>
            The calling thread must currently hold the lock.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.LockHeldByMe">
            <summary>
            Determine if the lock is currently held by the calling thread.
            </summary>
            <returns>True if the lock is currently held by the calling thread.</returns>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.AssertHasLock">
            <summary>
            Throw an exception if the lock is not held by the calling thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsLocked">
            <summary>
            Checks if the lock is currently held.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsOwnedByMe">
            <summary>
            Checks if the lock is currently held by the calling thread.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.TakeOwnership">
            <summary>
            Take ownership of the lock (by the calling thread). The lock may not already
            be held by any other code.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.ReleaseOwnership">
            <summary>
            Release ownership of the lock. The lock must already be held by the calling thread.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.s_cancellationTokenCanceledEventHandler">
            <summary>
            Action object passed to a cancellation token registration.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.CancellationTokenCanceledEventHandler(System.Object)">
            <summary>
            Callback executed when a cancellation token is canceled during a Wait.
            </summary>
            <param name="obj">The syncLock that protects a <see cref="T:Roslyn.Utilities.NonReentrantLock"/> instance.</param>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock.SemaphoreDisposer">
            <summary>
            Since we want to avoid boxing the return from <see cref="M:Roslyn.Utilities.NonReentrantLock.DisposableWait(System.Threading.CancellationToken)"/>, this type must be public.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.SemaphoreDisposer.#ctor(Roslyn.Utilities.NonReentrantLock)">
            <summary>
            Since we want to avoid boxing the return from <see cref="M:Roslyn.Utilities.NonReentrantLock.DisposableWait(System.Threading.CancellationToken)"/>, this type must be public.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1">
             <summary>
             A reference-counting wrapper which allows multiple uses of a single disposable object in code, which is
             deterministically released (by calling <see cref="M:System.IDisposable.Dispose"/>) when the last reference is
             disposed.
             </summary>
             <remarks>
             <para>Each instance of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> represents a counted reference (also
             referred to as a <em>reference</em> in the following documentation) to a target object. Each of these
             references has a lifetime, starting when it is constructed and continuing through its release. During
             this time, the reference is considered <em>alive</em>. Each reference which is alive owns exactly one
             reference to the target object, ensuring that it will not be disposed while still in use. A reference is
             released through either of the following actions:</para>
            
             <list type="bullet">
             <item>The reference is explicitly released by a call to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>.</item>
             <item>The reference is no longer in use by managed code and gets reclaimed by the garbage collector.</item>
             </list>
            
             <para>While each instance of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> should be explicitly disposed when
             the object is no longer needed by the code owning the reference, this implementation will not leak resources
             in the event one or more callers fail to do so. When all references to an object are explicitly released
             (i.e. by calling <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>), the target object will itself be deterministically released by a
             call to <see cref="M:System.IDisposable.Dispose"/> when the last reference to it is released. However, in the event
             one or more references is not explicitly released, the underlying object will still become eligible for
             non-deterministic release (i.e. finalization) as soon as each reference to it is released by one of the
             two actions described previously.</para>
            
             <para>When using <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/>, certain steps must be taken to ensure the
             target object is not disposed early.</para>
            
             <list type="number">
             <para>Use <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> consistently. In other words, do not mix code using
             reference-counted wrappers with code that references to the target directly.</para>
             <para>Only use the <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.#ctor(`0)"/> constructor one time per target object.
             Additional references to the same target object must only be obtained by calling
             <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/>.</para>
             <para>Do not call <see cref="M:System.IDisposable.Dispose"/> on the target object directly. It will be called
             automatically at the appropriate time, as described above.</para>
             </list>
            
             <para>All public methods on this type adhere to their pre- and post-conditions and will not invalidate state
             even in concurrent execution.</para>
             </remarks>
             <typeparam name="T">The type of disposable object.</typeparam>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1._instance">
            <summary>
            The target of this reference. This value is initialized to a non-<see langword="null"/> value in the
            constructor, and set to <see langword="null"/> when the current reference is disposed.
            </summary>
            <remarks>
            <para>This value is only cleared in order to support cases where one or more references is garbage
            collected without having <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> called.</para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1._boxedReferenceCount">
             <summary>
             The boxed reference count, which is shared by all references with the same <see cref="P:Roslyn.Utilities.ReferenceCountedDisposable`1.Target"/> object.
             </summary>
             <remarks>
             <para>This field serves as the synchronization object for the current type, since it is shared among all
             counted reference to the same target object. Accesses to <see cref="F:Roslyn.Utilities.ReferenceCountedDisposable`1.BoxedReferenceCount._referenceCount"/>
             should only occur when this object is locked.</para>
            
             <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
             available in source control history. The use of exclusive locks was not causing any measurable
             performance overhead even on 28-thread machines at the time this was written.</para>
             </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.#ctor(`0)">
            <summary>
            Initializes a new reference counting wrapper around an <see cref="T:System.IDisposable"/> object.
            </summary>
            <remarks>
            <para>The reference count is initialized to 1.</para>
            </remarks>
            <param name="instance">The object owned by this wrapper.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="instance"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:Roslyn.Utilities.ReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReferenceImpl(`0,Roslyn.Utilities.ReferenceCountedDisposable{`0}.BoxedReferenceCount)">
            <summary>
            Provides the implementation for <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/> and
            <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference.TryAddReference"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose">
            <summary>
            Releases the current reference, causing the underlying object to be disposed if this was the last
            reference.
            </summary>
            <remarks>
            <para>After this instance is disposed, the <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/> method can no longer be used to
            obtain a new reference to the target, even if other references to the target object are still in
            use.</para>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference">
            <summary>
            Represents a weak reference to a <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> which is capable of
            obtaining a new counted reference up until the point when the object is no longer accessible.
            </summary>
            <remarks>
            This value type holds a single field, which is not subject to torn reads/writes.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference.TryAddReference">
             <summary>
             Increments the reference count for the disposable object, and returns a new disposable reference to
             it.
             </summary>
             <remarks>
             <para>Unlike <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/>, this method is capable of
             adding a reference to the underlying instance all the way up to the point where it is finally
             disposed.</para>
            
             <para>The returned object is an independent reference to the same underlying object. Disposing of
             the returned value multiple times will only cause the reference count to be decreased once.</para>
             </remarks>
             <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object,
             if it has not yet been disposed; otherwise, <see langword="null"/> if the underlying object has
             already been disposed.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1.BoxedReferenceCount">
            <summary>
            Holds the reference count associated with a disposable object.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.BoxedReferenceCount.#ctor(System.Int32)">
            <summary>
            Holds the reference count associated with a disposable object.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1.BoxedReferenceCount._weakInstance">
            <summary>
            Holds the weak reference used by instances of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference"/> to obtain a reference-counted
            reference to the original object. This field is initialized the first time a weak reference is obtained
            for the instance, and latches in a non-null state once initialized.
            </summary>
            <remarks>
            DO NOT DISPOSE OF THE TARGET.
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposableCache`2">
            <summary>
            Implements a reference-counted cache, where key/value pairs are associated with a count. When the count of a pair goes to zero,
            the value is evicted. Values can also be explicitly evicted at any time. In that case, any new calls to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposableCache`2.GetOrCreate``1(`0,System.Func{`0,``0,`1},``0)"/>
            will return a new value, and the existing holders of the evicted value will still dispose it once they're done with it.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SemaphoreSlimFactory">
            <summary>
            Container for a <see cref="T:System.Threading.SemaphoreSlim"/> factory.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SemaphoreSlimFactory.Instance">
            <summary>
            Factory object that may be used for lazy initialization. Creates AsyncSemaphore instances with an initial count of 1.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SoftCrashException">
            <summary>
            TODO: remove this exception: https://github.com/dotnet/roslyn/issues/40476
            
            this represents soft crash request compared to hard crash which will bring down VS.
            
            by soft crash, it means everything same as hard crash except it should use NFW and info bar
            to inform users about unexpected condition instead of killing VS as traditional crash did.
            
            in other words, no one should ever try to recover from this exception. but they must try to not hard crash.
            
            this exception is based on cancellation exception since, in Roslyn code, cancellation exception is so far
            only safest exception to throw without worrying about crashing VS 99%. there is still 1% case it will bring
            down VS and those places should be guarded on this exception as we find such place.
            
            for now, this is an opt-in based. if a feature wants to move to soft crash (ex, OOP), one should catch
            exception and translate that to this exception and then add handler which report NFW and info bar in their
            code path and make sure it doesn't bring down VS.
            
            as we use soft-crash in more places, we should come up with more general framework.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SpecializedTasks.TransformWithoutIntermediateCancellationExceptionAsync``3(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.ValueTask{``1}},System.Func{``1,``0,``2},``0,System.Threading.CancellationToken)">
             <summary>
             This helper method provides semantics equivalent to the following, but avoids throwing an intermediate
             <see cref="T:System.OperationCanceledException"/> in the case where the asynchronous operation is cancelled.
            
             <code><![CDATA[
             public ValueTask<TResult> MethodAsync(TArg arg, CancellationToken cancellationToken)
             {
               var intermediate = await func(arg, cancellationToken).ConfigureAwait(false);
               return transform(intermediate);
             }
             ]]></code>
             </summary>
             <remarks>
             This helper method is only intended for use in cases where profiling reveals substantial overhead related to
             cancellation processing.
             </remarks>
             <typeparam name="TArg">The type of a state variable to pass to <paramref name="func"/> and <paramref name="transform"/>.</typeparam>
             <typeparam name="TIntermediate">The type of intermediate result produced by <paramref name="func"/>.</typeparam>
             <typeparam name="TResult">The type of result produced by <paramref name="transform"/>.</typeparam>
             <param name="func">The intermediate asynchronous operation.</param>
             <param name="transform">The synchronous transformation to apply to the result of <paramref name="func"/>.</param>
             <param name="arg">The state to pass to <paramref name="func"/> and <paramref name="transform"/>.</param>
             <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> that the operation will observe.</param>
             <returns></returns>
        </member>
        <member name="M:Roslyn.Utilities.ValueTaskExtensions.VerifyCompleted``1(System.Threading.Tasks.ValueTask{``0},System.String)">
            <summary>
            Asserts the <see cref="T:System.Threading.Tasks.ValueTask"/> passed has already been completed.
            </summary>
            <remarks>
            This is useful for a specific case: sometimes you might be calling an API that is "sometimes" async, and you're
            calling it from a synchronous method where you know it should have completed synchronously. This is an easy
            way to assert that while silencing any compiler complaints.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.WordSimilarityChecker._substringsAreSimilar">
            <summary>
            Whether or words should be considered similar if one is contained within the other
            (regardless of edit distance).  For example if is true then IService would be considered
            similar to IServiceFactory despite the edit distance being quite high at 7.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WordSimilarityChecker.AreSimilar(System.String,System.String,System.Boolean,System.Double@)">
            <summary>
            Returns true if 'originalText' and 'candidateText' are likely a misspelling of each other.
            Returns false otherwise.  If it is a likely misspelling a similarityWeight is provided
            to help rank the match.  Lower costs mean it was a better match.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SyntaxPath">
            <summary>
            Stores the "path" from the root of a tree to a node, allowing the node to be recovered in a
            later snapshot of the tree, under certain circumstances.
            
            The implementation stores the child indices to represent the path, so any edit which affects
            the child indices could render this object unable to recover its node.  NOTE: One thing C#
            IDE has done in the past to do a better job of this is to store the fully qualified name of
            the member to at least be able to descend into the same member.  We could apply the same sort
            of logic here.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SyntaxPath.TryResolve(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNodeOrToken@)">
            <summary>
            Attempts to recover the node at this path in the provided tree.  If the node is found
            then 'true' is returned, otherwise the result is 'false' and 'node' will be null.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.TaskExtensions.VerifyCompleted(System.Threading.Tasks.Task)">
            <summary>
            Asserts the <see cref="T:System.Threading.Tasks.Task"/> passed has already been completed.
            </summary>
            <remarks>
            This is useful for a specific case: sometimes you might be calling an API that is "sometimes" async, and you're
            calling it from a synchronous method where you know it should have completed synchronously. This is an easy
            way to assert that while silencing any compiler complaints.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.TaskExtensions.VerifyCompleted``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Asserts the <see cref="T:System.Threading.Tasks.Task"/> passed has already been completed.
            </summary>
            <remarks>
            This is useful for a specific case: sometimes you might be calling an API that is "sometimes" async, and you're
            calling it from a synchronous method where you know it should have completed synchronously. This is an easy
            way to assert that while silencing any compiler complaints.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EventHandlerFactory`1.CreateWeakHandler``1(``0,System.Action{``0,System.Object,`0})">
            <summary>
            Creates an event handler that holds onto the target weakly.
            </summary>
            <param name="target">The target that is held weakly, and passed as an argument to the invoker.</param>
            <param name="invoker">An action that will receive the event arguments as well as the target instance. 
            The invoker itself must not capture any state.</param>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using
            <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
        <member name="T:System.IO.Hashing.NonCryptographicHashAlgorithm">
            <summary>
              Represents a non-cryptographic hash algorithm.
            </summary>
        </member>
        <member name="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes">
            <summary>
              Gets the number of bytes produced from this hash algorithm.
            </summary>
            <value>The number of bytes produced from this hash algorithm.</value>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.#ctor(System.Int32)">
            <summary>
              Called from constructors in derived classes to initialize the
              <see cref="T:System.IO.Hashing.NonCryptographicHashAlgorithm"/> class.
            </summary>
            <param name="hashLengthInBytes">
              The number of bytes produced from this hash algorithm.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              <paramref name="hashLengthInBytes"/> is less than 1.
            </exception>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.Append(System.ReadOnlySpan{System.Byte})">
            <summary>
              When overridden in a derived class,
              appends the contents of <paramref name="source"/> to the data already
              processed for the current hash computation.
            </summary>
            <param name="source">The data to process.</param>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.Reset">
            <summary>
              When overridden in a derived class,
              resets the hash computation to the initial state.
            </summary>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetCurrentHashCore(System.Span{System.Byte})">
            <summary>
              When overridden in a derived class,
              writes the computed hash value to <paramref name="destination"/>
              without modifying accumulated state.
            </summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
            <remarks>
              <para>
                Implementations of this method must write exactly
                <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/> bytes to <paramref name="destination"/>.
                Do not assume that the buffer was zero-initialized.
              </para>
              <para>
                The <see cref="T:System.IO.Hashing.NonCryptographicHashAlgorithm"/> class validates the
                size of the buffer before calling this method, and slices the span
                down to be exactly <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/> in length.
              </para>
            </remarks>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.Append(System.Byte[])">
            <summary>
              Appends the contents of <paramref name="source"/> to the data already
              processed for the current hash computation.
            </summary>
            <param name="source">The data to process.</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="source"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.Append(System.IO.Stream)">
            <summary>
              Appends the contents of <paramref name="stream"/> to the data already
              processed for the current hash computation.
            </summary>
            <param name="stream">The data to process.</param>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="stream"/> is <see langword="null"/>.
            </exception>
            <seealso cref="M:System.IO.Hashing.NonCryptographicHashAlgorithm.AppendAsync(System.IO.Stream,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.AppendAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
              Asychronously reads the contents of <paramref name="stream"/>
              and appends them to the data already
              processed for the current hash computation.
            </summary>
            <param name="stream">The data to process.</param>
            <param name="cancellationToken">
              The token to monitor for cancellation requests.
              The default value is <see cref="P:System.Threading.CancellationToken.None"/>.
            </param>
            <returns>
              A task that represents the asynchronous append operation.
            </returns>
            <exception cref="T:System.ArgumentNullException">
              <paramref name="stream"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetCurrentHash">
            <summary>
              Gets the current computed hash value without modifying accumulated state.
            </summary>
            <returns>
              The hash value for the data already provided.
            </returns>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.TryGetCurrentHash(System.Span{System.Byte},System.Int32@)">
            <summary>
              Attempts to write the computed hash value to <paramref name="destination"/>
              without modifying accumulated state.
            </summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
            <param name="bytesWritten">
              On success, receives the number of bytes written to <paramref name="destination"/>.
            </param>
            <returns>
              <see langword="true"/> if <paramref name="destination"/> is long enough to receive
              the computed hash value; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetCurrentHash(System.Span{System.Byte})">
            <summary>
              Writes the computed hash value to <paramref name="destination"/>
              without modifying accumulated state.
            </summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
            <returns>
              The number of bytes written to <paramref name="destination"/>,
              which is always <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
              <paramref name="destination"/> is shorter than <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/>.
            </exception>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetHashAndReset">
            <summary>
              Gets the current computed hash value and clears the accumulated state.
            </summary>
            <returns>
              The hash value for the data already provided.
            </returns>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.TryGetHashAndReset(System.Span{System.Byte},System.Int32@)">
            <summary>
              Attempts to write the computed hash value to <paramref name="destination"/>.
              If successful, clears the accumulated state.
            </summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
            <param name="bytesWritten">
              On success, receives the number of bytes written to <paramref name="destination"/>.
            </param>
            <returns>
              <see langword="true"/> and clears the accumulated state
              if <paramref name="destination"/> is long enough to receive
              the computed hash value; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetHashAndReset(System.Span{System.Byte})">
            <summary>
              Writes the computed hash value to <paramref name="destination"/>
              then clears the accumulated state.
            </summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
            <returns>
              The number of bytes written to <paramref name="destination"/>,
              which is always <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
              <paramref name="destination"/> is shorter than <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/>.
            </exception>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetHashAndResetCore(System.Span{System.Byte})">
            <summary>
              Writes the computed hash value to <paramref name="destination"/>
              then clears the accumulated state.
            </summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
            <remarks>
              <para>
                Implementations of this method must write exactly
                <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/> bytes to <paramref name="destination"/>.
                Do not assume that the buffer was zero-initialized.
              </para>
              <para>
                The <see cref="T:System.IO.Hashing.NonCryptographicHashAlgorithm"/> class validates the
                size of the buffer before calling this method, and slices the span
                down to be exactly <see cref="P:System.IO.Hashing.NonCryptographicHashAlgorithm.HashLengthInBytes"/> in length.
              </para>
              <para>
                The default implementation of this method calls
                <see cref="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetCurrentHashCore(System.Span{System.Byte})"/> followed by <see cref="M:System.IO.Hashing.NonCryptographicHashAlgorithm.Reset"/>.
                Overrides of this method do not need to call either of those methods,
                but must ensure that the caller cannot observe a difference in behavior.
              </para>
            </remarks>
        </member>
        <member name="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetHashCode">
            <summary>
              This method is not supported and should not be called.
              Call <see cref="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetCurrentHash"/> or <see cref="M:System.IO.Hashing.NonCryptographicHashAlgorithm.GetHashAndReset"/>
              instead.
            </summary>
            <returns>This method will always throw a <see cref="T:System.NotSupportedException"/>.</returns>
            <exception cref="T:System.NotSupportedException">In all cases.</exception>
        </member>
        <member name="T:System.IO.Hashing.XxHash128">
            <summary>Provides an implementation of the XXH128 hash algorithm for generating a 128-bit hash.</summary>
            <remarks>
            For methods that persist the computed numerical hash value as bytes,
            the value is written in the Big Endian byte order.
            </remarks>
        </member>
        <member name="F:System.IO.Hashing.XxHash128.HashLengthInBytes">
            <summary>XXH128 produces 16-byte hashes.</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.IO.Hashing.XxHash128"/> class using the default seed value 0.</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.#ctor(System.Int64)">
            <summary>Initializes a new instance of the <see cref="T:System.IO.Hashing.XxHash128"/> class using the specified seed.</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.Hash(System.Byte[])">
            <summary>Computes the XXH128 hash of the provided <paramref name="source"/> data.</summary>
            <param name="source">The data to hash.</param>
            <returns>The XXH128 128-bit hash code of the provided data.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.Hash(System.Byte[],System.Int64)">
            <summary>Computes the XXH128 hash of the provided data using the provided seed.</summary>
            <param name="source">The data to hash.</param>
            <param name="seed">The seed value for this hash computation.</param>
            <returns>The XXH128 128-bit hash code of the provided data.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="source"/> is null.</exception>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.Hash(System.ReadOnlySpan{System.Byte},System.Int64)">
            <summary>Computes the XXH128 hash of the provided <paramref name="source"/> data using the optionally provided <paramref name="seed"/>.</summary>
            <param name="source">The data to hash.</param>
            <param name="seed">The seed value for this hash computation. The default is zero.</param>
            <returns>The XXH128 128-bit hash code of the provided data.</returns>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.Hash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int64)">
            <summary>Computes the XXH128 hash of the provided <paramref name="source"/> data into the provided <paramref name="destination"/> using the optionally provided <paramref name="seed"/>.</summary>
            <param name="source">The data to hash.</param>
            <param name="destination">The buffer that receives the computed 128-bit hash code.</param>
            <param name="seed">The seed value for this hash computation. The default is zero.</param>
            <returns>The number of bytes written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="destination"/> is shorter than <see cref="F:System.IO.Hashing.XxHash128.HashLengthInBytes"/> (16 bytes).</exception>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.TryHash(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.Int32@,System.Int64)">
            <summary>Attempts to compute the XXH128 hash of the provided <paramref name="source"/> data into the provided <paramref name="destination"/> using the optionally provided <paramref name="seed"/>.</summary>
            <param name="source">The data to hash.</param>
            <param name="destination">The buffer that receives the computed 128-bit hash code.</param>
            <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination"/>.</param>
            <param name="seed">The seed value for this hash computation. The default is zero.</param>
            <returns><see langword="true"/> if <paramref name="destination"/> is long enough to receive the computed hash value (16 bytes); otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.HashToUInt128(System.ReadOnlySpan{System.Byte},System.Int64)">
            <summary>Computes the XXH128 hash of the provided data.</summary>
            <param name="source">The data to hash.</param>
            <param name="seed">The seed value for this hash computation. The default is zero.</param>
            <returns>The computed XXH128 hash.</returns>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.Reset">
            <summary>Resets the hash computation to the initial state.</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.Append(System.ReadOnlySpan{System.Byte})">
            <summary>Appends the contents of <paramref name="source"/> to the data already processed for the current hash computation.</summary>
            <param name="source">The data to process.</param>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.GetCurrentHashCore(System.Span{System.Byte})">
            <summary>Writes the computed 128-bit hash value to <paramref name="destination"/> without modifying accumulated state.</summary>
            <param name="destination">The buffer that receives the computed hash value.</param>
        </member>
        <member name="M:System.IO.Hashing.XxHash128.GetCurrentHashAsUInt128">
            <summary>Gets the current computed hash value without modifying accumulated state.</summary>
            <returns>The hash value for the data already provided.</returns>
        </member>
        <member name="P:System.IO.Hashing.XxHashShared.DefaultSecret">
            <summary>The default secret for when no seed is provided.</summary>
            <remarks>This is the same as a custom secret derived from a seed of 0.</remarks>
        </member>
        <member name="M:System.IO.Hashing.XxHashShared.Multiply32To64(System.UInt32,System.UInt32)">
            <summary>Calculates a 32-bit to 64-bit long multiply.</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHashShared.Avalanche(System.UInt64)">
            <summary>"This is a fast avalanche stage, suitable when input bits are already partially mixed."</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHashShared.Multiply64To128ThenFold(System.UInt64,System.UInt64)">
            <summary>Calculates a 64-bit to 128-bit multiply, then XOR folds it.</summary>
        </member>
        <member name="M:System.IO.Hashing.XxHashShared.Accumulate(System.UInt64*,System.Byte*,System.Byte*,System.Int32,System.Boolean,System.Int32)">
            <summary>Optimized version of looping over <see cref="M:System.IO.Hashing.XxHashShared.Accumulate512(System.UInt64*,System.Byte*,System.Byte*)"/>.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.Accumulators">
            <summary>The accumulators. Length is <see cref="F:System.IO.Hashing.XxHashShared.AccumulatorCount"/>.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.Secret">
            <summary>Used to store a custom secret generated from a seed. Length is <see cref="F:System.IO.Hashing.XxHashShared.SecretLengthBytes"/>.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.Buffer">
            <summary>The internal buffer. Length is <see cref="F:System.IO.Hashing.XxHashShared.InternalBufferLengthBytes"/>.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.BufferedCount">
            <summary>The amount of memory in <see cref="F:System.IO.Hashing.XxHashShared.State.Buffer"/>.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.StripesProcessedInCurrentBlock">
            <summary>Number of stripes processed in the current block.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.TotalLength">
            <summary>Total length hashed.</summary>
        </member>
        <member name="F:System.IO.Hashing.XxHashShared.State.Seed">
            <summary>The seed employed (possibly 0).</summary>
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>
            Declare the following extension methods in System.Linq namespace to avoid accidental boxing of ImmutableArray{T} that implements IEnumerable{T}.
            The boxing would occur if the methods were defined in Roslyn.Utilities and the file calling these methods has <c>using Roslyn.Utilities</c>
            but not <c>using System.Linq</c>.
            </summary>
        </member>
        <member name="T:System.Linq.ImmutableSegmentedListExtensions">
            <seealso cref="T:System.Linq.ImmutableArrayExtensions"/>
        </member>
        <member name="T:FixedSizeArrayBuilder`1">
            <summary>
            A bare-bones array builder, focused on the case of producing <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>s where the final array
            size is known at construction time.  In the golden path, where all the expected items are added to the builder, and
            <see cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/> is called, this type is entirely garbage free.  In the non-golden path (usually
            encountered when a cancellation token interrupts getting the final array), this will leak the intermediary array
            created to store the results.
            </summary>
            <remarks>
            This type should only be used when all of the following are true:
            <list type="number">
            <item>
            The number of elements is known up front, and is fixed.  In other words, it isn't just an initial-capacity, or a
            rough heuristic.  Rather it will always be the exact number of elements added.
            </item>
            <item>
            Exactly that number of elements is actually added prior to calling <see cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/>.  This means no
            patterns like "AddIfNotNull".
            </item>
            <item>
            The builder will be moved to an array (see <see cref="M:FixedSizeArrayBuilder`1.MoveToArray"/>) or <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> (see <see
            cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/>).
            </item>
            </list>
            If any of the above are not true (for example, the capacity is a rough hint, or the exact number of elements may not
            match the capacity specified, or if it's intended as a scratch buffer, and won't realize a final array), then <see
            cref="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.GetInstance(System.Int32,`0)"/> should be used instead.
            </remarks>
        </member>
        <member name="M:FixedSizeArrayBuilder`1.#ctor(System.Int32)">
            <summary>
            A bare-bones array builder, focused on the case of producing <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>s where the final array
            size is known at construction time.  In the golden path, where all the expected items are added to the builder, and
            <see cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/> is called, this type is entirely garbage free.  In the non-golden path (usually
            encountered when a cancellation token interrupts getting the final array), this will leak the intermediary array
            created to store the results.
            </summary>
            <remarks>
            This type should only be used when all of the following are true:
            <list type="number">
            <item>
            The number of elements is known up front, and is fixed.  In other words, it isn't just an initial-capacity, or a
            rough heuristic.  Rather it will always be the exact number of elements added.
            </item>
            <item>
            Exactly that number of elements is actually added prior to calling <see cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/>.  This means no
            patterns like "AddIfNotNull".
            </item>
            <item>
            The builder will be moved to an array (see <see cref="M:FixedSizeArrayBuilder`1.MoveToArray"/>) or <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> (see <see
            cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/>).
            </item>
            </list>
            If any of the above are not true (for example, the capacity is a rough hint, or the exact number of elements may not
            match the capacity specified, or if it's intended as a scratch buffer, and won't realize a final array), then <see
            cref="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.GetInstance(System.Int32,`0)"/> should be used instead.
            </remarks>
        </member>
        <member name="M:FixedSizeArrayBuilder`1.MoveToImmutable">
            <summary>
            Moves the underlying buffer out of control of this type, into the returned <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>. It
            is an error for a client of this type to specify a capacity and then attempt to call <see
            cref="M:FixedSizeArrayBuilder`1.MoveToImmutable"/> without that number of elements actually having been added to the builder.  This will
            throw if attempted.  This <see cref="T:FixedSizeArrayBuilder`1"/> is effectively unusable once this is called.
            The internal buffer will reset to an empty array, meaning no more items could ever be added to it.
            </summary>
        </member>
    </members>
</doc>
